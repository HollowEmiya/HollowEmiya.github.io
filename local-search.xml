<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Atmosphere Ⅱ</title>
    <link href="/2025/09/10/Atmosphere%20%E2%85%A1/"/>
    <url>/2025/09/10/Atmosphere%20%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>搜寻找关键卡了，再战atmosphere，补充。<br /><span id="more"></span></p><h1 id="atmosphere-ⅱ">Atmosphere Ⅱ</h1><h2 id="transmittance">Transmittance</h2><p>当光在大气中从点 <span class="math inline">\(p\)</span> 传播至点<span class="math inline">\(q\)</span>时，由于空气分子和气溶胶粒子的作用，光被部分吸收并发生散射偏离初始的传播方向。因此，到达<span class="math inline">\(q\)</span> 点的光只是从 <spanclass="math inline">\(p\)</span>点出发的一部分，这一比例和波长相关，被称为 <ahref="https://en.wikipedia.org/wiki/Transmittance">transmittance</a><font color=#A0A0A0>(透射率)</font>。接下来我们会描述如何计算，在预计算Texture中存储，并如何读取回来。</p><h3 id="computation">Computation</h3><p>对于在大气中共线的三点 <spanclass="math inline">\(p,q,r\)</span>，按照这个顺序，<spanclass="math inline">\(p,r\)</span> 之间的透射率等于 <spanclass="math inline">\(p,q\)</span> 之间的透射率乘上 <spanclass="math inline">\(q,r\)</span>之间的透射率。<font color=#ADADAD>这里的 <spanclass="math inline">\(p,q,r\)</span> 和下图无关。</font><br />特别的，<span class="math inline">\(p,q\)</span> 间的透射率为点 <spanclass="math inline">\(p\)</span> 和射线<spanclass="math inline">\([p,q)\)</span> 与大气顶部或底部最近交点 <spanclass="math inline">\(i\)</span> 之间的透射率，除以 <spanclass="math inline">\(q,i\)</span>间的透射率，或者，如果射线和地面相交则透射率就为0：<font color=#ADADAD>(下图就是和大气顶部相交，如果q点下移，就是和大气底部相交，所谓和地面相交，就是qp两点连线和地面相交……)</font><br /><img src="/imgs/Atmosphere%20Ⅱ/Transmittance.svg" /><br />并且 <span class="math inline">\(p,q\)</span> 和 <spanclass="math inline">\(q,p\)</span>之间的透射率是相同的，只和两点的位置有关和方向无关。因此，想要计算任意两点的透射率，只需要知道大气中一点<span class="math inline">\(p\)</span> 和大气顶部边界上点 <spanclass="math inline">\(i\)</span>之间的透射率。这个透射率只依赖两个参数，半径 <spanclass="math inline">\(r=\lvert op\rvert\)</span> 和“观测天顶角”的余弦<span class="math inline">\(\mu=op\cdot pi/\lvert op\rvert\lvertpi\rvert=\cos(\theta)\)</span>。为了计算该透射率，我们要知道 <spanclass="math inline">\(\lvert pi\rvert\)</span> 的长度，并且需要知道线段<span class="math inline">\([p,i]\)</span> 是否和地面相交。</p><h4 id="distance-to-the-top-atmosphere-boundary">Distance to the topatmosphere boundary</h4><p>一点从 <span class="math inline">\(p\)</span> 出发沿着 <spanclass="math inline">\([p,i)\)</span> 方向距离为 <spanclass="math inline">\(d\)</span>，其坐标可以描述为：<spanclass="math inline">\([d\sqrt{1-\mu^2},r+d\mu]^T\)</span></p><h2 id="latex-picture">Latex Picture</h2><ul><li>figure 1<br /><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tikzpicture&#125;<br><br>  <span class="hljs-comment">% 画同心圆弧 (半径=2cm 和 3cm, 从 30° 到 120°)</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.5pt] (60:4cm) arc[start angle=60, end angle=120, radius=4cm];<br>  <span class="hljs-keyword">\draw</span>[line width=0.5pt, name path=topArc] (60:5.5cm) arc[start angle=60, end angle=120, radius=5.5cm];<br>  <span class="hljs-keyword">\fill</span> (0,2) circle (0.05);<br>  <span class="hljs-keyword">\node</span>[font=<span class="hljs-keyword">\bfseries</span>,scale=0.8] at (0,2) [above right] &#123;o&#125;;<br><br>  <span class="hljs-comment">% x axis</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt,-&gt;] (0,2) -- (1,2);<br>  <span class="hljs-keyword">\node</span>[scale=0.8] at (1,2) [above right] &#123;x&#125;;<br>  <br>  <span class="hljs-comment">% z axis</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (0,2) -- (0,2.4);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt,-&gt;] (0,2.75) -- (0,3);<br>  <span class="hljs-keyword">\node</span>[scale=0.8] at (0,3) [above left] &#123;z&#125;;<br>  <span class="hljs-comment">% symbol on z axis</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (-0.2,2.4) -- (-0.05,2.55);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (-0.05,2.55) -- (0.1,2.4);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (0.1,2.4) -- (0.25,2.55);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (-0.2,2.55) -- (-0.05,2.7);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (-0.05,2.7) -- (0.1,2.55);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (0.1,2.55) -- (0.25,2.7);<br><br>  <span class="hljs-comment">% p point</span><br>  <span class="hljs-keyword">\fill</span> (0,4.6) circle (0.05);<br>  <span class="hljs-keyword">\node</span>[font=<span class="hljs-keyword">\bfseries</span>,scale=0.7] at (0,4.6) [above left] &#123;p&#125;;<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (0,3) -- (0,4.6);<br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt] (0,4.6) -- (0,5.2);<br><br>  <span class="hljs-comment">% p i line</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt,name path=pii] (0,4.6) -- (3,5);<br><br>  <span class="hljs-comment">% angle mu</span><br>  <span class="hljs-keyword">\draw</span>[line width=0.2pt,dash pattern=on 1.5pt off 1pt, name path=angle]<br>   (0.3,4.64) arc[start angle=10, end angle=90, radius=0.3cm]<br>  node [right, xshift=0.1cm, yshift=0.1cm,scale = 0.8] &#123;<span class="hljs-built_in">$</span><span class="hljs-keyword">\mu</span>=<span class="hljs-keyword">\cos</span>(<span class="hljs-keyword">\theta</span>)<span class="hljs-built_in">$</span>&#125;;<br><br>  <span class="hljs-keyword">\fill</span>[name intersections=&#123;of=topArc and pii&#125;]<span class="hljs-comment">%, </span><br>                            <span class="hljs-comment">%  by=inter,  % 交点命名</span><br>                            <span class="hljs-comment">%  total=1&#125;]  % 只取第一个交点</span><br>  (intersection-1) circle (0.05)<br>  node [above, scale=0.80, font=<span class="hljs-keyword">\bfseries</span>] &#123;i&#125;;<br>  <br>  <span class="hljs-comment">% point q</span><br>  <span class="hljs-keyword">\fill</span> (1.5,4.8) circle(0.05)<br>  node[below,scale=0.8, font=<span class="hljs-keyword">\bfseries</span>] &#123;q&#125;;<br><br>  <span class="hljs-comment">% r</span><br>  <span class="hljs-keyword">\draw</span>[line width = 0.2pt, dash pattern = on 1.5pt off 1pt,&lt;-&gt;]<br>   (-1,2) -- (-1,4.6);<br>  <span class="hljs-keyword">\node</span> at (-1,3.3) [left,scale=0.8] &#123;r&#125;;<br>   <br>  <span class="hljs-keyword">\draw</span>[line width = 0.2pt]<br>  (-1.1,2) -- (-0.9,2);<br>  <span class="hljs-keyword">\draw</span>[line width = 0.2pt]<br>  (-1.1,4.6) -- (-0.9,4.6);<br><br><span class="hljs-keyword">\end</span>&#123;tikzpicture&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="reference">Reference</h2><p><ahref="https://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/functions.glsl.html">ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/functions.glsl.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rigid Body Simulation Ⅲ</title>
    <link href="/2025/09/04/Rigid%20Body%20Simulation%20%E2%85%A2/"/>
    <url>/2025/09/04/Rigid%20Body%20Simulation%20%E2%85%A2/</url>
    
    <content type="html"><![CDATA[<p>刚体模拟附录部分。<br /><span id="more"></span></p><h1 id="rigid-body-simulation-ⅲ">Rigid Body Simulation Ⅲ</h1><h2 id="appendix">Appendix</h2><h3 id="appendix-a-motion-equation-derivations">Appendix A MotionEquation Derivations</h3><p>在这部分，我们将补充在第2节中缺失的内容，关于方程 <spanclass="math inline">\(\dot{P}(t)=F(t),\dot{L}(t)=\tau(t),L(t)=I(t)\omega(t)\)</span>。这里的推导方法并非标准方法，是由Andy Witkin 提出的。本附录推导(原作者认为)比传统推导来自Goldstein[^10]的简洁。<br />用 <span class="math inline">\(F_i(t)\)</span>来描述作用在刚体上的外力，这里 <spanclass="math inline">\(F_i(t)\)</span> 指的是作用在第 i个粒子上的外力。然而，对于一个钢铁而言，要保持刚体的形状，就必须有一些“内部”的约束作用作用在同一物体的粒子之间。我们假设这些约束力被动地作用于系统，并且不会对任何网格作用。设<span class="math inline">\(F_{ci}(t)\)</span> 表示作用于第 i个粒子的净内力。在 <span class="math inline">\(t_0\rightarrowt_1\)</span> 间 <span class="math inline">\(F_{ci}\)</span> 对第 i个粒子所做的功为：<br /><span class="math display">\[\int_{t_0}^{t_1}F_{ci}(t)\cdot\dot{r}_i(t)\mathrm{d}t\]</span> 这里 <span class="math inline">\(\dot{r}_i(t)\)</span> 是第 i个粒子的速度。所有粒子的净做功是总和：<br /><span class="math display">\[\sum_i\int_{t_0}^{t_1}F_{ci}(t)\cdot\dot{r}_i(t)\mathrm{d}t=\int_{t_0}^{t_1}\sum_iF_{ci}(t)\cdot\dot{r}_i(t)\mathrm{d}t\]</span> 无论任何 <span class="math inline">\(t_0\rightarrowt_1\)</span> 的时间段这个总和必须为零，也就是说<br /><span class="math display">\[\sum_iF_{ci}(t)\cdot\dot{r}_i(t)\tag{A-1}\]</span> 式子(A-1)在任何时候都必须为零。<br />所以我们可以使用这个来从我们的推到中消除任何关于约束力 <spanclass="math inline">\(F_{ci}\)</span> 的部分。<br />首先，在 2.3 节内定义的 “<span class="math inline">\(^*\)</span>”操作，因<span class="math inline">\(a^*b=a\times b,a\times b=-b\timesa\)</span>，则有：<br /><span class="math display">\[-a^*b=b\times a=b^*a.\tag{A-2}\]</span> 因为 <span class="math inline">\(a^*\)</span>是反对称矩阵，<br /><span class="math display">\[(a^*)^T=-a^*.\tag{A-3}\]</span> 最后因为<span class="math inline">\(^*\)</span>是线性操作，<br /><span class="math display">\[(\dot{a})^*=\dot{(a^*)}=\frac{\mathrm{d}}{\mathrm{d}t}(a^*)\tag{A-4}\]</span> 对于多个向量 <span class="math inline">\(a_i\)</span>的集合<br /><span class="math display">\[\sum a_i^*=(\sum a_i)^*.\tag{A-5}\]</span></p><p>回想一下，我们可以把速度 <spanclass="math inline">\(\dot{r}_i\)</span> 写作 <spanclass="math inline">\(\dot{r}_i=v+\omega\times(r_i-x)\)</span> 这里<span class="math inline">\(r_i\)</span> 是粒子位置， <spanclass="math inline">\(x\)</span> 是质心位置，<spanclass="math inline">\(v,\omega\)</span> 分别是线速度和角速度。令 <spanclass="math inline">\(r&#39;_i=r_i-x\)</span>，并使用 <spanclass="math inline">\(^*\)</span> 运算符。<br /><span class="math display">\[\dot{r}_i=v+\omega^*r_i&#39;=v-r_i&#39;^*\omega.\tag{A-6}\]</span> 将其带入<span class="math inline">\(\sum F_{ci}\cdot\dot{r}_i\)</span>，该式恒为零<br /><span class="math display">\[\sum F_{ci}\cdot(v-r_i&#39;^*\omega)=0\tag{A-7}\]</span> 注意该等式对于任何的 <spanclass="math inline">\(v,\omega\)</span> 都成立。因为 <spanclass="math inline">\(v,\omega\)</span> 二者相独立，如果我们将 <spanclass="math inline">\(\omega\)</span> 设为零，则对于任何 <spanclass="math inline">\(v\)</span> 的取值，我们都必须满足 <spanclass="math inline">\(\sum F_{ci}\cdot v=0\)</span>，那实际上就是 <spanclass="math inline">\(\sumF_{ci}=\textbf{0}\)</span>。这意味着约束力不会产生合力。同样的，假如我们令<span class="math inline">\(v\)</span> 取零，则<spanclass="math inline">\(\sum-F_{ci}\cdot(r_i&#39;^*\omega)=0\)</span>对于任何 <span class="math inline">\(\omega\)</span> 取值都成立。重写为<span class="math inline">\(F_{ci}\cdot(r_i&#39;^*\omega)\rightarrowF_{ci}^T(r_i&#39;^*\omega)\)</span>，能够得到：<br /><span class="math display">\[\sum-F_{ci}^Tr_i&#39;^*\omega=(\sum-F_{ci}^Tr_i&#39;^*)\omega=0\tag{A-8}\]</span> 对于任何 <span class="math inline">\(\omega\)</span>取值，都存在 <spanclass="math inline">\(\sum-F_{ci}^Tr_i&#39;^*=\textbf0^T\)</span>。转置后得：<br /><span class="math display">\[\sum-(r_i&#39;^*)^TF_{ci}=\sum(r_i&#39;)^*F_{ci}=\sum r_i&#39;\timesF_{ci}=\textbf{0}\tag{A-9}\]</span> 这意味着内力不会产生扭矩。<br />可以使用上述推导出刚体的运动方程。作用在每个粒子上的合力是内力 <spanclass="math inline">\(F_{ci}\)</span> 和外力 <spanclass="math inline">\(F_i\)</span> 之合。第 i 个粒子的加速度 <spanclass="math inline">\(\ddot{r}_i\)</span> :<br /><span class="math display">\[\ddot{r}_i=\frac{\mathrm{d}}{\mathrm{d}t}\dot{r}_i=\frac{\mathrm{d}}{\mathrm{d}t}(v-r_i&#39;^*\omega)=\dot{v}-\dot{r}_i&#39;^*\omega-r_i&#39;^*\dot\omega\tag{A-10}\]</span> 因为每个粒子都要遵循牛顿定律 <spanclass="math inline">\(F=ma\)</span>，或者 <spanclass="math inline">\(ma-f=\textbf0\)</span><br /><span class="math display">\[m_i\ddot{r}_i-F_i-F_{ci}=m_i(\dot{v}-\dot{r}_i&#39;^*\omega-r_i&#39;^*\dot\omega)-F_i-F_{ci}=\textbf0\tag{A-11}\]</span> 为了计算 <span class="math inline">\(\dot{P}=F=\sumF_i\)</span>，使用等式 A-11 来对所有粒子求合，<br /><span class="math display">\[\summ_i(\dot{v}-\dot{r}_i&#39;^*\omega-r_i&#39;^*\dot\omega)-F_i-F_{ci}=\textbf0\tag{A-12}\]</span> 拆分这个大的求合运算为多个小的求合：<br /><span class="math display">\[\begin{aligned}\summ_i(\dot{v}-\dot{r}_i&#39;^*\omega-r_i&#39;^*\dot\omega)-F_i-F_{ci}&amp;=\\\sum m_i\dot{v}-\sum m_i\dot{r}_i&#39;^*\omega-\sum m_ir_i&#39;^*\dot\omega -\sum F_i-\sum F_{ci} &amp;=\\\sum m_i\dot{v}-(\sum m_i\dot{r}_i&#39;)^*\omega-(\sum m_ir_i&#39;)^*\dot\omega-\sum F_i-\sum F_{ci}&amp;=\\\sum m_i\dot{v}-(\frac{\mathrm{d}}{\mathrm{d}t}\sum m_ir_i&#39;)^*\omega-(\sum m_ir_i&#39;)^*\dot\omega-\sum F_i-\sum F_{ci}&amp;=\textbf0\end{aligned}\tag{A-13}\]</span></p><p>因为我们在以质心为原点的坐标系中，通过 2.6 节的等式 (2-20) 我们能知道<span class="math inline">\(\summ_ir_i&#39;=\textbf0\)</span>，这也就是说 <spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\summ_ir_i&#39;=\textbf0\)</span>。去除带有 <span class="math inline">\(\summ_ir_i&#39;\)</span> 和 <span class="math inline">\(\sum F_{ci}\)</span>的项，得到下面式子：<br /><span class="math display">\[\sum m_i\dot{v}-\sum F_i=\textbf{0}\tag{A-14}\]</span> 简而言之，就是 <spanclass="math inline">\(M\dot{v}=\dot{P}=\sum F_i\)</span>。<br />注意到对角动量求导有 <span class="math inline">\(\dot{L}=\tau=\sumr_i&#39;\times F_i\)</span>，对于式 (A-11) 两侧都乘上 <spanclass="math inline">\(r_i&#39;^*\)</span><br /><span class="math display">\[r_i&#39;^*m_i(\dot{v}-\dot{r}_i&#39;^*\omega-r_i&#39;^*\dot\omega)-r_i&#39;^*F_i-r_i&#39;^*F_{ci}=r_i&#39;^*\textbf0=\textbf0\tag{A-15}\]</span> 对所有粒子求合：<br /><span class="math display">\[(\sum m_ir_i&#39;)^*\dot{v}-(\sum m_ir_i&#39;^*\dot{r}_i&#39;^*)\omega-(\sum m_ir_i&#39;^*r_i&#39;^*)\dot\omega-\sum r_i&#39;^*F_i-\sum r_i&#39;^*F_{ci}=\textbf0\tag{A-16}\]</span> 因为 <span class="math inline">\(\sumr_i&#39;^*F_{ci}=\textbf0\)</span> 能够得到<br /><span class="math display">\[(\sum m_ir_i&#39;)^*\dot{v}-(\sum m_ir_i&#39;^*\dot{r}_i&#39;^*)\omega-(\sum m_ir_i&#39;^*r_i&#39;^*)\dot{\omega}-\sumr_i&#39;^*F_i=\textbf0\tag{A-17}\]</span> 使用 <span class="math inline">\(\summ_ir_i&#39;=\textbf0\)</span> 得<br /><span class="math display">\[-(\sum m_ir_i&#39;^*\dot{r}_i&#39;^*)\omega-(\sum m_ir_i&#39;^*r_i&#39;^*)\dot{\omega}-\sumr_i&#39;^*F_i=\textbf0\tag{A-18}\]</span> 因 <span class="math inline">\(\sum r_i&#39;^*F_i=\sumr_i&#39;\times F_i=\tau\)</span><br /><span class="math display">\[-(\sum m_ir_i&#39;^*\dot{r}_i&#39;^*)\omega-(\sum m_ir_i&#39;^*r_i&#39;^*)\dot{\omega}=\tau\tag{A-19}\]</span> 我们的化简差不多了，如果还记得 <spanclass="math inline">\(^*\)</span> 运算的定义，能够很简单的得到矩阵 <spanclass="math inline">\(-a^*a^*\)</span> 是等价于 <spanclass="math inline">\((a^Ta)\textbf{1}-aa^T\)</span> 这里 <spanclass="math inline">\(\textbf1\)</span> 是3x3的单位矩阵。(这个规则等价于向量规则：<spanclass="math inline">\(a\times(b\times c)=ba^Tc-ca^Tb.\)</span>)所以：<br /><span class="math display">\[\sum -m_ir_i&#39;^*r_i&#39;^*=\sum m_i\big((r_i&#39;^Tr_i&#39;)\textbf1-r_i&#39;r_i&#39;^T\big)=I(t)\tag{A-20}\]</span> 带入 (A-19)<br /><span class="math display">\[(\sum-m_ir_i&#39;^*\dot{r}_i&#39;^*)\omega+I(t)\dot\omega=\tau\tag{A-21}\]</span> 上式基本计算完成，给出了角加速度 <spanclass="math inline">\(\dot\omega\)</span> 关于扭矩 <spanclass="math inline">\(\tau\)</span>参数的表达式，只是我们需要先计算出矩阵 <span class="math inline">\(\summ_ir_i&#39;^*\dot{r}_i&#39;^*\)</span>，该矩阵计算复杂程度不亚于计算惯性张量。我们使用最后一个trick 方法来解决。因为 <spanclass="math inline">\(\dot{r}_i&#39;=\omega\timesr_i&#39;,r_i&#39;^*\omega=-\omega\timesr_i&#39;\)</span>，能得到：<br /><span class="math display">\[\sum m_i\dot{r}_i&#39;^*r_i&#39;^*\omega=\sum m_i(\omega\times r_i&#39;)^*(-\omega\times r_i&#39;)=\sum -m_i(\omega\times r_i&#39;)\times(\omega\times r_i&#39;)=\textbf0\tag{A-22}\]</span> 所以我们可以把 <span class="math inline">\(-\summ_i\dot{r}_i&#39;^*r_i&#39;^*\omega=\textbf0\)</span> 添加到式A-21<br /><span class="math display">\[(\sum-m_ir_i&#39;^*\dot{r}_i&#39;^*-m_i\dot{r}_i&#39;^*r_i&#39;^*)\omega+I(t)\dot\omega=\tau\tag{A-24}\]</span></p><p><span class="math display">\[\dot{I}(t)=\frac{\mathrm{d}}{\mathrm{d}t}\sum-m_ir_i&#39;^*r_i&#39;^*=\sum-m_ir_i&#39;^*\dot{r}_i&#39;^*-m_i\dot{r}_i&#39;^*r_i&#39;^*\tag{A-24}\]</span></p><p><span class="math display">\[\dot{I}(t)\omega+I(t)\dot\omega=\frac{\mathrm{d}}{\mathrm{d}t}\big(I(t)\omega\big)=\tau.\tag{A-25}\]</span></p><p>因为 角动量等于 <spanclass="math inline">\(L(t)=I(t)\omega(t)\)</span>，所以能得到的就是：<br /><span class="math display">\[\dot{L}(t)=\tau\tag{A-26}\]</span></p><h3 id="appendix-b-quaternion-derivations">Appendix B QuaternionDerivations</h3><p>对旋转求导 <span class="math inline">\(\dot{q}(t)\)</span>的推导过程如下。回想刚体角速度 <spanclass="math inline">\(\omega(t)\)</span> 的描述，物体以大小为 <spanclass="math inline">\(|\omega(t)|\)</span>的量级绕着某轴旋转。假设一个物体以恒定的角速度 <spanclass="math inline">\(\omega(t)\)</span> 旋转。然后物体在一段时间 <spanclass="math inline">\(\Delta t\)</span> 后的旋转用四元数表示为：<spanclass="math inline">\([\cos\frac{|\omega(t)|\Deltat}{2},\sin\frac{|\omega(t)|\Deltat}{2}\frac{\omega(t)}{|\omega(t)|}].\)</span><br />我们计算在 <span class="math inline">\(t_0\)</span> 某时刻的 <spanclass="math inline">\(\dot{q}(t)\)</span>。在时刻 <spanclass="math inline">\(t+\Delta t\)</span>(<spanclass="math inline">\(\Delta t\)</span> 是小值)，物体的方向是(一阶精度to within first order) 先由 <span class="math inline">\(q(t_0)\)</span>的旋转然后再经过角速度 <span class="math inline">\(\omega(t_0)\)</span>旋转 <span class="math inline">\(\Delta t\)</span>时间的结果。组合两次旋转，能够列出：<br /><span class="math display">\[q(t_0+\Delta t)=[\cos\frac{|\omega(t_0)|\Delta t}{2},\sin\frac{|\omega(t_0)|\Delta t}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]q(t_0).\tag{B-1}\]</span> 我们用 <span class="math inline">\(t=t_0+\Delta t\)</span>来替换表示：<br /><span class="math display">\[q(t)=[\cos\frac{|\omega(t_0)|(t-t_0)}{2},\sin\frac{|\omega(t_0)(t-t_0)|}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]q(t_0).\tag{B-2}\]</span> 让我们在时刻 <span class="math inline">\(t_0\)</span> 对 <spanclass="math inline">\(q(t)\)</span> 求导。首先，因为 <spanclass="math inline">\(q(t_0)\)</span>是一个常数，所以我们只需要求导<br /><spanclass="math inline">\([\cos\frac{|\omega(t_0)|(t-t_0)}{2},\sin\frac{|\omega(t_0)(t-t_0)|}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]\)</span><br />在时刻 <span class="math inline">\(t=t_0\)</span><br /><span class="math display">\[\begin{aligned}\frac{\mathrm{d}}{\mathrm{d}t}\cos\frac{|\omega(t_0)|(t-t_0)}{2}&amp;=-\frac{|\omega(t_0)|}{2}\sin\frac{|\omega(t_0)|(t-t_0)}{2}\\&amp;=-\frac{|\omega(t_0)|}{2}\sin0=0\end{aligned}\tag{B-3}\]</span> 相似的<br /><span class="math display">\[\begin{aligned}\frac{\mathrm{d}}{\mathrm{d}t}\sin\frac{|\omega(t_0)|(t-t_0)}{2}&amp;=\frac{|\omega(t_0)|}{2}\cos\frac{|\omega(t_0)|(t-t_0)}{2}\\&amp;=\frac{|\omega(t_0)|}{2}\cos0=\frac{|\omega(t_0)|}{2}\end{aligned}\tag{B-4}\]</span> 因此在 <span class="math inline">\(t=t_0\)</span><br /><span class="math display">\[\begin{aligned}\dot{q}(t)&amp;=\frac{\mathrm{d}}{\mathrm{d}t}\Big([\cos\frac{|\omega(t_0)|(t-t_0)}{2},\sin\frac{|\omega(t_0)|(t-t_0)}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]q(t_0)\Big)\\&amp;=\frac{\mathrm{d}}{\mathrm{d}t}\Big([\cos\frac{|\omega(t_0)|(t-t_0)}{2},\sin\frac{|\omega(t_0)|(t-t_0)}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]\Big)q(t_0)\\&amp;=[0,\frac{|\omega(t_0)|}{2}\frac{\omega(t_0)}{|\omega(t_0)|}]q(t_0)\\&amp;=[0,\frac{1}{2}\omega(t_0)]q(t_0)=\frac{1}{2}[0,\omega(t_0)]q(t_0)\end{aligned}\tag{B-5}\]</span> 乘积 <spanclass="math inline">\([0,\omega(t_0)]q(t_0)\)</span> 可缩写作 <spanclass="math inline">\(\omega(t_0)q(t_0)\)</span>。因此，<spanclass="math inline">\(\dot{q}(t_0)\)</span> 的一般表达式为：<br /><span class="math display">\[\dot{q}(t_0)=\frac{1}{2}\omega(t)q(t)\tag{B-6}\]</span></p><h3 id="appendix-c-some-miscellaneous-formulas">Appendix C SomeMiscellaneous Formulas</h3><h4 id="c.1-kinetic-energy">C.1 Kinetic Energy</h4><p>物体动能 <span class="math inline">\(T\)</span> 的定义为：<br /><span class="math display">\[T=\sum \frac{1}{2}m_i\dot{r}_i^T\dot{r}_i.\tag{C-1}\]</span> 令 <span class="math inline">\(r_i&#39;=r_i-x\)</span>，有<spanclass="math inline">\(\dot{r}_i=v(t)+r_i&#39;^*\omega\)</span>，因此<br /><span class="math display">\[\begin{aligned}T&amp;=\sum\frac{1}{2}m_i\dot{r}_i^T\dot{r}_i\\&amp;=\sum\frac{1}{2}m_i(v+r_i&#39;^*\omega)^T(v+r_i&#39;^*\omega)\\&amp;=\frac{1}{2}\sum m_iv^Tv+\sum v^Tm_ir_i&#39;^*\omega+\frac{1}{2}\sum m_i(r_i&#39;^*\omega)^T(r_i&#39;^*\omega)\\&amp;=\frac{1}{2}v^T(\sum m_i)v+v^T(\sum m_ir_i&#39;^*)\omega+\frac{1}{2}\omega^T\Big(\sum m_i(r_i&#39;^*)^Tr_i&#39;^*\Big)\omega\end{aligned}\tag{C-2}\]</span> 因 <span class="math inline">\(\summ_ir_i&#39;=\textbf0,(r_i&#39;^*)^T=-r_i&#39;^*\)</span><br /><span class="math display">\[\begin{aligned}T&amp;=\frac{1}{2}v^TMv+\frac{1}{2}\omega^T\Big(\sum -m_ir_i&#39;^*r_i&#39;^*\Big)\omega\\&amp;=\frac{1}{2}(v^TMv+\omega^TI\omega)\end{aligned}\tag{C-3}\]</span> 这里的 <span class="math inline">\(I=\sum-m_ir_i&#39;^*r_i&#39;^*\)</span> 是 Appendix A 的式(A-20)。所以动能能够由两部分表达：线性部分 <spanclass="math inline">\(\frac{1}{2}^TMv\)</span> 和 角度部分 <spanclass="math inline">\(\frac{1}{2}\omega^TI\omega\)</span>。</p><h4 id="c.2-angular-acceleration">C.2 Angular Acceleration</h4><p>我们经常需要计算 <span class="math inline">\(\omega(t)\)</span>。因为<span class="math inline">\(L(t)=I(t)\omega(t)\)</span>，我们知道 <spanclass="math inline">\(\omega(t)=I^{-1}(t)L(t)\)</span>。<br /><span class="math display">\[\dot{\omega}(t)=\dot{I}^{-1}(t)L(t)+I^{-1}(t)\dot{L}(t)\tag{C-4}\]</span> 因 <span class="math inline">\(\dot{L}(t)=\tau(t)\)</span>(A-26) 式，主要处理 <spanclass="math inline">\(\dot{I}^{-1}(t)\)</span>，在式 (2-40) 能得到<br /><span class="math display">\[I^{-1}(t)=R(t)I^{-1}_{body}R(t)^T.\]</span></p><p><span class="math display">\[\dot{I}^{-1}(t)=\dot{R}(t)I^{-1}_{body}R(t)^T+R(t)I^{-1}_{body}\dot{R}(t)^T.\tag{C-5}\]</span></p><p>因为式 (2-12) <spanclass="math inline">\(\dot{R}(t)=\omega(t)^*R(t)\)</span><br /><span class="math display">\[\dot{R}(t)^T=(\omega(t)^*R(t))^T=R(t)^T\big(\omega(t)^*\big)^T\tag{C-6}\]</span> 因为 <span class="math inline">\(\omega(t)^*\)</span>是反对称矩阵(antisymmetric matrix)，(<spanclass="math inline">\(\big(\omega(t)^*\big)^T=-\omega(t)^*\)</span>),<br /><span class="math display">\[\dot{R}(t)^T=-R(t)^T\omega(t)^*\tag{C-7}\]</span></p><p><span class="math display">\[\begin{aligned}\dot{I}^{-1}(t)&amp;=\dot{R}(t)I^{-1}_{body}R(t)^T+R(t)I^{-1}_{body}\dot{R}(t)^T\\&amp;=\dot{R}(t)I^{-1}_{body}R(t)^T-R(t)I^{-1}_{body}R(t)^T\omega(t)^*\\&amp;=\omega(t)^*R(t)I^{-1}_{body}R(t)^T-I^{-1}(t)\omega(t)^*\\&amp;=\omega(t)^*I^{-1}(t)-I^{-1}(t)\omega(t)^*\end{aligned}\tag{C-8}\]</span></p><p><span class="math display">\[\begin{aligned}\dot\omega(t)&amp;=\dot{I}^{-1}L(t)+I^{-1}(t)\dot{L}(t)\\&amp;=\Big(\omega(t)^*I^{-1}(t)-I^{-1}(t)\omega(t)^*\Big)L(t)+I^{-1}(t)\dot{L}(t)\\&amp;=\omega(t)^*I^{-1}(t)L(t)-I^{-1}(t)\omega(t)^*L(t)+I^{-1}(t)\dot{L}(t)\\\end{aligned}\tag{C-9}\]</span></p><p>因为我们有 <spanclass="math inline">\(I^{-1}(t)L(t)=\omega(t)\)</span>，对于第一项 <spanclass="math inline">\(\omega(t)^*I^{-1}(t)L(t)\)</span> 实际上是 <spanclass="math inline">\(\omega(t)^*\omega(t)=\omega(t)\times\omega(t)=0\)</span>，所以能够得到：<br /><span class="math display">\[\begin{aligned}\dot\omega(t)&amp;=-I^{-1}(t)\omega(t)^*L(t)+I^{-1}(t)\dot{L}(t)\\&amp;=-I^{-1}(t)\omega(t)\times L(t)+I^{-1}(t)\dot{L}(t)\\&amp;=I^{-1}(t)\Big(L(t)\times\omega(t)\Big)+I^{-1}(t)\dot{L}(t)\\&amp;=I^{-1}(t)\Big(L(t)\times\omega(t)+\dot{L}(t)\Big)\end{aligned}\tag{C-10}\]</span> 我们可以由此看出，即使没有外力作用（即 <spanclass="math inline">\(\dot{L}(t)=0\)</span>），角加速度 <spanclass="math inline">\(\dot\omega(t)\)</span>仍可能非零。（事实上，<strong>只要角动量与角速度的方向不一致</strong>，就会出现这种情况——而这一现象又源于：刚体的<strong>转动速度轴（rotationalvelocity axis）不是刚体的对称轴</strong>。）</p><h4 id="c.3-acceleration-of-a-point">C.3 Acceleration of a Point</h4><p>给定一点在世界空间的位置 <spanclass="math inline">\(p(t)\)</span>，经常会需要计算 <spanclass="math inline">\(\ddot{p}(t)\)</span>。<br />将模型空间的点 <span class="math inline">\(p_0\)</span> 变换到时刻 <spanclass="math inline">\(t\)</span> 的世界坐标 <spanclass="math inline">\(p(t)\)</span>: <spanclass="math inline">\(p(t)=R(t)p_0+x(t)\)</span>。<br />如果令 <span class="math inline">\(r(t)=p(t)-x(t)\)</span>，则<br /><span class="math display">\[\begin{aligned}\dot{p}(t)&amp;=\dot{R}(t)p_0+\dot{x}(t)=\omega(t)^*R(t)p_0+v(t)\\&amp;=\omega(t)\times\Big(R(t)p_0+x(t)-x(t)\Big)+v(t)\\&amp;=\omega(t)\times\Big(p(t)-x(t)\Big)+v(t)\\&amp;=\omega(t)\times r(t)+v(t)\end{aligned}\tag{C-11}\]</span></p><p><span class="math display">\[\begin{aligned}\ddot{p}(t)&amp;=\dot\omega(t)\times r(t)+\omega(t)\times \dot{r}(t)+\dot{v}(t)\\&amp;=\dot\omega(t)\times r(t)+\omega(t)\times\Big(\omega(t)\times r(t)\Big)+\dot{v}(t)\end{aligned}\tag{C-12}\]</span></p><p>式(C-12) 用了式 (2-7)，对于上式结果我们可以这样理解。<br />第一项，<span class="math inline">\(\dot\omega(t)\times r(t)\)</span>是该点切向加速度(tangential acceleration)，即 <spanclass="math inline">\(\dot\omega(t)\times r(t)\)</span>是物体产生角加速度而产生的垂直于位移 <spanclass="math inline">\(r(t)\)</span> 的加速度。<br />第二项，<span class="math inline">\(\omega(t)\times\Big(\omega(t)\timesr(t)\Big)\)</span>是向心加速度，这种向心加速度产生是因为规定物体是刚体，并且物体上各点必须绕质心做圆周运动<font color=#909090><em>(这里我是没懂什么意思……角速度引起的向心加速度？)</em></font>。<br />最后一项，<span class="math inline">\(\dot v(t)\)</span>点的线性加速度，是因为物体质心线性加速度产生。</p><h3 id="appendix-d-resting-contact-derivations">Appendix D RestingContact Derivations</h3><p>如果想在模拟器中实现静接触，可能会需要本附录中的派生和代码。这或许并不是一篇易于阅读的附录内容；不过话说回来，写这篇附录的过程本身也不怎么有趣啊！<font color=#909090><em>(翻译下来也不是很有趣啊！keso！)</em></font><br />这里的推导过程比较简洁，但是搭配原文附录末尾的代码可能能更清晰易懂。<br /><span class="math display">\[\ddot{d_i}(t_0)=a_{i1}f_1+a_{i2}f_2+\cdots+a_{in}f_n+b_i.\tag{D-1}\]</span> 给定 <span class="math inline">\(i,j\)</span>，我们需要知道<span class="math inline">\(\ddot{d_i}(t_0)\)</span> 如何依赖于 <spanclass="math inline">\(f_j\)</span>，也就是说，需要知道 <spanclass="math inline">\(a_{ij}\)</span>。同时，我们还要计算常数项 <spanclass="math inline">\(b_i\)</span>。<br />我们先开始计算 <span class="math inline">\(a_{ij}\)</span>暂时忽略常数部分 <span class="math inline">\(b_i\)</span>。假设第 i个接触发生在物体 <span class="math inline">\(A,B\)</span> 之间。根据式(9-4) 对 <span class="math inline">\(\ddot{d}_i(t_0)\)</span>能得到：<br /><span class="math display">\[\ddot{d}(t_0)=\hat{n}_i(t_0)\cdot\big(\ddot{p}_a(t_0)-\ddot{p}_b(t_0)\big)+2\hat{n}_i(t_0)\cdot\big(\dot{p}_a(t_0)-\dot{p}_b(t_0)\big)\tag{D-2}\]</span> 这里的 <spanclass="math inline">\(p_a(t_0)=p_i=p_b(t_0)\)</span> 是在 <spanclass="math inline">\(t_0\)</span> 时刻的第 <spanclass="math inline">\(i\)</span> 个接触点。因此 <spanclass="math inline">\(2\hat{n}_i(t_0)\cdot\big(\dot{p}_a(t_0)-\dot{p}_b(t_0)\big)\)</span>项是一个速度相关项(你可以在不知道所涉及的力作用情况下立刻计算出来)，关于 <spanclass="math inline">\(b_i\)</span> 的部分，我们暂时忽略。<br />现在我们只需要计算 <spanclass="math inline">\(\ddot{p}_a(t_0),\ddot{p}_b(t_0)\)</span> 如何依赖<span class="math inline">\(f_i\)</span>，<spanclass="math inline">\(f_i\)</span> 为第 i 个接触力的大小。<br />我们来考虑第 i 个接触点的情况。如果物体 A 不是第 i个接触点中的其中一个物体，说明 <spanclass="math inline">\(\ddot{p}_a(t_0)\)</span> 和 <spanclass="math inline">\(f_i\)</span> 无关，因为第 i个接触点没有力作用在物体 A 上。同样的，如果 B 也不是第 i个接触点中的其中一个物体，则 <spanclass="math inline">\(\ddot{p}_b(t_0)\)</span> 和 <spanclass="math inline">\(f_i\)</span> 是无关的。(就像 figure26，第1个点的加速度是不会受到第5个接触点的影响的。因此 <spanclass="math inline">\(\ddot{d}_1(t_0)\)</span> 完全和 <spanclass="math inline">\(f_5\)</span> 无关。反之同理 <spanclass="math inline">\(\ddot{d}_5(t_0)\)</span> 和 <spanclass="math inline">\(f_1\)</span> 也是无关。)<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure26.png" /><br />假设在第 i 个接触点中，包括了物体 A。为了明确起见，假设在第 i个接触点中，一个力 <span class="math inline">\(j\hat{n}_j(t_0)\)</span>作用在物体 A 上，而不是 <spanclass="math inline">\(-j\hat{n}_j(t_0)\)</span>。我们需要求解作用在物体A 上的力 <span class="math inline">\(j\hat{n}_j(t_0)\)</span> 如何影响<span class="math inline">\(\ddot{p}_a(t_0)\)</span>。<br />根据式 (C-12)，能够得到： <span class="math display">\[\ddot{p}_a(t)=\dot{v}_a(t)+\dot\omega_a(t)\times r(t)_a+\omega_a(t)\times\Big(\omega_a(t)\times r_a(t)\Big)\tag{D-3}\]</span> 这里 <spanclass="math inline">\(r_a(t)=p_a(t)-x_a(t)\)</span>，并且<spanclass="math inline">\(x_a(t),v_a(t),\omega_a(t)\)</span> 全都是和物体 A有关的变量。我们知道 <span class="math inline">\(\dot{v}_a(t)\)</span>是物体的线性加速度，并且等于作用在 A 上的合力除以质量。因此，力 <spanclass="math inline">\(j\hat{n}_j(t_0)\)</span> 对加速度 <spanclass="math inline">\(\dot{v}_a(t),\ddot{p}_a(t_0)\)</span>的贡献为:<br /><span class="math display">\[\frac{f_j\hat{n}_j(t_0)}{m_a}=f_j\frac{\hat{n}_j(t_0)}{m_a}\tag{D-4}\]</span> 同样的，根据式 (C-10),(2-13) 能针对 <spanclass="math inline">\(\dot\omega_a(t)\)</span> 得<br /><span class="math display">\[\dot\omega_a(t)=I^{-1}_a(t)\tau_a(t)+I^{-1}_a(t)\Big(L_a(t)\times\omega_a(t)\Big)\]</span> 这里的 <span class="math inline">\(\tau_a(t)\)</span>是作用在物体 A 上的总扭矩。如果第 j 个 接触发生在点 <spanclass="math inline">\(p_j\)</span>，则力 <spanclass="math inline">\(j\hat{n}_j(t_0)\)</span> 产生的力矩为：<br /><span class="math display">\[\big(p_j-x_a(t_0)\big)\times f_j\hat{n}_j(t_0).\]</span> 因此，对于 <spanclass="math inline">\(\ddot{p_a}(t_0)\)</span> 的角度贡献为：<br /><span class="math display">\[\begin{aligned}&amp;f_j\Big(I_a^{-1}(t_0)\big((p_j-x_a(t_0))\times\hat{n}_j(t_0)\big)\Big)\timesr_a.\\&amp;完全看不懂为什么\cdots\\&amp;可能就是\dot\omega_a(t)暂时忽略了后面的陀螺项,然后算加速度?\\\end{aligned}\tag{D-5}\]</span> <span class="math inline">\(\ddot{p}_a(t_0)\)</span> 对 <spanclass="math inline">\(f_j\)</span> 的总依赖为：<br /><span class="math display">\[f_j\bigg(\frac{\hat{n}_j(t_0)}{m_a}+\Big(I_a^{-1}(t_0)\big((p_j-x_a(t_0))\times\hat{n}_j(t_0)\big)\Big)\times r_a\bigg).\]</span> 如果是一个力 <spanclass="math inline">\(-f_j\hat{n}(t_0)\)</span> 作用在 A上，得到的关系是一样的，只是要在 <spanclass="math inline">\(f_j\)</span> 前添加负号。显然 <spanclass="math inline">\(\ddot{p}_b(t_0)\)</span> 以类似的方式依赖于 <spanclass="math inline">\(f_j\)</span>。一旦我们计算出 <spanclass="math inline">\(\ddot{p}_a(t_0),\ddot{p}_b(t_0)\)</span> 如何依赖<span class="math inline">\(f_j\)</span>，就将结果组合并和 <spanclass="math inline">\(\hat{n}_i(t_0)\)</span> 做点乘，观察 <spanclass="math inline">\(\ddot{d}_i(t_0)\)</span> 如何依赖 <spanclass="math inline">\(f_j\)</span>。这给出了系数 <spanclass="math inline">\(a_{ij}\)</span>。可能有点困惑，看一看后面的代码部分。</p><p>我们还需要计算出 <span class="math inline">\(b_i\)</span>。我们知道<span class="math inline">\(\ddot{d_i}(t_0)\)</span> 包含固定项<br /><span class="math display">\[2\dot{\hat{n}}_i(t_0)\cdot\big(\dot{p}_a(t_0)-\dot{p}_b(t_0)\big).\]</span> 但是我们也必须要考虑已知外力对 <spanclass="math inline">\(\ddot{p}_a(t_0),\ddot{p}_b(t_0)\)</span>的影响，比如重力，同时还有和力无关的项 <spanclass="math inline">\(\omega_a(t_0)\times(\omega_a(t_0)\timesr_a),\Big(I^{-1}_a(t_0)\big(L_a(t_0)\times\omega_a(t_0)\big)\Big)\timesr_a\)</span>。如果令作用在 A 上的合力为 <spanclass="math inline">\(F_a(t_0)\)</span> 并且合扭矩为 <spanclass="math inline">\(\tau_a(t_0)\)</span>，接着从式 (D-4), (D-5)中可以得到 <span class="math inline">\(F_a(t_0)\)</span> 贡献为：<spanclass="math inline">\(\frac{F_a(t_0)}{m_a}\)</span>。<br />并且 <span class="math inline">\(\tau_a(t_0)\)</span> 贡献为：<spanclass="math inline">\(\Big(I_a^{-1}(t_0)\tau_a(t_0)\Big)\timesr_a.\)</span><br />因此，<span class="math inline">\(\ddot{p}_a(t_0)\)</span> 和 <spanclass="math inline">\(f_j\)</span> 无关的部分为：<br /><span class="math display">\[\begin{aligned}&amp;\frac{F_a(t_0)}{m_a}+\big(I^{-1}_a(t_0)\tau_a(t_0)\big)\times r_a+\omega_a(t_0)\times\big(\omega_a(t_0)\times r_a\big)+\\&amp;\Big(I^{-1}_a(t_0)\big(L_a(t_0)\times\omega_a(t_0)\big)\Big)\timesr_a\end{aligned}\]</span> 对于 <span class="math inline">\(\ddot{p}_b(t_0)\)</span>是相似的。为了计算 <span class="math inline">\(b_i\)</span>，我们组合<span class="math inline">\(\ddot{p}_a(t_0),\ddot{p}_b(t_0)\)</span> 和<span class="math inline">\(\hat{n}_i(t_0)\)</span> 做点乘，并添加项<spanclass="math inline">\(2\dot{\hat{n}}_i(t_0)\cdot\big(\dot{p}_a(t_0)-\dot{p}_b(t_0)\big).\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rigid Body Simulation Ⅱ</title>
    <link href="/2025/08/18/Rigid%20Body%20Simulation%20%E2%85%A1/"/>
    <url>/2025/08/18/Rigid%20Body%20Simulation%20%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<p>刚体模拟 Ⅱ。<br /><span id="more"></span></p><h1 id="rigid-body-simulation-ⅱ">Rigid Body Simulation Ⅱ</h1><h2 id="part-ⅱ.-nonpenetration-constraints">Part Ⅱ. NonpenetrationConstraints</h2><h3 id="problems-of-nonpenetration-constraints">6. Problems ofNonpenetration Constraints</h3><p>现在我们知道了如何写出和实现刚体的运动方程，让我们考虑一下如何防止物体移动时他们在环境中互相穿透的问题。为简化讨论，假设我们模拟一个<strong>质点</strong>（即单个粒子）落到固定地面的过程。这里面涉及几个关键问题。现在我们处理的是<strong>完全不可变形的刚体</strong>，因此当粒子撞击地面时，<strong>绝不允许任何穿透</strong>。（若将地面视为柔性体，可能允许粒子轻微穿透，并将其解释为地面在撞击点附近的形变。但这里地面是刚性的，因此<strong>完全不允许穿透</strong>。）这意味着：当粒子<strong>实际接触地面瞬间</strong>，我们需要<strong>突然改变粒子的速度</strong>——这与柔性体（如橡胶球）的处理方式截然不同。<br />对于柔性体，碰撞可视为<strong>渐进过程</strong>：在<strong>较短但不为零的时间跨度</strong>内，球与地面间会产生作用力，使球的速度逐渐变化；同时球因该力发生形变。球越刚性，形变越小，碰撞过程越快。<strong>极限情况</strong>下，球为<strong>绝对刚性</strong>（完全无形变），若速度不能<strong>瞬时</strong>停止，球就会穿透地面。<br />因此，在<strong>刚体动力学</strong>中，我们默认将碰撞视为<strong>瞬时事件</strong>（持续时间为零）。</p><p>这意味着我们需要处理<strong>两种接触类型</strong>。</p><ul><li><p>当两个物体在点 <span class="math inline">\(p\)</span>处接触，且存在相互靠近的速度（如粒子撞击地面），我们称之为<strong>碰撞接触</strong>。碰撞接触需要速度的<strong>瞬时变化</strong>。每当碰撞发生时，描述物体运动的状态（包含位置和速度）会发生<strong>速度的不连续变化</strong>。而求解常微分方程（ODE）的数值程序，默认基于“状态<span class="math inline">\(Y(t)\)</span>始终<strong>平滑变化</strong>”的假设运行。显然，碰撞时要求 <spanclass="math inline">\(Y(t)\)</span> 突变，直接违反了这一假设。<br />我们通过以下方式解决这个问题：若碰撞发生在时间 <spanclass="math inline">\(t_c\)</span>，我们让常微分方程（ODE）求解器<strong>停止运行</strong>。接着，我们获取该时刻的状态<spanclass="math inline">\(Y(t_c)\)</span>，并计算碰撞涉及物体的速度需如何改变。我们将反映这些新速度的状态记为<span class="math inline">\(Y(t_c)^+\)</span>。需注意： <spanclass="math inline">\(Y(t_c)\)</span> 与 <spanclass="math inline">\(Y(t_c)^+\)</span>在<strong>所有空间变量</strong>（位置和姿态）上一致，但在 <spanclass="math inline">\(t_c\)</span>时刻参与碰撞的物体<strong>速度变量</strong>上存在差异。随后，我们以新状态重 <span class="math inline">\(Y(t_c)^+\)</span>启数值求解器，并指示它从时间 <span class="math inline">\(t_c\)</span>开始继续模拟。</p></li><li><p>当物体在点 <span class="math inline">\(p\)</span>处<strong>相互静止接触</strong>（例如：粒子以零速度接触地面），我们称物体处于<strong>静息接触</strong>状态。此时，我们需要计算一个<strong>阻止粒子向下加速的力</strong>——本质上，这个力等于粒子受重力的重量（或其他施加于粒子的外部力）。我们将粒子与地面的力称为<strong>接触力</strong>。静息接触显然不需要我们在每一瞬间都停止并重启ODE 求解；从 ODE 求解器的视角看，接触力只是<code>Compute_Force_and_Torque</code> 函数返回的力的一部分。</p></li></ul><p><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure13.png" /><br />到目前为止，我们需要处理两个问题：计算碰撞接触时的速度变化，以及计算防止穿透现象的接触力。但在解决这些问题之前，我们必须先处理几何问题，即实际检测物体之间的接触。让我们回到粒子下落至地面的例子。在运行模拟时，我们会计算粒子在特定时间点朝地面下落的位置（见图13）。假设我们考虑粒子在时刻<span class="math inline">\(t_0,t_0+\Delta t,t_0+2\Delta t\)</span>等位置，且碰撞时刻 tc（粒子实际撞击地面的时刻)位于 <spanclass="math inline">\(t_0\)</span> 和 <spanclass="math inline">\(t_0+\Delta t\)</span> 之间。那么在 <spanclass="math inline">\(t_0\)</span>时刻，我们发现粒子位于地面之上；但在下一个时间步 <spanclass="math inline">\(t_0+\Delta t\)</span>时刻，我们发现粒子位于地面之下，这意味着发生了穿透现象。<br />如果我们希望在碰撞时刻 <span class="math inline">\(t_c\)</span>停止并重启模拟器，这就需要计算出 <spanclass="math inline">\(t_c\)</span>。我们目前所知道的是 <spanclass="math inline">\(t_c\)</span> 位于 <spanclass="math inline">\(t_0\)</span> 和 <spanclass="math inline">\(t_0+\Delta t\)</span> 之间。通常，精确求解 <spanclass="math inline">\(t_c\)</span>是困难的，因此我们通过数值方法在特定容差范围内求解 <spanclass="math inline">\(t_c\)</span>。确定 <spanclass="math inline">\(t_c\)</span>的一个简单方法是使用一种称为二分法的数值方法[14]。<br />如果在 <span class="math inline">\(t_0+\Delta t\)</span>时刻检测到相互穿透，我们通知常微分方程（ODE）求解器，希望在 <spanclass="math inline">\(t_0\)</span> 时刻重启，并模拟到 <spanclass="math inline">\(t_0+\Delta t/2\)</span> 时刻。如果模拟器到达 <spanclass="math inline">\(t_0+\Delta t/2\)</span>时刻时没有遇到相互穿透，我们就知道碰撞时间 <spanclass="math inline">\(t_c\)</span> 位于 <spanclass="math inline">\(t_0+\Delta t/2\)</span> 和 <spanclass="math inline">\(t_0+\Delta t\)</span> 之间。否则，<spanclass="math inline">\(t_c\)</span> 小于 <spanclass="math inline">\(t_0+\Delta t/2\)</span>，我们尝试从 <spanclass="math inline">\(t_0\)</span> 模拟到 <spanclass="math inline">\(t_0+\Delta t/4\)</span>。最终，碰撞时间 <spanclass="math inline">\(t_c\)</span> 会在一定的数值容差范围内被计算出来。<span class="math inline">\(t_c\)</span>的精度取决于碰撞检测程序。碰撞检测程序有参数 <spanclass="math inline">\(\epsilon\)</span>。当我们计算得到的 <spanclass="math inline">\(t_c\)</span>“足够好”时——即粒子对地板的穿透深度不超过 <spanclass="math inline">\(\epsilon\)</span>，且粒子在地板以上的高度小于<spanclass="math inline">\(\epsilon\)</span>——我们就认为粒子与地板接触（图14)。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure14.png" /><br />二分法虽然有点慢，但易于实现且相当稳健。更快捷的方法是通过考察位置 <spanclass="math inline">\(\textbf{Y}(t_0)\)</span> 和 <spanclass="math inline">\(\textbf{Y}(t_0 + \Delta t)\)</span>来实际预测碰撞时间 <span class="math inline">\(t_c\)</span>。Baraff[1,2]阐述了如何进行此类预测。具体如何实现，取决于你与常微分方程(ODE)求解器的交互方式。你可能需要使用异常处理代码向ODE 求解器通报各种事件 (碰撞、相互穿透)，或者向 ODE求解器传递某种消息。我们这里假定你有办法让 ODE 求解器恰好推进到时间<span class="math inline">\(t_c\)</span> 这个点。</p><p>一旦真正到达碰撞时间点，或在未发生穿透状态的任意时刻 <spanclass="math inline">\(Y(t)\)</span>下，都必须进行几何判定以找出所有接触点。（仅仅因为你在检测物体A和B之间的碰撞时间，并不意味着可以忽略其他物体C和D之间的静接触力。无论何时推进模拟，都需要计算物体间的接触点和这些点的接触力。）有关碰撞检测问题的文献非常丰富。例如，近年来涉及该主题的SIGGRAPH论文有VonHerzen、Barr和Zatz<sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="B. Von Herzen, A. Barr, and H. Zatz. Geometric collisions for time-dependent parametric surfaces. In Computer Graphics (Proc. SIGGRAPH), volume 24, pages 39–48. ACM, August 1990">[17]</span></a></sup>以及Moore和Wilhelms<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="P.M. Moore and J. Wilhelms. Collision detection and reponse for computer animation. In Computer Graphics (Proc. SIGGRAPH), volume 22, pages 289–298. ACM, August 1988.">[12]</span></a></sup>；在机器人领域，多篇重要论文包括Canny<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="J. Canny. Collision detection for moving polyhedra. IEEE Transactions on Pattern Analysis and Machine Intelligence, 8(2), 1986.">[4]</span></a></sup>、Gilbert和Hong<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="E.G. Gilbert and S.M. Hong. A new algorithm for detecting the collision of moving objects. In International Conference on Robotics and Automation, pages 8–13. IEEE, 1989.">[6]</span></a></sup>、Meyer<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="W. Meyer. Distance between boxes: Applications to collision detection and clipping. In International Conference on Robotics and Automation, pages 597–602. IEEE, 1986.">[11]</span></a></sup>以及Cundall<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="P.A. Cundall. Formulation of a three-dimensional distinct element model—Part I. A scheme to represent contacts in a system composed of many polyhedral blocks. International Journal of Rock Mechanics, Mineral Science and Geomechanics, 25, 1988.">[5]</span></a></sup>。Preparata和Shamos<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="F.P. Preparata and M.I. Shamos. Computational Geometry. Springer-Verlag, New York, 1985.">[13]</span></a></sup>描述了计算几何中解决该问题的多种方法。在下一节中，我们将简要介绍一种针对本课程笔记所关注的模拟类型、能实现高效算法的碰撞检测“思路”。该算法的实际代码虽然易于编写，但过于冗长，无法纳入这些笔记。接下来，我们将继续探讨碰撞接触和静接触问题。</p><h3 id="collision-detection">7. Collision Detection</h3><p>碰撞检测算法首先进行预处理步骤，即为每个刚体计算一个<strong>包围盒</strong>（边界框的边与坐标轴平行）。给定n个这样的包围盒后，算法需要快速确定所有发生重叠的包围盒对。对于包围盒未发生重叠的刚体对，无需进一步考虑。包围盒发生重叠的刚体对需要进一步分析。我们首先将描述如何高效检测<strong>凸多面体</strong>（convexpolyhedra）定义的刚体之间是否存在相互穿透或接触点；随后将阐述如何高效执行包围盒检测。</p><p>如第1节所述，模拟过程是反复计算状态向量 <spanclass="math inline">\(Y(t)\)</span> 的导数 <spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span>（在多个时刻<em>t</em> 处）。数值ODE求解器负责选择计算导数的时刻 <spanclass="math inline">\(t\)</span>。对于复杂模拟，求解器选择的时刻需保证相邻时间步间状态<span class="math inline">\(\textbf{Y}\)</span>变化极小——这使得时间步之间存在极强的几何一致性。在 <spanclass="math inline">\(t_0+\Delta t\)</span> 时刻，可复用前一时刻 <spanclass="math inline">\(t_0\)</span> 的碰撞检测结果。</p><h4 id="convex-polyhedra">7.1 Convex Polyhedra</h4><p>我们利用<strong>几何一致性</strong>的核心机制是借助<strong>“见证信息（witnesses）”</strong>。在我们的场景中，给定两个凸多面体<em>A</em> 和<em>B</em>，<strong>见证信息</strong>是一段可用于快速回答“<em>A</em> 和<em>B</em>是否不相交？”这一“是/否”问题的信息。我们通过<strong>缓存前一时刻的见证信息</strong>来利用时间步间的几何一致性：期望前一时刻的见证信息在当前时刻仍能作为有效依据。</p><p>由于我们考虑的是凸多面体，两个多面体不相交<strong>当且仅当</strong>它们之间存在一个<strong>分离平面（separatingplane）</strong>。两个多面体之间的分离平面是指：每个多面体都位于该平面的<strong>不同侧</strong>。要验证一个平面是否为分离平面，只需确保多面体A和多面体B的所有顶点都位于平面的<strong>对立两侧</strong>。因此，分离平面是“两个凸多面体不相交”这一事实的<strong>见证信息（witness）</strong>。若不存在分离平面，那么多面体必然相互穿透。</p><p>最开始查找 witness(模拟的起始阶段，或者两个物体第一次足够接近以至于不仅需要包围盒检测)这个消耗是无法避免的。要初始查找分离平面一个简单的方法如下。如果一对凸多面体是分离的或者接触(但不相交)，那么分离平面满足以下特性：要么该平面包含其中一个多面体的某个面，要么该平面包含其中一个多面体的一条边，并且与另一个多面体的一条边平行。（也就是说，分离平面的法线是两条边方向的叉积，而平面本身包含其中一条边。）我们称这些面和边为<strong>特征面</strong>、<strong>特征边</strong>。最初，我们简单地检查所有可能的面和边的组合，看看是否有一个这样的组合形成一个分离平面最初，我们简单地检查所有可能的面和边的组合，看看是否有一个这样的组合形成一个分离平面。(Figure15)尽管这种方法效率不高，但因执行频率极低，效率问题并不关键。在后续时间步中，只需利用前一时间步找到的<strong>特征面</strong>或<strong>特征边</strong>构造分离平面，再验证该平面是否仍然有效（如图16所示）。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure15.png" /><br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure16.png" /><br />在少数情况下，缓存的面或两条边无法构成分离平面，对与之前缓存的面和边相邻进行检测，判断其是否为分离平面。不过，这种情况发生的频率已经足够低，因此直接从头开始重新计算一个新的分离平面(无需依赖任何先验信息)反而可能更简便。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure17.png" /><br />一旦找到分离平面，如果两个几何体不是分离状态，就需要确定他们之间的接触面积。两个多面体的<strong>接触点</strong>仅可能出现在分离平面上。给定分离平面后，只需比较多面体上<strong>与分离平面共面</strong>的面、边和顶点，就能<strong>快速且高效</strong>地确定接触点。<br />一旦无法找到分离平面，则两个多面体必然处于<strong>相互穿透</strong>状态。当多面体发生穿透时，几乎总是存在以下两种情况之一：要么一个多面体的<strong>顶点</strong>位于另一个多面体内部，要么一个多面体的<strong>边</strong>与另一个多面体的<strong>面</strong>相交。这种情况下穿透的顶点或者线、面将被缓存为穿透的见证要素(witness)。因为这意味着在更早的时刻发生了碰撞，模拟器将回溯并计算更早时刻的<spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span>。在确定碰撞时刻之前，碰撞/接触判定步骤的首要操作是检查缓存的顶点或边与面，判断它们是否指示穿透。因此，因此，在找到碰撞时间之前，以最小的计算开销识别当前仍然存在互穿的状态。</p><h4 id="bounding-boxes">7.2 Bounding Boxes</h4><p>为了减少成对碰撞/接触的次数，在仿真环境中引入 Bounding Boxs。如果两个Bounding boxs 没重叠，不需要进一步计算包围盒内部的东西。给 n个与坐标轴对齐的矩形包围盒，我们想要有效的计算出所有重叠的包围盒对。直接遍历的复杂度是<spanclass="math inline">\(O(n^2)\)</span>，效率太低了。现有的计算几何算法可以在<spanclass="math inline">\(O(n\log n+ k)\)</span>时间内解决这个问题，其中 k是成对重叠的数量；一般结果是，对于 d维边界盒<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="F.P. Preparata and M.I. Shamos. Computational Geometry. Springer-Verlag, New York, 1985.">[13]</span></a></sup>，问题可以在时间<span class="math inline">\(O(n\log^{d−2}n+k)\)</span>内解决。使用相干性，我们可以获得更好的性能。</p><h5 id="the-one-dimensional-case">7.2.1 The one-dimensional case</h5><p>可以先考虑和坐标轴平行的一维包围盒。这样的包围盒可以定义为一个 <spanclass="math inline">\([b,e]\)</span> 区间，<spanclass="math inline">\(b,e\)</span> 是实数。假设有 n 个区间，第 i个区间为 <spanclass="math inline">\([b_i,e_i]\)</span>。问题就变成确定区间 <spanclass="math inline">\([b_i,e_j]\)</span> 和 <spanclass="math inline">\([b_j,e_j]\)</span> 相交的组合。</p><p>该问题最初可通过排序-扫描算法(sort and sweep algorithm)解决。首先，创建一个包含所有区间起点 <spanclass="math inline">\(b_i\)</span> 和终点 <spanclass="math inline">\(e_i\)</span>的有序列表(按值从低到高排序)。接着对列表执行扫描(sweep)，并维护一个初始为空的活动区间列表(activeintervals)。当遇到某个区间的起点 <spanclass="math inline">\(b_i\)</span>时，将该区间加入活动列表，并将活动列表中所有已有区间输出为“与区间 i重叠”（如图18a所示）；当遇到某个区间的终点 <spanclass="math inline">\(e_i\)</span>时，将该区间从活动列表中移除（如图18b所示）。该过程的时间复杂度为：创建有序列表需<span class="math inline">\(O(n\log n)\)</span>，扫描列表需 <spanclass="math inline">\(O(n)\)</span>，输出每个重叠关系需 <spanclass="math inline">\(O(k)\)</span> (k为重叠关系总数)。因此，总时间复杂度为 <spanclass="math inline">\(O(n\logn+k)\)</span>，这是解决该问题的最优算法。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure18.png" /><br />后续比较可以用以下方法优化。首先不必使用 <spanclass="math inline">\(O(n\log n)\)</span> 算法构建 <spanclass="math inline">\(b_i,e_i\)</span> 的有序序列。利用前一个时间步进的<span class="math inline">\(b_i,e_i\)</span>的已有序列更高效。若时间相干性足够高，当前时间步进的有效序列几乎和前一个时间步进一致。因此可使用插入排序<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="R. Sedgewick. Algorithms. Addison-Wesley, 1983.">[15]</span></a></sup>将“接近有序”的列表排列成有序列表。插入排序的原理是：将元素向列表头部移动，直到遇到比它更小的元素。具体来说，先比较第二个元素与第一个元素(必要时交换)，再将第三个元素向头部移动直到找到合适位置，以此类推；每次元素移动都对应两个值的顺序变化。当列表最后一个元素处理完成后，列表即有序。这种排序的时间复杂度为<span class="math inline">\(O(n+c)\)</span> (c为所需的交换操作次数)。例如，图19与图18的唯一区别是“区间4”向右移动了——从图18的有序列表出发，只需<strong>一次交换</strong>就能得到图19的有序列表。插入排序一般不建议作为通用排序方法(因其最坏情况需要<span class="math inline">\(O(n^2)\)</span>次交换)；但在<strong>高时间相干性的场景</strong>（如本算法环境）中，处理“近乎有序”的列表时，它是高效的。要完善算法，需注意：若两个区间<span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>在<strong>前一时间步进重叠</strong>，但在<strong>当前时间步不重叠</strong>，则必然发生了涉及<span class="math inline">\(b_i\)</span>（或 <spanclass="math inline">\(e_i\)</span>）与 <spanclass="math inline">\(b_j\)</span>（或 <spanclass="math inline">\(e_j\)</span>)的一次或多次交换；反之，若区间 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>从前一时间步“不重叠”变为当前时间步“重叠”，也存在同样的交换逻辑。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure19.png" /><br />因此，如果我们在每个时间步进内维护一张重叠区间表，这张表可以在每个时间步进内以<span class="math inline">\(O(n+c)\)</span>的消耗被更新。假设有相干性(前后时刻区序列的差距很小)，那么所必须的交换次数<span class="math inline">\(c\)</span> 将接近实际有效的交换次数 <spanclass="math inline">\(k\)</span>(这里的有效是在说，插入删除我们元素前移的过程中可能需要多次交换次数才能让元素到达正确的位置)，而额外的<span class="math inline">\(O(c-k)\)</span>可以忽略不计。因此，对于一维边界框问题，连贯性视角产生了一种极其(乃至极致<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="不会翻译 - if not maximal">[18]</span></a></sup>)简单的算法，其随着连贯性的提升而逼近最优解。</p><h5 id="the-three-dimensional-case">7.2.2 The three-dimensionalcase</h5><p>求解三维空间包围盒相交问题的高效几何算法比一维空间的复杂得多。然而这些算法都有共同点，本质上都是在坐标轴上进行排序，就像之前的一维空间一样。每个包围盒被描述成三个独立区间<spanclass="math inline">\([b_i^{(x)},e_i^{(x)}],[b_i^{(y)},e_i^{(y)}],[b_i^{(z)},e_i^{(z)}]\)</span>，表示第i个包围盒在三维坐标中的区间。因此我们首先能想到的，针对具有空间一致性下的几何算法，提高其效率的优化思路就是对包含<span class="math inline">\([b_i^{(x)},e_i^{(x)}]\)</span>的列表进行排序，对于 y,z 轴也是同理的。同样的这个步骤会提升 <spanclass="math inline">\(O(n+c)\)</span> 的效率，这里 c已经是三个列表交换次数的总和了。不过，如果我们注意到检测两个包围盒相交是常数时间复杂度的话，如果我们只是简单的判断相交即无论何时在索引<span class="math inline">\(i,j\)</span>对应的数据间发生交换操作(在任意坐标轴上)，我们就能在 <spanclass="math inline">\(O(n+c)\)</span>是时间尺度上检测所有的相交变化。<br />同样的，我们维护一个重叠包围盒表，并且在每个时间步进内以 <spanclass="math inline">\(O(n+c)\)</span> 的代价更新。额外交换消耗还是 <spanclass="math inline">\(O(c-k)\)</span>。在三维空间情况下，如果两个包围盒在某一个坐标轴上发生改变，但是实际上他们没有相交，可能会增加额外的计算。在实际中，可以发现额外消耗可以不急，并且算法基本在<span class="math inline">\(O(n+k)\)</span> 时间内完成。</p><h3 id="colliding-contact">8. Colliding Contact</h3><p>在笔记剩余部分我们将研究某一特定时刻 <spanclass="math inline">\(t_0\)</span> 时的物体状态。在这个时间 <spanclass="math inline">\(t_0\)</span>我们假设：没有物体相交，并且模拟器已经确定了那些物体接触、在哪个点接触。为了简化情况，我们假设所有物体都是多面体并且物体间所有的接触点都被检测到了。我们将多面体间顶点/面和 边/边 接触视为接触。一个顶点接触另一个多面体的面时就视为发生点/面接触。当一对边接触时视为发生 边/边接触，这种情况下认为两条边不共线。(点/点 和 点/边情况将被忽略，本篇不考虑这两种情况。)例如放在平面上的立方体可以视为有 4个 点/面接触，桌面上每个角各有一个。一个立方体放在桌子上但是底部悬在桌子边缘，仍然存在4 个触点；两个在桌面的顶点是 点/面触点，两个 一条立方体的边 和 桌面边形成的 边/边 触点。<br />每个触点可以结构化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Contact</span><br>&#123;<br>    RigidBody*a, <span class="hljs-comment">// body containing vertev</span><br>    *b; <span class="hljs-comment">// body containing face</span><br>    triplep,  <span class="hljs-comment">// world-space vertex location</span><br>    n,<span class="hljs-comment">// outwards pointing normal of face</span><br>    ea,<span class="hljs-comment">// edge direction for A</span><br>    eb; <span class="hljs-comment">// edge direction for B</span><br>    booleanvf; <span class="hljs-comment">// TRUE if vertex/face contact</span><br>&#125;;<br><br><span class="hljs-type">int</span> Ncontacts;<br>Contact *Contacts;<br></code></pre></td></tr></table></figure><p>如果发生 点/面 接触，变量 <span class="math inline">\(a\)</span>指向接触顶点所属的刚体，<span class="math inline">\(b\)</span>指向面所属的刚体。我们称这两个物体为 <spanclass="math inline">\(A,B\)</span>，对于点/面 接触，变量 <spanclass="math inline">\(n\)</span>被设为刚体接触面指向外侧的单位法线，变量 <spanclass="math inline">\(ea,eb\)</span> 没有被用到。<br />对于 边/边 接触，<span class="math inline">\(ea\)</span>是一个三维单位向量，指向物体 A(由a指定) 接触边的方向，<spanclass="math inline">\(eb\)</span> 也是同理。对于边/边接触，<spanclass="math inline">\(n\)</span> 表示 <spanclass="math inline">\(ea\times eb\)</span>方向的单位向量。我们和以前一样，将两个接触体标记为 <spanclass="math inline">\(A,B\)</span>，使得法线方向 <spanclass="math inline">\(ea\times eb\)</span> 从 B 指向外部，指向A，就像点/面 接触一样。<br />这两种接触类型，接触点的世界空间位置由 <spanclass="math inline">\(p\)</span>给出(要么是接触点，要么是两条线的交点)。碰撞检测程序负责查找所有接触点，将<code>Ncontacts</code> 设为接触点数量，并为 <code>contact</code>数组分配空间初始化。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure20.png" /><br />首先我们要做的是检查所有 <code>Contact</code>结构体，检测是否发生了碰撞接触。对于给定的接触点，两个物体在点<code>p</code> 处接触。设 <span class="math inline">\(p_a(t)\)</span>表示物体 A 的特定一点，满足 <spanclass="math inline">\(p_a(t_0)=p\)</span>。(对于点/面接触而言,这个点就是顶点本身；对于边/边接触而言，是物体A接触边上的一些特定点。)相似的，设<span class="math inline">\(p_b(t)\)</span> 表示物体 B 上特定一点，满足<span class="math inline">\(p_b(t_0)=p\)</span> (figure 20)。尽管 <spanclass="math inline">\(p_a(t_0),p_b(t_0)\)</span> 是相同的，但是两点在<span class="math inline">\(t_0\)</span>的速度可不一定是相同的。我们将检测速度观察物体是否会发生碰撞。<br />根据 2.5 节的内容我们可以知道 <spanclass="math inline">\(\dot{p_a}(t_0)\)</span><br /><span class="math display">\[\dot{p_a}(t_0)=\omega(t)\times(p_a(t_0)-x_a(t_0))+v_a(t_0)\tag{8-1}\]</span></p><p><span class="math display">\[\dot{p_b}(t_0)=\omega(t)\times(p_b(t_0)-x_b(t_0))+v_b(t_0)\tag{8-2}\]</span></p><p>让我们考察一个标量物理量。<br /><span class="math display">\[v_{rel}=\hat n(t_0)\cdot(\dot{p_a}(t_0)-\dot{p_b}(t_0))\tag{8-3}\]</span> <imgsrc="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure21.png" /><br />在该式子中，<span class="math inline">\(\hat n(t_0)\)</span>是每个接触点的表面单位法线，通过变量 <code>n</code> 描述。物理量 <spanclass="math inline">\(v_{rel}\)</span> 给出了 <spanclass="math inline">\(\dot{p_a}(t_0)-\dot{p_b}(t_0)\)</span> 在 <spanclass="math inline">\(\hat n(t_0)\)</span> 方向上的相对速度。很明显，若<span class="math inline">\(v_{rel}\)</span> 是正数，则表示相对速度<span class="math inline">\(\dot{p_a}(t_0)-\dot{p_b}(t_0)\)</span> 就是<span class="math inline">\(\hat n(t_0)\)</span>的正方向，说明两个物体正在相互远离，接触点将在 <spanclass="math inline">\(t_0\)</span> 时刻后立刻消失，正如 figure21。我们无需关心这种情况。<br />若 <span class="math inline">\(v_{rel}\)</span> 是0，说明物体既没接近又没远离 <span class="math inline">\(p\)</span>点(figure 22)。这就是所谓静止接触，在下一节我们会处理这种情况。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure22.png" /><br />还有最后一种情况，<spanclass="math inline">\(v_{rel}&lt;0\)</span>，这意味着相对速度和 <spanclass="math inline">\(\hat n(t_0)\)</span>方向相反，会发生接触碰撞。如果物体速度没有立即改变，就会发生互相穿透(figure23)。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure23.png" /><br />我们如何改变速度？任何力影响点 <spanclass="math inline">\(p\)</span>，都需要至少一小段时间来完全停止两者之间的相对运动，无论这个力有多强。由于我们想物体瞬间改变速度，我们假设一个新的物理量，冲量<span class="math inline">\(J\)</span>。冲量是一个矢量，类似力，但是有动量单位。施加冲量可以使物体速度瞬间改变，我们可以想象一个很大的力作用在一个很短的时间<span class="math inline">\(\Delta t\)</span> 内。如果我们令 <spanclass="math inline">\(F\)</span> 接近无穷，<spanclass="math inline">\(\Delta t\)</span> 接近 0，且满足<br /><span class="math display">\[F\Delta t=J\tag{8-4}\]</span> 通过分析力 <span class="math inline">\(F\)</span> 在时间 <spanclass="math inline">\(\Delta t\)</span>内对速度的影响，我们可以推导出冲量 <spanclass="math inline">\(J\)</span> 对物体速度的作用规律。<br />例如我们对质量 <span class="math inline">\(M\)</span> 的物体施加冲量<span class="math inline">\(J\)</span>，线速度改变为：<br /><span class="math display">\[\Delta v=\frac{J}{M}\tag{8-5}\]</span> 同样的，线性动量的变化 <span class="math inline">\(\DeltaP\)</span> 被简化为 <span class="math inline">\(\DeltaP=J\)</span>。如果冲量作用于点 <spanclass="math inline">\(p\)</span>，那么就类似力能够产生扭矩一样，<spanclass="math inline">\(J\)</span> 也可以有冲量扭矩。<br /><span class="math display">\[\tau_{impulse}=(p-x(t))\times J\tag{8-6}\]</span> 可以想象，冲量扭矩 <spanclass="math inline">\(\tau_{impulse}\)</span> 也会引起角动量的变化 <spanclass="math inline">\(\DeltaL=\tau_{impulse}\)</span>。角速度的改变可以简化为 <spanclass="math inline">\(I^{-1}(t_0)\tau_{impulse}\)</span>，假设冲量作用在时间<span class="math inline">\(t_0\)</span>。<br />当两个物体碰撞时，我们将在他们之间应用一个冲量来改变他们的速度。对于无摩擦力影响的物体，冲量方向就是法线方向，<spanclass="math inline">\(\hat n(t_0)\)</span>。因此我们简写<br /><span class="math display">\[J=j\hat n(t_0)\tag{8-7}\]</span> 这里的 <span class="math inline">\(j\)</span>是一个尚未确定的标量，其给出了冲量的大小。我们将采用以下约定，冲量<spanclass="math inline">\(J\)</span> 以正值作用于物体A，即物体A收到冲量<span class="math inline">\(+j\hatn(t_0)\)</span>，所以物体B受大小相等方向相反的冲量 <spanclass="math inline">\(-j\hat n(t_0)\)</span>(figure 24)。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure24.png" /><br />我们通过碰撞试验的经验法则来计算 <spanclass="math inline">\(j\)</span>。设 <spanclass="math inline">\(\dot{p}_a^-(t_0)\)</span>为施加冲量前接触顶点的速度， <spanclass="math inline">\(\dot{p}_a^+(t_0)\)</span> 为我们施加冲量 <spanclass="math inline">\(J\)</span> 后的速度。 <spanclass="math inline">\(\dot{p}_b^-(t_0),\dot{p}_b^+(t_0)\)</span>也同样这样定义。使用这些符号，得到在法线上的相对速度是<br /><span class="math display">\[v_{rel}^-=\hat{n}(t_0)\cdot(\dot{p}_a^-(t_0)-\dot{p}_b^-(t_0))\tag{8-8}\]</span> 在冲量应用后：<br /><span class="math display">\[v_{rel}^+=\hat{n}(t_0)\cdot(\dot{p}_a^+(t_0)-\dot{p}_b^+(t_0))\tag{8-9}\]</span> 无摩擦的经验定律描述为：<br /><span class="math display">\[v_{rel}^+=-\epsilon v_{rel}^-\tag{8-10}\]</span> <span class="math inline">\(\epsilon\)</span>成为恢复系数，必须满足 <spanclass="math inline">\(0\leq\epsilon\leq1\)</span>。<br />如果 <span class="math inline">\(\epsilon=1\)</span>，则 <spanclass="math inline">\(v_{rel}^+=v_{rel}^-\)</span>，这个碰撞是完全弹性碰撞，且没有动能损失维持动能守恒。<br />在另一个端点，<span class="math inline">\(\epsilon=0\)</span>，则 <spanclass="math inline">\(v_{rel}^+=0\)</span>动能损失达到最大，在碰撞之后两物体在接触点 p 进入静接触模式。(figure25)<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure25.png" /><br />计算冲量 <span class="math inline">\(J=j\hat{n}(t_0)\)</span>的大小相对简单，尽管推导过程有点麻烦。我们定义位移 <spanclass="math inline">\(p-x_a(t_0),p-x_b(t_0)\)</span> 为 <spanclass="math inline">\(r_a,r_b\)</span>，如果我们令 <spanclass="math inline">\(v_a^-(t_0),\omega_a^-(t_0)\)</span> 表示物体 A碰撞前的速度，<spanclass="math inline">\(v_a^+(t_0),\omega_a^+(t_0)\)</span> 表示物体 A碰撞后的速度，则可以列出<br /><span class="math display">\[\dot{p}_a^+(t_0)=v_a^+(t_0)+\omega_a^+(t_0)\times r_a\tag{8-11}\]</span></p><p><span class="math display">\[\begin{aligned}v_a^+(t_0)&amp;=v_a^-(t_0)+\frac{j\hat{n}(t_0)}{M_a}\\\omega_a^+(t_0)&amp;=\omega_a^-(t_0)+I_a^{-1}(t_0)(r_a\timesj\hat{n}(t_0))\\\end{aligned}\tag{8-12}\]</span></p><p><span class="math display">\[\begin{aligned}\dot{p}_a^+(t_0)&amp;=(v_a^-(t_0)+\frac{j\hat{n}(t_0)}{M_a})+(\omega_a^-(t_0)+I_a^{-1}(t_0)(r_a\timesj\hat{n}(t_0)))\times r_a\\&amp;=v_a^-(t_0)+\omega_a^-(t_0)\times r_a+(\frac{j\hat{n}(t_0)}{M_a})+(I_a^{-1}(t_0)(r_a\times j\hat{n}(t_0)))\times r_a\\&amp;=\dot{p}_a^-+j(\frac{\hat{n}(t_0)}{M_a}+I_a^{-1}(t_0)(r_a\times\hat{n}(t_0)))\timesr_a\end{aligned}\tag{}\]</span></p><p>对于 <span class="math inline">\(\dot{p}_a^+(t_0)\)</span>我们可以法线，这是一个给关于 j 的线性函数，<br />对于物体 B，而言，收到一个相反的冲量<spanclass="math inline">\(-j\hat{n}(t_0)\)</span><br /><span class="math display">\[\dot{p}_b^+(t_0)=\dot{p}_b^--j(\frac{\hat{n}(t_0)}{M_a}+I_a^{-1}(t_0)(r_a\times\hat{n}(t_0)))\timesr_b\tag{8-14}\]</span></p><p><span class="math display">\[\begin{aligned}\dot{p}_a^+(t_0)-\dot{p}_b^+(t_0)&amp;=(\dot{p}_a^+-\dot{p}_b^+)+j(\frac{\hat{n}(t_0)}{M_a}+\frac{\hat{n}(t_0)}{M_b}+\\&amp;(I_a^{-1}(t_0)(r_a\times\hat{n}(t_0)))\times r_a+(I_b^{-1}(t_0)(r_b\times\hat{n}(t_0)))\times r_b)\end{aligned}\tag{8-15}\]</span></p><p>为了计算 <span class="math inline">\(v_{rel}^+\)</span> 我们使用带<span class="math inline">\(\hat{n}(t_0)\)</span> 的表达式，由于 <spanclass="math inline">\(\hat{n}(t_0)\)</span> 是单位矢量， <spanclass="math inline">\(\hat{n}(t_0)\cdot\hat{n}(t_0)=1\)</span>，则：<br /><span class="math display">\[\begin{aligned}v_{rel}^+&amp;=\hat{n}(t_0)\cdot(\dot{p}_a^+(t_0)-\dot{p}_b^+(t_0))\\&amp;=\hat{n}(t_0)\cdot(\dot{p}_a^-(t_0)-\dot{p}_b^-(t_0))+j\bigg(\frac{1}{M_a}+\frac{1}{M_b}+\\&amp;\hat{n}(t_0)\cdot\big(I_a^{-1}(t_0)(r_a\times\hat{n}(t_0))\big)\times r_a+\hat{n}(t_0)\cdot\big(I_b^{-1}(t_0)(r_b\times\hat{n}(t_0))\big)\times r_b\bigg)\\&amp;=v_{rel}^-+j\bigg(\frac{1}{M_a}+\frac{1}{M_b}+\\&amp;\hat{n}(t_0)\cdot\big(I_a^{-1}(t_0)(r_a\times\hat{n}(t_0))\big)\times r_a+\hat{n}(t_0)\cdot\big(I_b^{-1}(t_0)(r_b\times\hat{n}(t_0))\big)\times r_b\bigg)\end{aligned}\tag{8-16}\]</span> 我们能够使用 <span class="math inline">\(v_{rel}^-\)</span>表达 <span class="math inline">\(v_{rel}^+\)</span> ，根据 8-10 和8-16：<br /><span class="math display">\[\begin{aligned}v_{rel}^-+j\bigg(\frac{1}{M_a}+\frac{1}{M_b}+\hat{n}(t_0)\cdot\Big(I_a^{-1}(t_0)(r_a\times\hat{n}(t_0))\Big)\times r_a+\\\hat{n}(t_0)\cdot\Big(I_b^{-1}(t_0)(r_b\times\hat{n}(t_0))\Big)\times r_b\bigg)=-\epsilonv_{rel}^+\end{aligned}\tag{8-17}\]</span></p><p><span class="math display">\[\begin{aligned}j&amp;=\\&amp;\frac{-(1+\epsilon)v_{rel}^-}{\frac{1}{M_a}+\frac{1}{M_b}+\hat{n}(t_0)\cdot\Big(I_a^{-1}(t_0)\big(r_a\times\hat{n}(t_0)\big)\Big)\times r_a+\hat{n}(t_0)\cdot\Big(I_b^{-1}(t_0)\big(r_b\times\hat{n}(t_0)\big)\Big)\times r_b}\end{aligned}\tag{8-18}\]</span></p><blockquote><p>这里原文放了一大堆代码，我就不写了……懒了</p></blockquote><p>需注意以下几点： 恢复系数 <spanclass="math inline">\(\epsilon=0.5\)</span>是任意选取的。在实际物理引擎实现中，需允许用户根据碰撞物体的材质组合（如“钢球-橡胶垫”与“木块-金属板”的碰撞），灵活设置不同的<span class="math inline">\(\epsilon\)</span> 值;<br />每次检测到碰撞时，必须重新扫描接触点列表：<br />因为原本静止的物体可能因碰撞开始运动，且新的碰撞事件也可能同步发生;<br />多接触点碰撞的顺序对模拟结果有影响：<br />例如“立方体平落至平面”时，四个顶点会同时发生碰撞——此时若按不同顺序处理接触点，模拟结果可能截然不同。虽然存在“同时计算多个接触点的冲量”的进阶方法，但实现更复杂，且其原理基于下一节“静接触”的核心概念。若需深入，可参考Baraff的文献<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="D. Baraff. Analytical methods for dynamic simulation of non-penetrating rigid bodies. In Computer Graphics (Proc. SIGGRAPH), volume 23, pages 223–232. ACM, July 1989.]">[1]</span></a></sup>。<br />顺便说一下，如果您想要某些物体是“固定的”，不能移动（比如地板或墙壁），您可以使用以下技巧：对于此类物体，将质量设为0；同时让惯性张量的逆矩阵也为 3×3的零矩阵。您可以专门编写代码来检查某个物体是否应固定不动，或者重新编写刚体的定义，用invmass 替代 mass。对于普通物体，invmass是质量的倒数，而对于固定物体，invmass 为0。惯性张量也是如此。（请注意，在任何动力学计算（包括下一节）中都不会使用质量或惯性张量，只使用它们的逆矩阵，所以您无需担心除以零的问题。）在下一节关于静止接触的内容中，也可以使用同样的技巧来模拟能够承受任意重量而不移动的物体。</p><h3 id="resting-contact">9. Resting Contact</h3><p>静止接触的情况，当物体在接触点既不碰撞也不分离时，是我们将在这些笔记中解决的最后（也是最难的）动力学问题。要实现本节中的内容，必须设计一个相当复杂的数值软件，我们将在下面描述它。<br />对于这种情况，我们假设有 n个接触点的情景。在每个接触点，物体都处于静接触状态，也就是说，按照第 8节的说法，相对速度 <span class="math inline">\(v_{rel}\)</span>是零(指在数值容差THRESHOLD 内可以视为零)。我们可以这样认为，因为<code>find_all_collisions</code> 程序能够消除碰撞接触，并且任何相对速度<span class="math inline">\(v_{rel}\)</span> 大于 THRESHOLD的接触点都可以安全地忽略，因为此时物体正在分离状态。<br />与碰撞接触类似，对于每个接触点，存在一个作用在接触面沿着接触面法线的接触力。对于碰撞接触情况，有冲量<span class="math inline">\(j\hat{n}(t_0)\)</span>，<spanclass="math inline">\(j\)</span>是未知的标量。对于静接触情况，每个接触点某个力 <spanclass="math inline">\(f_i\hat{n}_i(t_0)\)</span>，<spanclass="math inline">\(f_i\)</span> 是一个未知的标量，<spanclass="math inline">\(\hat{n}_i(t_0)\)</span> 是第 i个接触点的法线(figure 26)。我们的目标是计算每个 <spanclass="math inline">\(f_i\)</span> 大小。在计算 <spanclass="math inline">\(f_i\)</span>们的时候，他们必须被同时被确定，因为在第 i个接触点的力可能会影响物体上第 j个接触点，可能会影响发生接触的两个物体的其中一个，也可能两个物体都会受到影响。在第8 节我们写过接触点 <spanclass="math inline">\(p_a(t_0),p_b(t_0)\)</span> 速度如何随 <spanclass="math inline">\(j\)</span>变化。在这节我们会做类似的事，不过现在需要描述点 <spanclass="math inline">\(p_a(t_0),p_b(t_0)\)</span><em>加速度</em>如何根据每个 <span class="math inline">\(f_i\)</span>变化。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure26.png" /></p><p>对于碰撞接触，有经验规律，将冲量强度 <spanclass="math inline">\(j\)</span>与相对速度和恢复系数联系起来。对于静接触，根据三个条件来计算 <spanclass="math inline">\(f_i\)</span> 们。<br /><strong>首先，接触力必须避免相互穿透</strong>，就是说，接触力必须足够大防止接触的两个物体发生“挤压”。<br /><strong>其次，我们希望接触力是互相排斥的</strong>，接触力能把物体相互推开，但是不能像“胶水”一样将两个物体粘在一起。<br /><strong>最后，要求当物体开始分离的时候，接触点的力必须为零</strong>。例如，当一个方块静置在桌子上，在接触点上可能有一些力防止方块在重力作用下向下加速。然而如果有一个力使得方块向上，那么方块和桌子的接触力在方块离开桌子的那一刻就会为零。</p><p>让我们解决第一个条件：<strong>预防相互穿透</strong>。对于每个接触点<span class="math inline">\(i\)</span>，我们构建表达式 <spanclass="math inline">\(d_i(t)\)</span>，该表达式描述了在时刻 <spanclass="math inline">\(t\)</span>接触点上两物体的分离距离。距离为正值则表示物体已脱离接触，并且在第 <spanclass="math inline">\(i\)</span>点发生分离。而距离值为负，则表示相互穿透。因为在时刻 <spanclass="math inline">\(t_0\)</span> 物体发生接触，对于每个接触点都有<spanclass="math inline">\(d_i(t_0)=0\)</span>(在数值容差范围内)。我们的目标是确保<strong>接触力</strong>使得每个接触点的在未来时刻<span class="math inline">\(t&gt;t_0\)</span>，始终满足 <spanclass="math inline">\(d_i(t)\ge 0\)</span>。</p><p>对于点/面接触，能够离开构建简单的函数 <spanclass="math inline">\(d_i(t)\)</span>。若点 <spanclass="math inline">\(p_a(t),p_b(t)\)</span> 是物体 A,B 的第 i个接触点，则在未来时刻 <span class="math inline">\(t\ge t_0\)</span>顶点和面的距离为<br /><span class="math display">\[d_i(t)=\hat{n}_i(t)\cdot(p_a(t)-p_b(t))\tag{9-1}\]</span> 在时刻 <span class="math inline">\(t\)</span>，函数 <spanclass="math inline">\(d(t)\)</span> 表示了物体 A,B 之间的分离距离。若<span class="math inline">\(d_i(t)\)</span> 为零，则在第 i个接触点物体将会失去接触。然而如果 <spanclass="math inline">\(d_i(t)&lt;0\)</span>，物体就相互穿透了，这是需要避免的(figure27)。同样的函数也可以用在边/边接触，因为 <spanclass="math inline">\(\hat{n}_i(t)\)</span>是指向外侧，从B指向A(通常都这么定义的)，如果两个接触边移动使物体分离，<spanclass="math inline">\(\hat{n}_i(t)\cdot(p_a(t)-p_b(t))\)</span>将为正值。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅱ/figure27.png" /><br />由于 <spanclass="math inline">\(d_i(t_0)=0\)</span>，我们必须保证给在时刻 <spanclass="math inline">\(t_0\)</span>，<spanclass="math inline">\(d_i(t_0)\)</span> 不会有减小趋势，即必须有 <spanclass="math inline">\(\dot{d_i}(t_0)\ge 0\)</span>。<br /><span class="math display">\[\dot{d_i}(t_0)=\dot{\hat{n}}_i(t)\cdot(p_a(t)-p_b(t))+\hat{n}_i(t)\cdot(\dot{p}_a(t)-\dot{p}_b(t))\tag{9-2}\]</span> 因为 <span class="math inline">\(d_i(t)\)</span>描述分离距离，<span class="math inline">\(\dot{d_i}(t)\)</span>描述的是在时刻 <span class="math inline">\(t\)</span>的分离速度。然而在时刻 <spanclass="math inline">\(t_0,p_a(t_0)=p_b(t_0)\)</span> 意味着 <spanclass="math inline">\(\dot{d_i}(t_0)=\hat{n}(t_0)\cdot(\dot{p}_a(t_0)-\dot{p}_b(t_0))\)</span>。式子和前面提到的<span class="math inline">\(v_{rel}\)</span> 比较相似。函数 <spanclass="math inline">\(\dot{d_i}(t_0)\)</span>是判断物体如何分离的度量，对于静接触物体，<spanclass="math inline">\(\dot{d_i}(t_0)=0\)</span>，因为物体在接触点上既不会再接近彼此，也不会远离对方。<br />在此基础上，可以推断出 <spanclass="math inline">\(d_i(t_0)=\dot{d_i}(t_0)=0\)</span>。来观察 <spanclass="math inline">\(\ddot{d_i}(t_0)\)</span>,<br /><span class="math display">\[\tag{9-3}\begin{aligned}\ddot{d_i}(t)&amp;=\Big(\ddot{\hat{n}}_i(t)\cdot\big(p_a(t)-p_b(t)\big)+\dot{\hat{n}}_i(t)\cdot\big(\dot{p}_a(t)-\dot{p}_b(t)\big)\Big)+\\&amp;\Big(\dot{\hat{n}}_i(t)\cdot\big(\dot{p}_a(t)-\dot{p}_b(t)\big)+\hat{n}_i(t)\cdot\big(\ddot{p}_a(t)-\ddot{p}_b(t)\big)\Big)\\&amp;=\ddot{\hat{n}}_i(t)\cdot(p_a(t)-p_b(t))+\\&amp;2\dot{\hat{n}}_i(t)\cdot\big(\dot{p}_a(t)-\dot{p}_b(t)\big)+\hat{n}_i(t)\cdot\big(\ddot{p}_a(t)-\ddot{p}_b(t)\big)\end{aligned}\]</span> 有 <spanclass="math inline">\(p_a(t_0)=p_b(t_0),\ddot{d_i}(t_0):\)</span><br /><span class="math display">\[\ddot{d_i}(t_0)=2\dot{\hat{n}}_i(t_0)\cdot\big(\dot{p}_a(t_0)-\dot{p}_b(t_0)\big)+\hat{n}_i(t)\cdot\big(\ddot{p}_a(t_0)-\ddot{p}_b(t_0)\big).\tag{9-4}\]</span> 物理量 <span class="math inline">\(\ddot{d_i}(t_0)\)</span>意味着在接触点 <span class="math inline">\(p\)</span>两个物体相对的加速度如何。<br />若 <spanclass="math inline">\(\ddot{d_i}(t_0)&gt;0\)</span>，物体彼此之间有远离的加速度，在时刻<span class="math inline">\(t_0\)</span> 后，接触立刻分离。<br />如果 <spanclass="math inline">\(\ddot{d_i}(t_0)=0\)</span>，则保持接触状态。<br />另一种情况 <span class="math inline">\(\ddot{d_i}(t_0)&lt;0\)</span>必须避免，因为这表示物体相对加速度是向着彼此的。<br />注意，如果物体 B 是固定的，则 <spanclass="math inline">\(\hat{n}_i(t_0)\)</span> 是常数，得 <spanclass="math inline">\(\dot{\hat{n}}_i(t_0)\)</span>是零，式子可以进一步简化。</p><p>因此，针对每个接触点我们有如下约束，来保证接触力的第一个条件——<strong>预防相互穿透</strong>。<br /><span class="math display">\[\ddot{d_i}(t_0)\ge0\tag{9-5}\]</span> 由于加速度 <spanclass="math inline">\(\ddot{d_i}(t_0)\)</span>取决于接触力，所以这实际上就是对接触力的约束。</p><p>下面来研究一下第二条和第三条约束。由于<strong>接触力总是表现为相互排斥的</strong>，所以每个接触力的方向的必须向外作用。这意味着每个<span class="math inline">\(f_i\)</span> 都必须为正，因为作用在物体 A上的力为 <span class="math inline">\(f_i\hat{n}_i(t_0)\)</span>，而<span class="math inline">\(\hat{n}_i(t_0)\)</span> 是指向外侧朝向 B的法线，所以针对每个接触点都要满足：<br /><span class="math display">\[f_i\ge0\tag{9-6}\]</span> 第三个约束可以简单的用 <spanclass="math inline">\(f_i,\ddot{d_i}(t_0)\)</span> 表示。因为如果第 i个接触点正在分离，接触力 <spanclass="math inline">\(f_i\hat{n}_i(t_0)\)</span>必须为零。可以表示为：<br /><span class="math display">\[f_i\ddot{d_i}(t_0)=0;\tag{9-7}\]</span> 如果接触正在分离，<spanclass="math inline">\(\ddot{d_i}(t_0)&gt;0\)</span> 并且要满足等式(9-7)则必有 <span class="math inline">\(f_i=0\)</span>。如果接触不分离，则<span class="math inline">\(\ddot{d_i}(t_0)=0\)</span>并且满足了等式(9-7)不必理会 <spanclass="math inline">\(f_i\)</span>。</p>为了真的找到满足等式(9-5),(9-6),(9-7)，我们要用未知的 <spanclass="math inline">\(f_i\)</span> 们描述每一个 <spanclass="math inline">\(\ddot{d}_i(t_0)\)</span>。<br /><span class="math display">\[\ddot{d_i}(t_0)=a_{i1}f_1+a_{i2}f_2+\cdots+a_{in}f_n+b_i.\tag{9-8}\]</span> 矩阵形式为<br />$$<span class="math display">\[\begin{aligned}\begin{pmatrix}\ddot{d_1}(t_0)\\\vdots\\\ddot{d_n}(t_0)\end{pmatrix}=\textbf{A}\begin{pmatrix}f_1\\\vdots\\f_n\end{pmatrix}+\begin{pmatrix}b_i\\\vdots\\b_n\end{pmatrix}\end{aligned}\tag{9-9}\]</span><p>$$ <span class="math inline">\(\textbf{A}\)</span> 是式(9-8) 中 <spanclass="math inline">\(a_{ij}\)</span> 的 nxn 系数矩阵。尽管计算 <spanclass="math inline">\(a_{ij},b_i\)</span>的代码并不复杂，但是计算部分代码所依赖的推导过程有些复杂。推导过程我们放在附录D，以及计算<span class="math inline">\(a_{ij},b_i\)</span> 的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_a_matrix</span><span class="hljs-params">(Contact contacts[ ], <span class="hljs-type">int</span> ncontacts,</span></span><br><span class="hljs-params"><span class="hljs-function">bigmatrix &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_b_vector</span><span class="hljs-params">(Contact contacts[ ], <span class="hljs-type">int</span> ncontacts,</span></span><br><span class="hljs-params"><span class="hljs-function">vector &amp;b)</span></span>;<br></code></pre></td></tr></table></figure><p>这里 <code>matrix,vector</code>类型表示任意大小的矩阵和向量。第一个计算 <spanclass="math inline">\(a_{ij}\)</span>， 第二个计算 <spanclass="math inline">\(b_{i}\)</span>。</p><p>一旦我们计算完这些，就可以解方程 (9-5),(9-6),(9-7)。这个方程形式就是二次规划——<em>quadratic program</em>(QP)。也就是说满足这个方程的 <spanclass="math inline">\(f_i\)</span> 是通过叫做 quadratic programming的算法得到的。不是所有的二次规划问题又能高效的得到对应解，但是我们的接触力都是垂直于接触面的(意味着不涉及摩擦)，事实证明，关于我们这种QP 问题是可以高效解决的。值得一提的是，QP 代码很容易处理 <spanclass="math inline">\(\ddot{d_i}(t_0)=0\)</span> 而不是 <spanclass="math inline">\(\ddot{d_i}(t_0)\ge0\)</span>。如果我们希望约束两个物体在接触点永远不分离，我们需要<span class="math inline">\(\ddot{d_i}(t_0)=0\)</span> (并且丢掉约束<spanclass="math inline">\(f_i\ge0\)</span>)。这使得我们在仿真过程中能实现铰链(hinges)、销接头(pin-joints)以及非穿透约束。</p><p>然而二次规划的代码并不常见，显然他们不像线性方程那么常见，而且实现也更困难。原文的二次规划程序来自theDepartment of Operations Research at Stanford University，详情参考 Gilletal.<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="P. Gill, S. Hammarling, W. Murray, M. Saunders, and M. Wright. User’s guide for LSSOL: A Fortran package for constrained linear least-squares and convex quadratic programming. Technical Report Sol 86-1, Systems Optimization Laboratory, Department of Operations Research, Stanford University, 1986.">[7]</span></a></sup><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="P. Gill, W. Murray, M. Saunders, and M. Wright. User’s guide for QPSOL: A Fortran package for quadratic programming. Technical Report Sol 84-6, Systems Optimization Laboratory, Department of Operations Research, Stanford University, 1984.">[8]</span></a></sup><sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="P. Gill, W. Murray, M. Saunders, and M. Wright. User’s guide for NPSOL: A Fortran package for nonlinear programming. Technical Report Sol 86-2, Systems Optimization Laboratory, Department of Operations Research, Stanford University, 1986.">[9]</span></a></sup>。文中经常使用Bareff<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="D. Baraff. Fast contact force computation for nonpenetrating rigid bodies. Computer Graphics (Proc. SIGGRAPH), 28:23–34, 1994.">[3]</span></a></sup>提供的二次规划代码。如果真的咬定青山不放松，建议直接看这篇论文(除了关于接触和摩擦的部分)。<br />无论如何，我们假设有一个可用的 QP 求解器。我们假设将矩阵 <spanclass="math inline">\(\textbf{A}\)</span> 和向量 <spanclass="math inline">\(b_i\)</span> 们传递给 QP 求解器，然后就能得到<span class="math inline">\(f_i\)</span> 们的向量。我们假设</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qp_solve</span><span class="hljs-params">(bigmatrix &amp;a, vector &amp;b, vector &amp;f)</span></span>;<br></code></pre></td></tr></table></figure><p>来看看如何计算所有的静接触力。下面代码大概在<code>find_collisions</code> 之后，由<code>Compute_Force_and_Torque</code> 调用。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compute_contact_forces</span><span class="hljs-params">(Contact contacts[], <span class="hljs-type">int</span> ncontacts, <span class="hljs-type">double</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    假设 contacts[] 内每个元素都代表静接触中的一个接触(contact)。</span><br><span class="hljs-comment">    此外，对于 Bodies[] 的每个元素，&#x27;force&#x27;,&#x27;torque&#x27;字段，</span><br><span class="hljs-comment">    都被设置为作用于在该物体上的力(force)和扭矩(torque),因为重力、风等，可能通过调用Compute_External_Force_and_Torque_for_all_Bodies(t);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    申请 nxn 矩阵`amat`, n维向量`fvec`、`bvec`</span><br><span class="hljs-comment">    */</span><br>    bigmatrix amat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bigmatrix</span>(ncontacts, ncontacts);<br>    vector bvec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>(ncontacts),<br>   fvec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>(ncontacts);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    计算 a_ij,b_i 系数</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">compute_a_matrix</span>(contacts, ncontacts, amat);<br><span class="hljs-built_in">compute_b_vector</span>(contacts, ncontacts, bvec);<br>    <br>    <span class="hljs-comment">// 解 f_i</span><br>    <span class="hljs-built_in">qp_solve</span>(amat, bmat, fvec);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    现在将刚刚计算的静接触力添加到每个刚体的 &#x27;force&#x27;,&#x27;torque&#x27;字段内</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ncontacts; i++)<br>    &#123;<br>        <span class="hljs-type">double</span> f = fvec[i]; <span class="hljs-comment">/* fi */</span><br>        triple n = contacts[i]-&gt;n; <span class="hljs-comment">/* nˆi(t0) */</span><br>        RigidBody *A = contacts[i]-&gt;a, <span class="hljs-comment">/* body A */</span><br>        *B = contacts[i]-&gt;b; <span class="hljs-comment">/* body B */</span><br>        <span class="hljs-comment">/* apply the force `f n&#x27; positively to A... */</span><br>        A-&gt;force += f * n;<br>        A-&gt;torque += (contacts[i].p - A-&gt;x) * (f*n);<br>        <span class="hljs-comment">/* and negatively to B */</span><br>        B-&gt;force -= f * n;<br>        B-&gt;torque -= (contacts[i].p - B-&gt;x) * (f*n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>差不多就是这样了！现在静息力已经计算出来，并与外力结合在一起，我们将控制权交还给ODE求解器，每个物体都以物理正确的方式愉快地沿着自己的道路前进，没有相互渗透。</p><h3 id="references">References</h3><a href="https://www.cs.cmu.edu/~baraff/sigcourse/index.html">PhysicallyBased Modeling</a><br /><a href="https://www.cs.cmu.edu/~baraff/sigcourse/notesd2.pdf">RigidBody Simulation Ⅱ</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>D. Baraff. Analyticalmethods for dynamic simulation of non-penetrating rigid bodies. InComputer Graphics (Proc. SIGGRAPH), volume 23, pages 223–232. ACM, July1989.] <a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>D. Baraff. Curved surfacesand coherence for non-penetrating rigid body simulation. In ComputerGraphics (Proc. SIGGRAPH), volume 24, pages 19–28. ACM, August 1990.<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>D. Baraff. Fast contactforce computation for nonpenetrating rigid bodies. Computer Graphics(Proc. SIGGRAPH), 28:23–34, 1994.<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>J. Canny. Collisiondetection for moving polyhedra. IEEE Transactions on Pattern Analysisand Machine Intelligence, 8(2), 1986.<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>P.A. Cundall. Formulation ofa three-dimensional distinct element model—Part I. A scheme to representcontacts in a system composed of many polyhedral blocks. InternationalJournal of Rock Mechanics, Mineral Science and Geomechanics, 25, 1988.<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>E.G. Gilbert and S.M. Hong.A new algorithm for detecting the collision of moving objects. InInternational Conference on Robotics and Automation, pages 8–13. IEEE,1989. <a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>P. Gill, S. Hammarling, W.Murray, M. Saunders, and M. Wright. User’s guide for LSSOL: A Fortranpackage for constrained linear least-squares and convex quadraticprogramming. Technical Report Sol 86-1, Systems Optimization Laboratory,Department of Operations Research, Stanford University, 1986.<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>P. Gill, W. Murray, M.Saunders, and M. Wright. User’s guide for QPSOL: A Fortran package forquadratic programming. Technical Report Sol 84-6, Systems OptimizationLaboratory, Department of Operations Research, Stanford University,1984. <a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>P. Gill, W. Murray, M.Saunders, and M. Wright. User’s guide for NPSOL: A Fortran package fornonlinear programming. Technical Report Sol 86-2, Systems OptimizationLaboratory, Department of Operations Research, Stanford University,1986. <a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>H. Goldstein. ClassicalMechanics. Addison-Wesley, Reading, 1983.<a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>W. Meyer. Distance betweenboxes: Applications to collision detection and clipping. InInternational Conference on Robotics and Automation, pages 597–602.IEEE, 1986. <a href="#fnref:11" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:12" class="footnote-text"><span>P.M. Moore and J. Wilhelms.Collision detection and reponse for computer animation. In ComputerGraphics (Proc. SIGGRAPH), volume 22, pages 289–298. ACM, August 1988.<a href="#fnref:12" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:13" class="footnote-text"><span>F.P. Preparata and M.I.Shamos. Computational Geometry. Springer-Verlag, New York, 1985.<a href="#fnref:13" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:14" class="footnote-text"><span>W.H. Press, B.P. Flannery,S.A. Teukolsky, and W.T. Vetterling. Numerical Recipes. CambridgeUniversity Press, 1986.<a href="#fnref:14" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:15" class="footnote-text"><span>R. Sedgewick. Algorithms.Addison-Wesley, 1983.<a href="#fnref:15" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:16" class="footnote-text"><span>K. Shoemake. Animatingrotation with quaternion curves. In Computer Graphics (Proc. SIGGRAPH),volume 19, pages 245–254. ACM, July 1985.<a href="#fnref:16" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:17" class="footnote-text"><span>B. Von Herzen, A. Barr, andH. Zatz. Geometric collisions for time-dependent parametric surfaces. InComputer Graphics (Proc. SIGGRAPH), volume 24, pages 39–48. ACM, August1990 <a href="#fnref:17" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:18" class="footnote-text"><span>不会翻译 - if not maximal<a href="#fnref:18" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何为犬儒主义</title>
    <link href="/2025/08/17/Dog%20Philosophers/"/>
    <url>/2025/08/17/Dog%20Philosophers/</url>
    
    <content type="html"><![CDATA[<p>“我希望你闪到一边，不要挡住我的阳光。”</p><p>“我若不是亚历山大，我愿是第欧根尼。”<br /><span id="more"></span></p><h1 id="何为犬儒主义">何为犬儒主义</h1><h2 id="安提斯泰尼第欧根尼犬儒主义">安提斯泰尼、第欧根尼、犬儒主义</h2><p>安提斯泰尼 其实是犬儒主义的开山鼻祖，是苏格拉底的学生。<br />第欧根尼在旅行中遇到了安提斯泰尼，想拜他为师，但是安提斯泰尼不喜欢他，因为第欧根尼曾涂改货币导致第欧根尼的父亲入狱。<br />但是第欧根尼的倔强打动了他，安提斯泰尼提出了犬儒主义，第欧根尼则是有名的践行者。</p><blockquote><p>人的苦痛有两种，一种源于物质，一种源于精神。精神上的幸福快乐才是真正的快乐满足，人当摆脱世俗的利益去追求唯一值得拥有的善。</p><p>犬儒主义</p></blockquote><h3 id="第欧根尼">第欧根尼</h3><p>在公元前4世纪，一位银行家的儿子通过伪造硬币使锡诺佩市陷入丑闻。当尘埃落定之后，这位名叫第欧根尼的年轻人被剥夺了国籍，钱和所有财产。<br />至少，故事就是这样发展的。尽管戴第欧根尼的许多细节鲜为人知，但因他的耻辱而产生的哲学思想在今天仍然存在。<br />在流放中，第欧根尼（Diogenes）相信通过拒绝他人的意见和社会衡量成功的标准，他可以真正获得自由。他将过着自给自足的生活，亲近大自然，不主张物质主义，没有虚荣心或顺从性。<br />在实践中，这意味着他在希腊的城市中流浪了很多年，除了斗篷，拐杖和面包袋外什么都没有，一年四季都在外，不使用技术，不洗澡也不吃熟食。他并没有悄悄地追求这种新的存在方式，据说他取笑路人，并在公共场合通过模仿那些有权势的人吃饭，小便，甚至自慰来嘲笑他们。<br />市民称他为kyôn——一种狂吠的狗。虽然是一种侮辱，但实际上狗是他哲学的一个很好的象征——它们是快乐的动物，不被财富或声誉之类的抽象概念束缚。<br />第欧根尼和他越来越多的追随者被称为“狗哲学家”或“kynikoi”，这一称号最终成为“犬儒主义”一词。这些早期的犬儒主义者无拘无束，被流浪的生活方式所吸引。<br />随着戴奥真尼斯声誉的提高，其他人试图挑战他的信仰。亚历山大大帝向他提供了他想要的任何东西。<br />但是，第欧根尼（Diogenes）并没有要求任何物资，而是要求亚历山大闪到一边去，不要遮住他的阳光。第欧根尼死后，在接下来的900年，坚持他的哲学的人继续称自己为犬儒主义者，直到500CE。<br />一些希腊哲学家，例如斯多葛派（Stoics），认为每个人都应该效法第欧根尼。他们还试图柔和他的哲学，使其更能被传统社会接受，这当然与他的作法根本背道而驰。<br />其他人则不那么乐于接受犬儒主义者。讽刺作家卢西安（Lucian）在公元2世纪在罗马的叙利亚省中，将自己时代的犬儒主义者描述为无原则，唯物主义，自我推广的伪君子，他们只宣讲了第欧根尼曾经真正实践过的东西。<br />几个世纪后，文艺复兴与宗教改革派作家阅读卢西安的著作，称他们的竞争对手为犬儒主义作为侮辱，指那些用毫无价值的话来批评别人的人。这种用法最终为“cynic”一词的现代含义打下了基础：一个人认为其他人都是出于纯粹的个人利益行事，即使他们声称有更高尚的动机。<br />然而，犬儒主义的哲学仍然令人钦佩，尤其是那些希望质疑社会状况的人。18世纪的法国哲学家让·雅克·卢梭（Jean-JacquesRousseau）称艺术，科学和技术使人们腐败，因此被称为“新的第欧根尼”。<br />1882年，尼采（FriedrichNietzsche）重现了一个故事，第欧根尼（Diogenes）带着灯笼进入雅典市场，徒劳地寻找一个诚实的人。在尼采的版本中，一个所谓的疯子冲进了一个城市广场，宣称“上帝已经死了”。<br />这是尼采呼吁“价值重估”的方式，他反对基督教和柏拉图关于超越物质世界的普世的，关于精神见解的主导思想。尼采赞扬第欧根尼坚决坚持活在当下。<br />最近，人们将1960年代的嬉皮士与第欧根尼（Diogenes）作为反正统文化者进行了比较。第欧根尼的思想被一遍又一遍地重新构想。<br />最初的犬儒主义者可能不赞成这些新观点：他们认为反对惯例和亲近自然的价值观是唯一的真价值观。无论您是否同意这一点，或以后的任何化身，它们都具有共同点：他们质疑现状。<br />这是我们仍然可以遵循的一个例子：不要盲目地遵循传统或多数人的观点，而要认真思考哪些东西真的有价值。批判性地思考我们的机构和生活方式比以往任何时候都重要。<br />用这些视频的观点来阐释你新发现的怀疑主义。</p><blockquote><p>In the 4th century BCE, a banker's son threw the city of Sinope intoscandal by counterfeiting coins. When the dust finally settled, theyoung man, Diogenes of Sinope, had been stripped of his citizenship, hismoney, and all his possessions.<br />At least, that's how the story goes. While many of the details ofDiogenes' life are shadowy, the philosophical ideas born out of hisdisgrace survive today.<br />In exile, Diogenes decided that by rejecting the opinions of others andsocietal measures of success, he could be truly free. He would liveself-sufficiently, close to nature, without materialism, vanity, orconformity.<br />In practice, this meant he spent years wandering around Greek citieswith nothing but a cloak, staff, and knapsack— outdoors year-round,forgoing technology, baths, and cooked food. He didn't go about this newexistence quietly, but is said to have teased passers-by and mocked thepowerful, eating, urinating and even masturbating in public.<br />The citizens called him a <em>kyôn</em>— a barking dog. Though meant asan insult, dogs were actually a good symbol for his philosophy — they'rehappy creatures, free from abstractions like wealth or reputation.<br />Diogenes and his growing number of followers became known as "dogphilosophers," or <em>kynikoi</em>, a designation that eventually becamethe word "Cynic." These early Cynics were a carefree bunch, drawn to thefreedom of a wandering lifestyle.<br />As Diogenes' reputation grew, others tried to challenge his commitment.Alexander the Great offered him anything he desired. But instead ofasking for material goods, Diogenes only asked Alexander to get out ofhis sunshine. After Diogenes' death, adherents to his philosophycontinued to call themselves Cynics for about 900 years, until 500CE.<br />Some Greek philosophers, like the Stoics, thought everyone should followDiogenes' example. They also attempted to tone down his philosophy to bemore acceptable to conventional society — which, of course, wasfundamentally at odds with his approach.<br />Others viewed the Cynics less charitably. In the Roman province of Syriain the 2nd century CE, the satirist Lucian described the Cynics of hisown time as unprincipled, materialistic, self-promoting hypocrites, whoonly preached what Diogenes had once actually practiced.<br />Reading Lucian's texts centuries later, Renaissance and Reformationwriters called their rivals <em>cynics</em> as an insult — meaningpeople who criticized others without having anything worthwhile to say.This usage eventually laid the groundwork for the modern meaning of theword "cynic": a person who thinks everyone else is acting out of pureself-interest, even if they claim a higher motive.<br />Still, the philosophy of cynicism had admirers, especially among thosewho wished to question the state of society. The 18th-century Frenchphilosopher Jean-Jacques Rousseau was called the "new Diogenes" when heargued that the arts, sciences, and technology, corrupt people.<br />In 1882, Friedrich Nietzsche reimagined a story in which Diogenes wentinto the Athenian marketplace with a lantern, searching in vain for asingle honest person. In Nietzsche's version, a so-called madman rushesinto a town square to proclaim that "God is dead." This was Nietzsche'sway of calling for a "revaluation of values," and rejecting the dominantChristian and Platonic idea of universal, spiritual insights beyond thephysical world. Nietzsche admired Diogenes for sticking stubbornly tothe here-and-now.<br />More recently, the hippies of the 1960s have been compared with Diogenesas counter-cultural rebels. Diogenes' ideas have been adopted andreimagined over and over again.<br />The original cynics might not have approved of these fresh takes: theybelieved that their values of rejecting custom and living closely withnature were the only true values. Whether or not you agree with that, orwith any of the later incarnations, all have one thing in common: theyquestioned the status quo.<br />And that's an example we can still follow: not to blindly followconventional or majority views, but to think hard about what is trulyvaluable. Thinking critically about our institutions and way of life ismore important than ever.<br />Hone your new-found skepticism with these videos.</p></blockquote><h2 id="reference">Reference</h2><p><ahref="https://www.bilibili.com/video/BV1T7411b76u">【Ted-ED】犬儒主义的哲学The Philosophy Of Cynicism</a><br /><ahref="https://www.bilibili.com/video/BV1du4y1L7z2">什么是犬儒主义？</a><br /><ahref="https://www.bilibili.com/video/BV11r4y1J7Jk">对犬儒主义的灵魂拷问</a><br /><ahref="https://www.bilibili.com/video/BV1PU4y1Q7pi">齐泽克为什么是错的？或犬儒为什么是一个糟糕的概念，和大露恶的赛博空间。</a><br /><a href="https://www.zhihu.com/question/48307164">到底什么是犬儒主义？ -知乎</a><br /><ahref="https://zhuanlan.zhihu.com/p/421933857">犬儒主义者：“像狗一样活着”- 知乎</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>犬儒主义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Note 1</title>
    <link href="/2025/08/16/C++Note_1/"/>
    <url>/2025/08/16/C++Note_1/</url>
    
    <content type="html"><![CDATA[<h1 id="c-note-1">C++ Note 1</h1><p>重新学C++了家人们，自从2023年毕业之后就碰了三个月cpp，后面去做技术美术写了一年的Shader和C#URP，Render Pipeline，但是 C++ 是我的心病，就得学C++，卧槽，拦不住的。</p><h2 id="什么是面向对象">什么是面向对象？</h2><p>面向对象是相对面对过程而言，通过类和对象的设计，封装、继承、多态的特性进行开发。<br />即以对象为核心，通过对象封装<strong>数据</strong>和<strong>行为(函数)</strong>。<br />其中核心特性：封装、继承、多态。</p><h3 id="封装">封装：</h3><p>将<strong>数据</strong>和<strong>函数</strong>封存在类内，<strong>隐藏内部细节</strong>，只暴露出必要的部分，<br />尽量避免外部的直接修改。<br />通过public 方法尽量做到安全访问。<br />所有类的设计都应该是一个封装的过程。</p><h3 id="继承">继承:</h3><p>子类能够复用父类方法，实现代码复用。<br />继承的情况：</p><ul><li><p>单一继承：子类只有一个父类</p></li><li><p>多个继承：子类多个父类，如果父类有相同的成员，需要在子类中使用类名限定。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        age = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">B</span>()<br>    &#123;<br>        age = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-keyword">public</span> :<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">C</span>()<br>    &#123;<br>        age = <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;;<br><br>C c = <span class="hljs-built_in">C</span>();<br><span class="hljs-comment">// c.age 3</span><br><span class="hljs-comment">// c.B::age 2</span><br><span class="hljs-comment">// c.A::age 1</span><br></code></pre></td></tr></table></figure></p></li><li><p>菱形继承：1-n-1 的继承方式，通过使用虚函数进行虚继承来解决<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// ERROR</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandFather</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-built_in">GrandFather</span>()&#123; age = <span class="hljs-number">100</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father1</span> : <span class="hljs-keyword">public</span> GrandFather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father2</span> : <span class="hljs-keyword">public</span> GrandFather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father1, <span class="hljs-keyword">public</span> Father2&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son p;<br>    p.age = <span class="hljs-number">12</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这个例子会报错，因为编译器不知道age是哪个作用域下的age，不知道是Father1还是Father2的，我们可以指定作用域。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class="hljs-number">12</span>;<br>    p.Father2::age = <span class="hljs-number">23</span>;<br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;<br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>但是这种解决办法缺少实际意义，我们往往需要的是son只有一个age属性即可。使用<code>virtual</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandFather</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-built_in">GrandFather</span>()&#123; age = <span class="hljs-number">100</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> GrandFather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> GrandFather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father1, <span class="hljs-keyword">public</span> Father2&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class="hljs-number">12</span>;<br>    p.Father2::age = <span class="hljs-number">22</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;                <span class="hljs-comment">// 22</span><br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;        <span class="hljs-comment">// 22</span><br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;        <span class="hljs-comment">// 22</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果会是三个<code>22</code>，因为son中只有一个age了。 <ahref="https://zhuanlan.zhihu.com/p/395173418">l菱形继承</a><br />通过在子类中vbptr指向<strong>虚基类表</strong>，通过读取<strong>虚基类表存储的偏移量，计算目标地址</strong>。<br /><img src="/imgs/C++/虚继承.jpg" /><br />虚基类表存储了内存偏移，使得有菱形继承的子类能够将爷爷的成员存储的相同地址。</p></li></ul><h3 id="多态">多态</h3><p>多态的核心思想就是为不同数据类型的实体提供统一的接口，<br />使得统一操作在面对不同类型的对象时采取不同的行为。<br />比如两个继承同一父类的子类对象，对父类的虚函数的可能有不同的实现方案。<br />C++ 中多态分为静态多态和动态多态。</p><h4 id="静态多态">静态多态</h4><p>通过<strong>函数重载、运算符重载、模板</strong>实现，可以在编译阶段确定函数调用。</p><h4 id="动态多态">动态多态</h4><p>通过<strong>虚函数、继承、基类指针、引用</strong>实现，在运行过程中动态绑定函数调用</p><h2 id="虚函数">虚函数</h2><p>在基类中能够使用 <code>virtual</code>修饰成员函数，允许子类重写该函数改变函数行为。</p><p>在深入虚函数之前需要对 C++ 的 <a href="#内存布局">内存布局</a>有一定的了解。</p><h2 id="内存布局">内存布局</h2><p><em>代码段、数据段、BSS 段(Block Started bySymbol)、Heap、Stack</em></p><h3 id="代码段">代码段</h3><ul><li>存储程序编译后的机器指令（函数体二进制代码）</li><li>特性：只读，防止指令被意外修改</li></ul><h3 id="数据段">数据段</h3><ul><li>存储<strong>已初始化的全局变量、静态变量、常量字符串</strong></li></ul><h3 id="bss-段block-started-by-symbol">BSS 段(Block Started bySymbol)</h3><ul><li><p><strong>未初始化的全局变量、静态变量（C++ 中默认初始化为0）</strong></p></li><li><p>不占用空间，程序加载到内存后，由操作系统自动初始化为0（清零）</p></li></ul><h3 id="heap">Heap</h3><ul><li>动态内存分配区域，通过 <code>new/malloc</code> 管理</li></ul><h3 id="stack">Stack</h3><ul><li>自动管理临时数据的区域，由编译器控制</li><li>特性<ul><li>地址<strong>从高到低增长</strong></li><li>存储<strong>局部变量、函数参数、返回地址、临时对象</strong></li><li>每个函数调用创建独立的<strong>栈帧（Stack Frame）</strong></li><li>栈溢出（Stack Overflow）风险（如递归过深）</li></ul></li></ul><h3 id="关于对象的内存布局">关于对象的内存布局</h3><p>一不包含静态函数，只有普通成员函数的类：<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun_a</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun_b</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure></p><pre><code class=" mermaid">graph LRA[方形] --&gt;B[&quot;fun_a()fun_b()&quot;]C[堆] --&gt; D[a:int]</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rigid Body Simulation Ⅰ</title>
    <link href="/2025/08/11/Rigid%20Body%20Simulation%20%E2%85%A0/"/>
    <url>/2025/08/11/Rigid%20Body%20Simulation%20%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<p>刚体模拟内容Ⅰ <span id="more"></span></p><h1 id="rigid-body-simulation-ⅰ">Rigid Body Simulation Ⅰ</h1><h2 id="part-i.-unconstrained-rigid-body-dynamics">Part I. UnconstrainedRigid Body Dynamics</h2><h3 id="simulation-basics">1. Simulation Basics</h3><p>模拟刚体的运动与模拟单个粒子的运动几乎是一样的，所以让我们先从粒子模拟开始。我们模拟一个粒子的方法如下。我们用函数<span class="math inline">\(x(t)\)</span> 来表示在时间 <spanclass="math inline">\(t\)</span>时该粒子在世界空间（即在模拟过程中所有粒子或物体所在空间）中的位置。函数<span class="math inline">\(v(t) = \dot{x}(t) =\frac{\mathrm{d}}{\mathrm{d}t}x(t)\)</span> 表示该粒子在时间 <spanclass="math inline">\(t\)</span> 时的速度。粒子在时间 <spanclass="math inline">\(t\)</span>的状态就是其位置和速度。我们通过定义一个状态向量 <spanclass="math inline">\(\textbf{Y}(t)\)</span>来对整个系统进行这一概念的推广：对于单个粒子，<br /><span class="math display">\[\textbf{Y}(t)=\begin{pmatrix}x(t)\\v(t)\end{pmatrix}\tag{1-1}\]</span> 当我们讨论实际的实现时，必须将 <spanclass="math inline">\(\textbf{Y}(t)\)</span>“展平”成一个数组。对于单个粒子， <spanclass="math inline">\(\textbf{Y}(t)\)</span>可以描述为一组六个数字：通常，我们会让数组的前三个元素代表 <spanclass="math inline">\(x(t)\)</span>，最后三个元素代表 <spanclass="math inline">\(v(t)\)</span>。之后，当我们谈论包含矩阵以及向量的状态向量<span class="math inline">\(Y(t)\)</span> 时，也会采用同样的操作将 <spanclass="math inline">\(Y(t)\)</span>展平成一个数组。当然，我们还得反过来进行这个过程，将一组数字转换回状态向量<spanclass="math inline">\(Y(t)\)</span>。总的来说，这都是相当简单的，所以，我们将假定我们知道如何将任何类型的状态向量<span class="math inline">\(Y(t)\)</span>转换为一个适当长度的数组，反之亦然。（对于涉及粒子的简单示例，请查看这些笔记中的“粒子系统动力学”部分。）<br />对于一个有着 n 粒子的系统，我们将 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 拓展为：<br /><span class="math display">\[\textbf{Y}(t)=\begin{pmatrix}x_1(t)\\v_1(t)\\\vdots\\x_n(t)\\v_n(t)\end{pmatrix}\tag{1-2}\]</span> <span class="math inline">\(x_i(t),v_i(t)\)</span> 是第 i个粒子的位置和速度。处理 n个粒子与处理单个粒子的难度是一样的，所以目前我们暂且将 Y(t)设为单个粒子的状态向量（稍后当我们讨论单个刚体时，它将代表单个刚体的状态）。<br />要真正模拟我们的粒子的运动，我们还需要知道另外一件事——在时刻 <spanclass="math inline">\(t\)</span>时作用在该粒子上的力。我们将把作用在粒子上的力在时刻 <spanclass="math inline">\(t\)</span> 时的大小定义为 <spanclass="math inline">\(F(t)\)</span>。函数 <spanclass="math inline">\(F(t)\)</span>就是作用在该粒子上的所有力的总和：重力、风力、弹簧力等等。若该粒子的质量为<span class="math inline">\(m\)</span> ，那么其随时间变化的 <spanclass="math inline">\(\textbf{Y}\)</span> 值可由以下公式表示：<br /><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)=\frac{\mathrm{d}}{\mathrm{d}t}\begin{pmatrix}x(t)\\v(t)\end{pmatrix}=\begin{pmatrix}v(t)\\F(t)/m\end{pmatrix}.\tag{1-3}\]</span> 给定任意时刻 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 值，等式 1-3 描述了 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 的瞬时变化率。模拟过程以<span class="math inline">\(Y(0)\)</span> 为初始条件 (即<spanclass="math inline">\(x(0),v(0)\)</span>) 并通过数值微分方程求解器跟踪<span class="math inline">\(\textbf{Y}\)</span> 随着时间流动。<br />求解器使用何种数值方法其实我们不关心，让我们看一下在 C++如何实现数组求解器，假设我们访问一个数值求解器，通常该 ODE函数应该是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*dydt_func)</span><span class="hljs-params">(<span class="hljs-type">double</span> t[], <span class="hljs-type">double</span> t[], <span class="hljs-type">double</span> ydot[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ode</span><span class="hljs-params">(<span class="hljs-type">double</span> y0[], <span class="hljs-type">double</span> yend[], <span class="hljs-type">int</span> len, <span class="hljs-type">double</span> t0,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">double</span> t1, dydt_func dydt)</span></span>;<br></code></pre></td></tr></table></figure><p>我们将初始状态向量数组 y0 传到 ode 函数。求解器对 y的内部并不关心，由于求解器可以解决任意维度的问题，我们还必须传 y0 的长度len。对于一个有 n 个粒子的系统，len = 6n。此外要提供开始和结束时间 t0,t1求解器的目标是计算 t1 时刻的状态向量并返回到 yend 中。<br />我们也提供了函数 dydt 给 ode 函数。状态向量 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 和 时间 <spanclass="math inline">\(t\)</span> 编码成一个数组 y，dydt 必须计算并返回<spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span>于数组 ydot。必须把 t 传递给 dydt 是因为系统中可能会有随时间变化的力，这种情况下，dydt 必须知道 时间 来确定力。在跟踪从 t0 到t1 <span class="math inline">\(\textbf{Y}(t)\)</span>的变化中，求解器可以随时调用 dydt。假设我们有一个 ode的例子，我们需要做的就是编写 dydt 将它作为参数传给 ode。<br />模拟刚体与模拟粒子遵循完全相同的模式。唯一的区别是刚体的状态向量 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 包含了更多的信息，而导数<spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span>则稍微复杂一些。然而，我们将使用完全相同的范例，使用求解器ode来跟踪刚体的运动，同样我们将提供一个函数dydt。</p><h3 id="rigid-body-concepts">2. Rigid Body Concepts</h3><h4 id="position-and-orientation">2.1 Position and Orientation</h4><p>粒子在 <span class="math inline">\(t\)</span>时刻在空间中的位置可以被描述为向量 <spanclass="math inline">\(x(t)\)</span>，表示距离原点的位移。刚体比粒子复杂，在位移的基础上要添加旋转。为了定位一个在世界坐标中的刚体，我们用向量<span class="math inline">\(x(t)\)</span>表示刚体的位移，同时必须描述刚体的旋转，暂时用一个 3x3 的旋转矩阵 <spanclass="math inline">\(R(t)\)</span> 表示，<spanclass="math inline">\(x(t),R(t)\)</span> 为一个刚体的控件变量。<br />刚体和粒子不同，其占据一定的空间具有一定的形状。因为刚体不会形变只会位移和旋转，所以我们用一个固定的大小不会变化的空间定义刚体的形状，称之为<strong>体空间</strong>。给定体空间的几何描述，然后用 <spanclass="math inline">\(x(t),R(t)\)</span>变换体空间的描述至世界空间(figure1)。为了简化使用的一些方程、等式，我们规定刚体在体空间的质心为原点 (0,0,0)。后面会更准确地定义质心，这里可以先认为物体的几何中心就是质心。在描述物体形状时，需要保证物体的几何中心位于物体空间的 (0, 0, 0)。我们定义 <span class="math inline">\(R(t)\)</span>表示物体绕质心的旋转，一个在 物体空间 固定的向量 <spanclass="math inline">\(r\)</span> 在时刻 <spanclass="math inline">\(t\)</span> 将被旋转至 <spanclass="math inline">\(R(t)r\)</span>。则刚体上任意一点在物体空间的 <spanclass="math inline">\(p_0\)</span> 先绕原点旋转后位移的结果是 <spanclass="math inline">\(p(t)\)</span>：<br /><span class="math display">\[p(t)=R(t)p_0+x(t)\tag{2-1}\]</span> <imgsrc="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure1.png" /><br />由于质心位于原点，所以我们可以从 <spanclass="math inline">\(x(t)\)</span> 直接获得质心的世界坐标，所以 <spanclass="math inline">\(x(t)\)</span> 是时刻 <spanclass="math inline">\(t\)</span>质心的位置。对于旋转矩阵也有类似的物理意义，想象 物体空间的 x 轴，(1, 0,0) ，在时间 <span class="math inline">\(t\)</span>有世界空间向量：<br /><span class="math display">\[R(t)\begin{pmatrix}1\\0\\0\\\end{pmatrix}\\\]</span> <span class="math display">\[R(t)=\begin{pmatrix}r_{xx}\;r_{yx}\;r_{zx}\\r_{xy}\;r_{yy}\;r_{zy}\\r_{xz}\;r_{yz}\;r_{zz}\end{pmatrix},\tag{2-2}\]</span></p><p><span class="math display">\[\begin{aligned}R(t)\begin{pmatrix}1\\0\\0\\\end{pmatrix}=\begin{pmatrix}r_{xx}\\r_{xy}\\r_{xz}\\\end{pmatrix}\end{aligned}\tag{2-3}\]</span></p><p>可以看到就是第一列，<span class="math inline">\(R(t)\)</span>的物理意义即(1, 2, 3)列 为 刚体(x, y, z) 轴在时间 <spanclass="math inline">\(t\)</span> 变换到世界空间时所指示方向。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure2.png" /></p><h4 id="linear-velocity">2.2 Linear Velocity</h4><p>为了简化，我们称 <span class="math inline">\(x(t),R(t)\)</span> 为位置 和 朝向。接下来要做的就是定义 位置 和 朝向 如何随时间变化。我们需要<span class="math inline">\(\dot{x}(t),\dot{R}(t)\)</span>。因为 <spanclass="math inline">\(x(t)\)</span> 是质心在世界空间的坐标，<spanclass="math inline">\(\dot{x}(t)\)</span> 即质心在世界空间的速度。</p><h4 id="angular-velocity">2.3 Angular Velocity</h4><p>除了为位移外，物体还可以旋转，我们先不考虑位移，将其固定。那么，物体空间各点的任何移动都必定是由于刚体绕着通过质心的某根轴旋转所致。定义该自旋为<span class="math inline">\(\omega(t)\)</span>，其方向决定了物体<strong>旋转轴</strong>的方向 (figure 3)。<spanclass="math inline">\(\omega(t)\)</span> 的大小 <spanclass="math inline">\(|\omega(t)|\)</span> 表示物体旋转的快慢。 <spanclass="math inline">\(|\omega(t)|\)</span> 的量纲是[转/单位时间],因此它关联了物体在<strong>角速度保持恒定</strong>的前提下，给定时间内将转过的角度，物理量<span class="math inline">\(\omega(t)\)</span> 称之为角速度。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure3.png" /><br />对于线速度我们可以对 <span class="math inline">\(x(t)\)</span>在时间上求导 <spanclass="math inline">\(v(t)=\frac{\mathrm{d}}{\mathrm{d}t}x(t)\)</span>。物体旋转<span class="math inline">\(R(t)\)</span> 如何与角速度 <spanclass="math inline">\(\omega(t)\)</span> 关联？尤其是 <spanclass="math inline">\(R(t)\)</span> 是矩阵 而 <spanclass="math inline">\(\omega(t)\)</span> 是向量。<br />我们知道 <span class="math inline">\(R(t)\)</span> 的列表示 物体 x,y,z轴在时刻 t 变换后的方向。这意味着 <span class="math inline">\(\dotR(t)\)</span> 的列一定分布表示 x,y,z 轴被变换的速度。为了解决 <spanclass="math inline">\(R(t)\)</span> 和 <spanclass="math inline">\(\omega(t)\)</span>的关联，需要观测刚体中任意矢量变化和角速度 <spanclass="math inline">\(\omega(t)\)</span> 的关系。<br />Figure 4 展示了角速度为 <span class="math inline">\(\omega(t)\)</span>的刚体，思考在世界空间中指定时刻 <span class="math inline">\(t\)</span>的向量 <spanclass="math inline">\(r(t)\)</span>。假设该向量固定在刚体上，即 <spanclass="math inline">\(r(t)\)</span> 会随着刚体在世界空间在运动。由于<span class="math inline">\(r(t)\)</span>是一个方向向量，是不受平移影响的也就是说 <spanclass="math inline">\(\dot r(t)\)</span> 和 <spanclass="math inline">\(v(t)\)</span> 无关。为了研究 <spanclass="math inline">\(\dot r(t)\)</span>，将其分解为向量a, b，其中 a平行于 <span class="math inline">\(\omega(t)\)</span> ，b 垂直于 <spanclass="math inline">\(\omega(t)\)</span> 。假设刚体保持恒定的角速度，使<span class="math inline">\(r(t)\)</span> 的尖端绕 <spanclass="math inline">\(\omega (t)\)</span> 轴画了一个圆(figure4)。圆的半径即为 <span class="math inline">\(|b|\)</span>，因为向量<span class="math inline">\(r(t)\)</span> 的尖端是瞬时沿着圆运动的，所以<span class="math inline">\(r(t)\)</span> 的瞬时变化率即 <spanclass="math inline">\(\dot{r}(t)\)</span> 是同时垂直于 <spanclass="math inline">\(b,\omega(t)\)</span>。又因为 <spanclass="math inline">\(r(t)\)</span> 端点做绕半径 <spanclass="math inline">\(b\)</span> 的圆周运动，<spanclass="math inline">\(r(t)\)</span> 的瞬时速度大小为 <spanclass="math inline">\(|b|\cdot|\omega(t)|\)</span>，由于 <spanclass="math inline">\(b,\omega(t)\)</span> 垂直则有<br /><span class="math display">\[|\omega(t)\times b|=|\omega(t)|\cdot|b|\tag{2-5}\]</span> <imgsrc="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure4.png" /><br />整理后我们能得到 <spanclass="math inline">\(\dot{r}(t)=\omega(t)\times(b)\)</span>。因为 <spanclass="math inline">\(r(t)=a+b\)</span> 但是 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(\omega(t)\)</span> 垂直<br /><span class="math display">\[\dot r(t)=\omega(t)\times b=\omega(t)\times b+\omega(t)\timesa=\omega(t)\times (b+a)\tag{2-6}\]</span></p><p><span class="math display">\[\dot r(t)=\omega(t)\times r(t)\tag{2-7}\]</span></p><p>我们知道时刻 <span class="math inline">\(t\)</span> 刚体在世界空间的x 轴是 旋转矩阵的第一列，其导数就是该向量的变化率，利用刚才的式子：<span class="math display">\[\omega(t)\times\begin{pmatrix}r_{xx}\\r_{xy}\\r_{xz}\end{pmatrix}\]</span> 对于其他轴向也有： <span class="math display">\[\begin{aligned}\dot R=\begin{pmatrix}\omega(t)\times\begin{pmatrix}r_{xx}\\r_{xy}\\r_{xz}\end{pmatrix},\omega(t)\times\begin{pmatrix}r_{yx}\\r_{yy}\\r_{yz}\end{pmatrix},\omega(t)\times\begin{pmatrix}r_{zx}\\r_{zy}\\r_{zz}\end{pmatrix}\end{pmatrix}\end{aligned}\tag{2-8}\]</span></p><p>这样写很麻烦，我们可以简化，因 a，b 都是三维向量，则 <spanclass="math inline">\(a\times b\)</span> 亦是：</p><p><span class="math display">\[a\times b=\begin{pmatrix}a_yb_z-b_ya_z\\a_zb_x-b_za_x\\a_xb_y-b_xa_y\end{pmatrix}\]</span> 我们定义一个矩阵 <span class="math inline">\(a^*\)</span>:<span class="math display">\[{a^*=\begin{pmatrix}&amp;0 &amp;-a_z &amp;a_y\\&amp;a_z &amp;0 &amp;-a_x\\&amp;0 &amp;-a_z &amp;a_y\end{pmatrix}}\]</span></p><p><span class="math display">\[{a^*b=\begin{pmatrix}a_yb_z-b_ya_z\\a_zb_x-b_za_x\\a_xb_y-b_xa_y\end{pmatrix}=a\times b\tag{2-9}}\]</span></p><p><span class="math display">\[\dot{R}(t)=\begin{pmatrix}\omega(t)^*\begin{pmatrix}r_{xx}\\r_{xy}\\r_{xz}\end{pmatrix}&amp;\omega(t)^*\begin{pmatrix}r_{yx}\\r_{yy}\\r_{yz}\end{pmatrix}&amp;\omega(t)^*\begin{pmatrix}r_{zx}\\r_{zy}\\r_{zz}\end{pmatrix}\end{pmatrix}\tag{2-10}\]</span></p><p><span class="math display">\[\dot{R}(t)=\omega(t)^*\begin{pmatrix}\begin{pmatrix}r_{xx}\\r_{xy}\\r_{xz}\end{pmatrix}&amp;\begin{pmatrix}r_{yx}\\r_{yy}\\r_{yz}\end{pmatrix}&amp;\begin{pmatrix}r_{zx}\\r_{zy}\\r_{zz}\end{pmatrix}\end{pmatrix}\tag{2-11}\]</span></p><p><span class="math display">\[\dot{R}(t)=\omega(t)^*{R}(t)\tag{2-12}\]</span></p><h4 id="mass-of-a-body">2.4 Mass of a Body</h4><p>为了做一些推导，我们需要对刚体进行一些理论上的积分，我们暂时认为刚体是由很多微小粒子组成的，编号为1到 N，第 i 个粒子的质量为 <span class="math inline">\(m_i\)</span>每个粒子在空间中有起始位置 <span class="math inline">\(r_{0i}\)</span>。在 t 时刻：<br /><span class="math display">\[r_i(t)=R(t)r_{0i}+x(t)\tag{2-13}\]</span> 刚体的质量 <span class="math inline">\(M\)</span> 为：<br /><span class="math display">\[M=\sum^N_{i=1}m_i\tag{2-14}\]</span></p><h4 id="velocity-of-particle">2.5 Velocity of Particle</h4><p>第 i 个粒子的速度 <span class="math inline">\(\dot{r}_i(t)\)</span>是对 等式2-13 的求导，记得 <spanclass="math inline">\(\dot{R}(t)=\omega^*R(t)\)</span>：<br /><span class="math display">\[\dot{r}_i(t)=\omega^*R(t)r_{0i}+v(t)\tag{2-15}\]</span> 可以重写为：<br /><span class="math display">\[\begin{aligned}\dot{r}_i(t)&amp;=\omega^*R(t)r_{0i}+v(t)\\&amp;=\omega^*(R(t)r_{0i}+x(t)-x(t))+v(t)\\&amp;=\omega^*(r_i(t)-x(t))+v(t)\end{aligned}\tag{2-16}\]</span> 这里写成叉乘：<br /><span class="math display">\[\dot{r}_i(t)=\omega(t)\times(r_i(t)-x(t))+v(t)\tag{2-17}\]</span> 所以刚体上一点粒子的速度有两个分量，一个是线性分量 <spanclass="math inline">\(v(t)\)</span> 及一个角速度分量 <spanclass="math inline">\(\omega(t)\times(r_i(t)-x(t))\)</span><br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure5.png" /></p><h4 id="center-of-mass">2.6 Center of Mass</h4><p>我们对质心的定义将使我们能够同样，地将物体的动力学分解为 线性分量 和角分量。<br /><span class="math display">\[\frac{\sum m_ir_i(t)}{M}\tag{2-18}\]</span> 其中 <span class="math inline">\(M\)</span>是物体的质量，当我们说我们正在使用质心坐标系时，意思是在物体空间中，以质心为原点:<br /><span class="math display">\[\frac{\sum m_ir_{0i}}{M}=\textbf{0}=\begin{pmatrix}0\\0\\0\end{pmatrix}\tag{2-19}\]</span> 关于 <span class="math inline">\(x(t)\)</span> 是 <spanclass="math inline">\(t\)</span> 时刻的质心位置：<br /><span class="math display">\[\begin{aligned}\frac{\sum m_ir_i(t)}{M}&amp;=\frac{\sum m_i(R(t)r_{0i}+x(t))}{M}\\&amp;=\frac{R(t)\sum m_ir_{0i}+\sum m_ix(t)}{M}\\&amp;=R(t)\textbf{0}+x(t)\frac{\sum m_i}{M}\\&amp;=x(t)\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;\sum m_i(r_i(t)-x(t))=\\&amp;\sum m_i(R(t)r_{0i}+x(t)-x(t))=R(t)\sum m_ir_{0i}=\textbf{0}\end{aligned}\tag{2-20}\]</span></p><h4 id="force-and-torque">2.7 Force and Torque</h4><p>当我们想象由于外部因素导致一个力施加在刚体上，比如重力、风、或接触力，我们想象这个力恰巧作用在刚体一个特定的粒子上。作用力的作用位置决定了力所施加的位置。我们用<span class="math inline">\(F_i(t)\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻作用在第 i 个粒子上的力。定义第 i个粒子的外力矩为 <span class="math inline">\(\tau_i(t)\)</span><br /><em>(记住，我们的粒子模型只是概念性质的，我们可以在任何几何位置去想象一个力不论是物体表面上或者物体内部的，因为我们都可以随意想象那恰好有个粒子)</em><br /><span class="math display">\[\tau_i(t)=(r_i(t)-x(t))\times F_i(t)\tag{2-21}\]</span>扭矩与力不同在于，作用于粒子上的扭矩取决于粒子相对质心的位置，我们可以直观的发现<span class="math inline">\(\tau_i(t)\)</span>的方向就是当质心被固定时，由于 <spanclass="math inline">\(F_i(t)\)</span>作用，物体将会绕其旋转的轴。(figure 6)<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure6.png" /><br />作用在物体上的力为作用在粒子上的总和：<br /><span class="math display">\[F(t)=\sum F_i(t)\tag{2-22}\]</span> 外力矩：<br /><span class="math display">\[\tau(t)=\sum\tau_i(t)=\sum(r_i(t)-x(t))\times F_i(t)\tag{2-23}\]</span> 可以注意到 <span class="math inline">\(F(t)\)</span>没有包含作用于物体的各个力的位置信息。然而 <spanclass="math inline">\(\tau(t)\)</span> 的确能告知我们 <spanclass="math inline">\(F_i(t)\)</span> 在物体上的分布情况。</p><h4 id="linear-momentum">2.8 Linear Momentum</h4><p><span class="math display">\[p=mv\tag{2-24}\]</span></p><p><span class="math display">\[P(t)=\sum m_i\dot{r}(t)\tag{2-25}\]</span></p><p>根据等式 2-17，<spanclass="math inline">\(\dot{r}_i(t)=\omega(t)\times(r_i(t)-x(t))+v(t)\)</span>，因此物体的线性动量为：<br /><span class="math display">\[\begin{aligned}P(t)&amp;=\sum m_i\dot{r}_i(t)\\&amp;=\sum[m_iv(t)+m_i\omega(t)\times(r_i(t)-x(t))]\\&amp;=\sum m_iv(t)+\omega(t)\sum m_i(r_i(t)-x(t)).\end{aligned}\tag{2-26}\]</span> 因为我们以质心为原点所以能够应用 2-20，得<br /><span class="math display">\[P(t)=\sum m_iv(t)=v(t)\sum m_i=Mv(t)\tag{2-27}\]</span> 刚体的线性动量就像一个粒子的线性动量简单，所以我们能得到<br /><span class="math display">\[\dot{v}(t)=\frac{\dot{P}(t)}{M}\tag{2-28}\]</span> 我们知道 <spanclass="math inline">\(p=mv,\dot{p}=ma=f\)</span>，所以能够有<br /><span class="math display">\[\dot{P}(t)=F(t)\tag{2-29}\]</span> 就是说，线性动量的变换等于作用在刚体上的总力。<spanclass="math inline">\(P(t)\)</span> 不包含旋转速度，同样 <spanclass="math inline">\(F(t)\)</span> 也不包含。<br />由于 <span class="math inline">\(P(t)\)</span> 和 <spanclass="math inline">\(v(t)\)</span> 的关系简单，我们使用 <spanclass="math inline">\(P(t)\)</span> 来表示刚体的状态，而非 <spanclass="math inline">\(v(t)\)</span>。如果使用 <spanclass="math inline">\(v(t)\)</span> 可以使用下面的关系<br /><span class="math display">\[\dot v(t)=\frac{F(t)}{M}\tag{2-30}\]</span> 不过使用 <span class="math inline">\(P(t)\)</span>更符合我们处理角速度和加速度的形式。</p><h4 id="angular-momentum">2.9 Angular Momentum</h4><p>虽然线性动量非常直观 ( <spanclass="math inline">\(P(t)=Mv(t)\)</span>)，但角动量不是。在刚体中引入角动量唯一的好处就是能够写成比执着于角速度更简洁的等式。因此或许不必纠结给角动量附加直观的物理解释——毕竟，它本质上是<strong>极为反直觉</strong>的概念。角动量最终能简化方程，源于<strong>自然界中角动量守恒</strong>，而角速度不守恒：若刚体在无外力矩的太空漂浮，其角动量恒定；但即使刚体的角动量恒定，角速度也可能变化！正因如此，刚体的角速度<strong>即便不受力也可能改变</strong>。由此，“选择角动量作为状态变量”比角速度更合理——最终在数学处理上更简便。<br />从线性动量我们知道 <spanclass="math inline">\(P(t)=Mv(t)\)</span>，相似的我们定义刚体总角动量<span class="math inline">\(L(t)=I(t)\omega(t)\)</span>，其中 <spanclass="math inline">\(I(t)\)</span> 是一个 3x3的矩阵，严格而言是二阶张量，称之为<strong>惯性张量</strong>。惯性张量表述了刚体相对于其质心的质量分布，该张量决定物体的朝向，但是不依赖物体的平动。<br />要注意的是无论线性还是角度，动量都是一个速度的线性函数，区别仅在于角动量的“缩放因子” 是矩阵——惯性张量，而平动动量的 “缩放因子”是标量——质量。此外，角动量不受平动影响，平动动量也不受转动影响。<br />角动量 <span class="math inline">\(L(t)\)</span> 和 外力矩 <spanclass="math inline">\(\tau(t)\)</span> 的关系非常简单：<br /><span class="math display">\[\dot{L}(t)=\tau(t)\tag{2-31}\]</span> 类似 <span class="math inline">\(\dot{P}(t)=F(t)\)</span>.</p><h4 id="the-inertia-tensor">2.10 The Inertia Tensor</h4>惯性张量是角速度和角动量之间的缩放系数。在给定时刻 <spanclass="math inline">\(t\)</span> ，令 <spanclass="math inline">\(r_i&#39;\)</span> 表示第 i 个粒子距离 <spanclass="math inline">\(x(t)\)</span> 的位移 <spanclass="math inline">\(r_i&#39;=r_i(t)-x(t)\)</span>……不就是 <spanclass="math inline">\(r_i&#39;=R(t)r_{0i}\)</span><br />$$<span class="math display">\[\begin{aligned}I(t)=\sum\begin{pmatrix}m_i(r_{iy}^{&#39;2}+r_{iz}^{&#39;2})&amp; -m_ir_{ix}^{&#39;}r_{iy}^{&#39;}&amp; -m_ir_{iz}^{&#39;}r_{ix}^{&#39;}\\-m_ir_{ix}^{&#39;}r_{iy}^{&#39;}&amp; m_i(r_{iz}^{&#39;2}+r_{ix}^{&#39;2})&amp; -m_ir_{iy}^{&#39;}r_{iz}^{&#39;}\\-m_ir_{iz}^{&#39;}r_{ix}^{&#39;}&amp; m_ir_{iy}^{&#39;}r_{iz}^{&#39;}&amp; m_i(r_{ix}^{&#39;2}+r_{iy}^{&#39;2})\end{pmatrix}\end{aligned}\tag{2-32}\]</span><p>$$在<strong>实际实现</strong>中，我们会将<strong>有限求和</strong>替换为对刚体体积的<strong>积分</strong>（在世界坐标系中进行）。质量项<span class="math inline">\(m_i\)</span>会被<strong>密度函数</strong>取代。</p><p>乍看之下，似乎每当刚体的朝向 <spanclass="math inline">\(R(t)\)</span>变化时，都需要重新计算积分来求解惯性张量 <spanclass="math inline">\(I(t)\)</span>。除非刚体形状极其简单（例如球形或立方体，这类形状的积分可解析求解），否则在仿真过程中执行这种计算会<strong>代价过高</strong>。<br />幸运的是，通过使用物体坐标系，我们可以基于<strong>预计算积分</strong>（在体坐标系中完成），低成本地计算任意朝向<span class="math inline">\(R(t)\)</span>下的惯性张量。（该积分通常在仿真启动前完成，应被视为描述刚体物理属性的输入参数之一。）使用式子<spanclass="math inline">\(r_i^{&#39;T}r_i^{&#39;}=r_{ix}^{&#39;2}+r_{iy}^{&#39;2}+r_{iz}^{&#39;2}\)</span>，可以重写<span class="math display">\[I(t)=\sum m_ir_i^{&#39;T}r_i^{&#39;}\begin{pmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{pmatrix}-\begin{pmatrix}m_ir_{ix}^{&#39;2}&amp; m_ir_{ix}^{&#39;}r_{iy}^{&#39;}&amp; m_ir_{ix}^{&#39;}r_{iz}^{&#39;}\\m_ir_{iy}^{&#39;}r_{ix}^{&#39;}&amp; m_ir_{iy}^{&#39;2}&amp; m_ir_{iy}^{&#39;}r_{iz}^{&#39;}\\m_ir_{iz}^{&#39;}r_{ix}^{&#39;}&amp; m_ir_{iz}^{&#39;}r_{iy}^{&#39;}&amp; m_ir_{iz}^{&#39;2}\end{pmatrix}\tag{2-33}\]</span></p><p><span class="math display">\[\begin{aligned}r_i^{&#39;}r_i^{&#39;T}&amp;=\begin{pmatrix}r_{ix}^{&#39;}\\r_{iy}^{&#39;}\\r_{iz}^{&#39;}\end{pmatrix}\begin{pmatrix}r_{ix}^{&#39;}&amp;r_{iy}^{&#39;}&amp;r_{iz}^{&#39;}\end{pmatrix}\\&amp;=\begin{pmatrix}r_{ix}^{&#39;2}&amp; r_{ix}^{&#39;}r_{iy}^{&#39;}&amp; r_{ix}^{&#39;}r_{iz}^{&#39;}\\r_{iy}^{&#39;}r_{ix}^{&#39;}&amp; r_{iy}^{&#39;2}&amp; r_{iy}^{&#39;}r_{iz}^{&#39;}\\r_{iz}^{&#39;}r_{ix}^{&#39;}&amp; r_{iz}^{&#39;}r_{iy}^{&#39;}&amp; r_{iz}^{&#39;2}\end{pmatrix}\end{aligned}\tag{2-34}\]</span></p><p>设 <span class="math inline">\(\textbf{1}\)</span> 是一个 3x3的单位矩阵： <span class="math display">\[I(t)=\summ_i(r_i^{&#39;T}r_i^{&#39;}\textbf{1}-r_i^{&#39;}r_i^{&#39;T})\tag{2-35}\]</span> 因为 <spanclass="math inline">\(r_i(t)=R(t)r_{0i}+x(t),\;r&#39;_i=R(t)r_{0i},\;R(t)R(t)^T=\textbf{1}\)</span><br /><span class="math display">\[\begin{aligned}I(t)&amp;=\sum m_i(r_i^{&#39;T}r_i^{&#39;}\textbf{1}-r_i^{&#39;}r_i^{&#39;T})\\&amp;=\sum m_i\bigg(\Big(R(t)r_{0i}\Big)^T\Big(R(t)r_{0i}\Big)\textbf{1}-\Big(R(t)r_{0i}\Big)\Big(R(t)r_{0i}\Big)^T\bigg)\\&amp;=\summ_i\Big(r_{0i}^TR(t)^TR(t)r_{0i}\textbf{1}-R(t)r_{0i}r_{0i}^TR(t)^T\Big)\\&amp;=\sum m_i(r_{0i}^Tr_{0i}\textbf{1}-R(t)r_{0i}r_{0i}^TR(t)^T)\end{aligned}\tag{2-36}\]</span> 由于 <span class="math inline">\(r_{0i}^Tr_{0i}\)</span>是标量，所以可以有： <span class="math display">\[\begin{aligned}I(t)&amp;=\sum m_i(r_{0i}^Tr_{0i}\textbf{1}-R(t)r_{0i}r_{0i}^TR(t)^T)\\&amp;=\summ_i(R(t)r_{0i}^Tr_{0i}R(t)^T\textbf{1}-R(t)r_{0i}r_{0i}^TR(t)^T)\\&amp;=R(t)\bigg(\summ_i\Big((r_{0i}^Tr_{0i})\textbf{1}-r_{0i}r_{0i}^T)\Big)\bigg)R(t)^T\end{aligned}\tag{2-37}\]</span> 定义 <span class="math inline">\(I_{body}\)</span> 矩阵：<span class="math display">\[I_{body}=\sum m_i((r_{0i}^Tr_{0i}\textbf{1}-r_{0i}r_{0i}^T))\tag{2-38}\]</span></p><p><span class="math display">\[I(t)=R(t)I_{body}R(t)^T\tag{2-39}\]</span></p><p>幸运的是，由于 <span class="math inline">\(I_{body}\)</span>是在<strong>体坐标系</strong>中定义的，因此在仿真过程中它是<strong>恒定不变</strong>的。正因如此，我们可以在仿真开始前预计算刚体的<span class="math inline">\(I_{body}\)</span>再结合当前的<strong>朝向矩阵</strong> <spanclass="math inline">\(R(t)\)</span>，就能轻松计算出任意时刻 <em>t</em>的惯性张量 <span class="math inline">\(I(t)\)</span>。第 5.1节将基于“对刚体在体坐标系中体积的积分”，推导<strong>矩形物体</strong>的体坐标系惯性张量。<br /><span class="math inline">\(I(t)\)</span> 的逆由下面给出： <spanclass="math display">\[\begin{aligned}I^{-1}(t)&amp;=(R(t)I_{body}R(t)^T)^{-1}\\&amp;=(R(t)^T)^{-1}I_{body}^{-1}R(t)^{-1}\\&amp;=R(t)I_{body}^{-1}R(t)^T\end{aligned}\tag{2-40}\]</span></p><p>因为 <spanclass="math inline">\(R(t)^T=R(t)^{-1},\Big(R(t)\Big)^T=R(t).\)</span>显然，<span class="math inline">\(I_{body}^{-1}\)</span>也是固定的。</p><h4 id="rigid-body-equations-of-motion">2.11 Rigid Body Equations ofMotion</h4><p>对于一个刚体我们定义 <spanclass="math inline">\(\textbf{Y}(t)\)</span>: <spanclass="math display">\[\textbf{Y}(t)=\begin{pmatrix}x(t)\\R(t)\\P(t)\\L(t)\end{pmatrix}\tag{2-41}\]</span>刚体的状态由<strong>空间信息</strong>（位置与朝向）和<strong>速度信息</strong>（线动量与角动量）共同构成。刚体的质量<span class="math inline">\(M\)</span>与<strong>体坐标系惯性张量</strong> <spanclass="math inline">\(I_{body}\)</span>是常量——我们假设在仿真启动时，这两个物理属性已预先确定。<br />在任意给定时刻，辅助量 <spanclass="math inline">\(I(t)\)</span>（世界坐标系惯性张量）、<spanclass="math inline">\(\omega (t)\)</span>（角速度）与 <spanclass="math inline">\(v(t)\)</span>（线速度）需通过计算得到: <spanclass="math display">\[\begin{aligned}&amp; v(t)=\frac{P(t)}{M}\\&amp; I(t)=R(t)I_{body}R(t)^T\\&amp; \omega(t)=I(t)^{-1}L(t)\end{aligned}\tag{2-42}\]</span> 导数 <spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span>:<span class="math display">\[\begin{aligned}\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)=\frac{\mathrm{d}}{\mathrm{d}t}\begin{pmatrix}x(t)\\R(t)\\P(t)\\L(t)\end{pmatrix}=\begin{pmatrix}v(t)\\w(t)^*R(t)\\F(t)\\\tau(t)\end{pmatrix}\end{aligned}\tag{2-43}\]</span> 最后一点：与其用 <spanclass="math inline">\(\textbf{Y}(t)\)</span> 中的矩阵 <spanclass="math inline">\(R(t)\)</span> 来表示物体的朝向，不如使用四元数。第4节讨论了用四元数代替旋转矩阵。简单来说，四元数是一种包含四个元素的向量，可用于表示旋转。如果我们将<span class="math inline">\(\textbf{Y}(t)\)</span> 中的 <spanclass="math inline">\(R(t)\)</span> 替换为四元数 <spanclass="math inline">\(q(t)\)</span>，就可以将 <spanclass="math inline">\(R(t)\)</span> 视为一个辅助变量，从 <spanclass="math inline">\(q(t)\)</span> 直接计算 <spanclass="math inline">\(R(t)\)</span>，就像从 <spanclass="math inline">\(L(t)\)</span> 直接计算 <spanclass="math inline">\(\omega(t)\)</span> 的方式。第 4节会推导出一个类似于 <span class="math inline">\(\dot R(t) =\omega(t)^*R(t)\)</span> 的公式，该公式根据 <spanclass="math inline">\(q(t)\)</span> 和 <spanclass="math inline">\(\omega(t)\)</span> 表示 <spanclass="math inline">\(\dot q(t)\)</span>。</p><h3 id="computeing-fracmathrmdmathrmdttextbfyt">3. Computeing <spanclass="math inline">\(\frac{\mathrm{d}}{\mathrm{d}t}\textbf{Y}(t)\)</span></h3><p>让我们考虑刚体的 dydt函数的实现。代码是用c++编写的，我们假设我们有称为 matrix 和 triple的数据类型（类），它们分别实现3 × 3矩阵和3空间中的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// 3x3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">matrix</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">/// 3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">triple</span><br>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RigidBody</span><br>&#123;<br>    <span class="hljs-comment">// constant quantities</span><br>    <span class="hljs-type">double</span> mass;<br>    matrix Ibody;<br>    matrix IbodyInv;<br>    <br>    <span class="hljs-comment">// state variables</span><br>    triple x;<br>    matrix R;<br>    triple P;<br>    triple L;<br>    <br>    <span class="hljs-comment">// derived quantities</span><br>    matrix Iinv;<br>    triple v;<br>    triple omega;<br>    <br>    <span class="hljs-comment">// computed quantities</span><br>    triple force;<br>    triple torque;<br>&#125;<br><br>RigidBody Bodies[NBODIES];<br></code></pre></td></tr></table></figure><p>假设在模拟开始之前，已经为数组<code>Bodies</code>的每个成员计算了常量<code>mass</code>，<code>Ibody</code>和<code>IbodyInv</code>。同样，每个刚体的初始条件通过赋值给的<code>Bodies</code>每个成员的状态变量<code>x</code>、<code>R</code>、<code>P</code>和<code>L</code>来指定。本节中的实现用旋转矩阵表示方向；第4节描述了用四元数表示方向所必需的更改。我们通过传递实数数组与微分方程求解器进行通信。<br />需要几个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// copy body state information to an array</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">State_to_Array</span><span class="hljs-params">(RigidBody *rb, <span class="hljs-type">double</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    *y++ = rb-&gt;x[<span class="hljs-number">0</span>];<br>    *y++ = rb-&gt;x[<span class="hljs-number">1</span>];<br>    *y++ = rb-&gt;x[<span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>        &#123;<br>            *y++ = rb-&gt;R[i,j];<br>        &#125;<br>    &#125;<br>    *y++ = rb-&gt;P[<span class="hljs-number">0</span>];<br>    *y++ = rb-&gt;P[<span class="hljs-number">1</span>];<br>    *y++ = rb-&gt;P[<span class="hljs-number">2</span>];<br>    <br>    *y++ = rb-&gt;L[<span class="hljs-number">0</span>];<br>    *y++ = rb-&gt;L[<span class="hljs-number">1</span>];<br>    *y++ = rb-&gt;L[<span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-comment">// Copy information from an array to RigidBody</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Array_to_State</span><span class="hljs-params">(RigidBody *rb, <span class="hljs-type">double</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    rb-&gt;x[<span class="hljs-number">0</span>] = *y++;<br>    rb-&gt;x[<span class="hljs-number">1</span>] = *y++;<br>    rb-&gt;x[<span class="hljs-number">2</span>] = *y++;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>        &#123;<br>            rb-&gt;R[i,j] = *y++;<br>        &#125;<br>    &#125;<br>    rb-&gt;P[<span class="hljs-number">0</span>] = *y++;<br>    rb-&gt;P[<span class="hljs-number">1</span>] = *y++;<br>    rb-&gt;P[<span class="hljs-number">2</span>] = *y++;<br>    <br>    rb-&gt;L[<span class="hljs-number">0</span>] = *y++;<br>    rb-&gt;L[<span class="hljs-number">1</span>] = *y++;<br>    rb-&gt;L[<span class="hljs-number">2</span>] = *y++;<br>    <br>    <span class="hljs-comment">// 原文就这么写的，我也不知道哪来的，伪代码看一乐吧</span><br>    rb-&gt;v = rb-&gt;P / mass;<br>    <br>    rb-&gt;Iinv = R * IbodyInv * <span class="hljs-built_in">Transpose</span>(R);<br>    <br>    rb-&gt;omega = rb-&gt;Iinv * rb-&gt;L;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查这些例程，我们看到每个刚体的状态由3+9+3+3 = 18个数字(<spanclass="math inline">\(mass\; and\;I_{body}:\textbf{fxxk}\)</span>)表示。body的所有成员和大小为18·NBODIES的数组y之间的传输。<br />Compute_Force_and_Torque考虑了所有的力和扭矩：重力，风，与其他物体的相互作用等。</p><p>开摆了这部分都是程序设计没什么好说的</p><h3 id="quaternions-vs.-rotation-matrix">4. Quaternions vs. RotationMatrix</h3><p>对于刚体模拟，避免使用旋转矩阵的最重要原因是数值漂移问题。假设我们根据公式跟踪刚体的方向<spanclass="math inline">\(\dot R(t)=\omega^*R(t)\)</span><br />当我们用这个公式更新 <span class="math inline">\(R(t)\)</span>时（也就是说，当我们对这个方程积分时），我们将不可避免地遇到数值漂移。数值误差将在R(t)的系数中建立，因此<spanclass="math inline">\(R(t)\)</span>将不再是精确的旋转矩阵。从图形上看，效果是将 <spanclass="math inline">\(R(t)\)</span> 应用于物体会导致扭曲效果。<br />在刚体模拟中，使用单位四元数表示旋转可缓解数值漂移问题。四元数仅需四个参数，仅需一个额外变量即可描述旋转的三个自由度。相比之下，旋转矩阵用九个参数描述三个自由度，冗余度显著高于四元数。因此，四元数的漂移程度远低于旋转矩阵。若必须修正四元数的漂移，那是因为它已失去单位幅值特性。可通过将四元数重新归一化为单位长度轻松修正。由于这两大特性，直接用单位四元数<span class="math inline">\(q(t)\)</span>表示物体方向最为理想。我们仍将角速度表示为向量 ω(t)。计算惯性张量 <spanclass="math inline">\(I^{-1}(t)\)</span> 所需的方向矩阵 <spanclass="math inline">\(R(t)\)</span>，将作为辅助变量由 <spanclass="math inline">\(q(t)\)</span> 直接推导得出。<br />我们把四元数 <span class="math inline">\(s+v_xi+v_yj+v_zk\)</span>写成数对: <span class="math inline">\([s,v]\)</span><br /><span class="math display">\[[s_1,v_1][s_2,v_2]=[s_1s_2-v_1\cdot v_2,s_1v_2+s_2v_1+v_1\timesv_2]\tag{4-1}\]</span> 绕单位轴 <span class="math inline">\(u\)</span> 旋转 <spanclass="math inline">\(\theta\)</span> 表示为: <spanclass="math inline">\([\cos(\frac{\theta}{2}),\sin(\frac{\theta}{2})u].\)</span><br />在刚元数表示旋转时，若 <span class="math inline">\(q_1\)</span> 和 <spanclass="math inline">\(q_2\)</span> 分别表示旋转，则 <spanclass="math inline">\(q-2q_1\)</span> 表示先执行 <spanclass="math inline">\(q_1\)</span> 旋转、再执行 <spanclass="math inline">\(q_2\)</span>旋转的复合旋转。稍后我们将展示如何修改第 3节的例程以适配四元数的方向表示。但在修改前，需先推导 <spanclass="math inline">\(\dot q(t)\)</span> 的公式，附录 B推导了该公式：<br /><span class="math display">\[\dot q(t)=\frac{1}{2}\omega(t)q(t)\tag{4-2}\]</span> 这里 <span class="math inline">\(\omega(t)q(t)\)</span> 是四元数 <span class="math inline">\([0, \omega(t)]\)</span> 和 <spanclass="math inline">\(q(t)\)</span> 相乘的简写。<br />这个等式看着有些眼熟，不是吗？<br /><span class="math inline">\(\dot R(t)=\omega(t)^*R(t)\)</span><br />使用四元数我们需要重新设计 RigidBody：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RigidBody</span><br>&#123;<br>    <span class="hljs-comment">// constant quantities</span><br>    <span class="hljs-type">double</span> mass;<br>    matrix Ibody;<br>    matrix IbodyInv;<br>    <br>    <span class="hljs-comment">// state variables</span><br>    triple x;<br>    quaternion q;<br>    triple P;<br>    triple L;<br>    <br>    <span class="hljs-comment">// derived quantities</span><br>    matrix Iinv;<br>    matrix R;<br>    triple v;<br>    triple omega;<br>    <br>    <span class="hljs-comment">// computed quantities</span><br>    triple force;<br>    triple torque;<br>&#125;<br><br>rb-&gt;R = <span class="hljs-built_in">quaternion_to_matrix</span>(<span class="hljs-built_in">normalize</span>(rb-&gt;q));<br></code></pre></td></tr></table></figure><p>函数 <code>normalize</code> 返回被 <spanclass="math inline">\(q\)</span> 除以 长度的归一化结果。单位长度的四元数再传给 <code>quaternion_to_matrix</code>，返回 3x3 矩阵，如 <span class="math inline">\(q=[s,v]\)</span>则返回的矩阵为<br /><span class="math display">\[\begin{pmatrix}1-2v_y^2-2v_z^2&amp; 2v_xv_y-2sv_z&amp; 2v_xv_z+2sv_y\\2v_xv_y+2sv_z&amp; 1-2v_x^2-2v_z^2&amp; 2v_yv_z-2sv_x\\2v_xv_z-2sv_y&amp; 2v_yv_z+2sv_x&amp; 1-2v_x^2-2v_y^2\end{pmatrix}\]</span> 从旋转矩阵到四元数<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">quaternion <span class="hljs-title">matrix_to_quaternion</span><span class="hljs-params">(<span class="hljs-type">const</span> matrix &amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br>    quaternion q;<br>    <span class="hljs-type">double</span> tr,s;<br>    <br>    tr = m[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] + m[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]+m[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span>(tr &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        s = <span class="hljs-built_in">sqrt</span>(tr + <span class="hljs-number">1</span>);<br>        q.r = <span class="hljs-number">0.5</span> * s;<br>        s = <span class="hljs-number">0.5</span> / s;<br>        q.i = (m[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] - m[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) * s;<br>        q.j = (m[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] - m[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]) * s;<br>        q.k = (m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] - m[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]) * s;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(m[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] &gt; m[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br>            i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(m[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] &gt; m[i,i])<br>            i = <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">switch</span>(i)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                s = <span class="hljs-built_in">sqrt</span>((m[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]-(m[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] + m[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])) + <span class="hljs-number">1</span>);<br>                q.i = <span class="hljs-number">0.5</span> * s;<br>                s = <span class="hljs-number">0.5</span> / s;<br>                q.j = (m[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] + m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]) * s;<br>q.k = (m[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] + m[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]) * s;<br>q.r = (m[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] - m[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) * s;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>s = <span class="hljs-built_in">sqrt</span>((m[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] - (m[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] + m[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])) + <span class="hljs-number">1</span>);<br>q.j = <span class="hljs-number">0.5</span> * s;<br>s = <span class="hljs-number">0.5</span> / s;<br>q.k = (m[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + m[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]) * s;<br>q.i = (m[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] + m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]) * s;<br>q.r = (m[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>] - m[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]) * s;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>s = <span class="hljs-built_in">sqrt</span>((m[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] - (m[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] + m[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>);<br>                q.k = <span class="hljs-number">0.5</span> * s;<br>                s = <span class="hljs-number">0.5</span> / s;<br>                q.i = (m[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] + m[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]) * s;<br>                q.j = (m[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + m[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]) * s;<br>                q.r = (m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] - m[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]) * s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>矩阵m的结构使m[0,0], m[0,1]和m[0,2]构成m的第一行（而不是列）。<br />例程Array_to_Bodies和Bodies_to_Array根本不需要任何更改，但请注意常量STATE_SIZE从18更改为13，因为四元数需要的元素比旋转矩阵少5个。我们只需要在ddt_State_to_Array中进行其他更改</p><h3 id="examples">5. Examples</h3><h4 id="inertia-tensor-of-a-block">5.1 Inertia Tensor of a Block</h4><p><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure7.png" /><br />计算图中 <span class="math inline">\(x_0\times y_0\times z_0\)</span>的长方形的惯性张量 <span class="math inline">\(I_{body}\)</span>我们将质心设为原点，因此长方体的 x 轴 <spanclass="math inline">\([-\frac{x_0}{2},\frac{x}{2}]\)</span>，yz同理。<br />我们需要知道质量才能计算，<spanclass="math inline">\(\rho(x_i,y_i,z_i)dxdydz=m_i\)</span>因为物体密度恒定，所以质量就是 <span class="math inline">\(M=\rhox_0y_0z_0\)</span><br /><span class="math display">\[\begin{aligned}I_{xx}&amp;=\int_{-\frac{x_0}{2}}^{\frac{x_0}{2}}\int_{-\frac{y_0}{2}}^{\frac{y_0}{2}}\int_{-\frac{z_0}{2}}^{\frac{z_0}{2}}\rho(x,y,z)(y^2+z^2)\mathrm{d}z\mathrm{d}y\mathrm{d}x\\&amp;=\frac{M}{12}(y_0^2+z_0^2)\\I_{yy}&amp;=\frac{M}{12}(x_0^2+z_0^2)\\I_{zz}&amp;=\frac{M}{12}(x_0^2+y_0^2)\end{aligned}\tag{5-1}\]</span> 计算 <span class="math inline">\(I_{xy}\)</span>(根据 2-32式)<br /><span class="math display">\[\begin{aligned}I_{xy}&amp;=\int_{-\frac{x_0}{2}}^{\frac{x_0}{2}}\int_{-\frac{y_0}{2}}^{\frac{y_0}{2}}\int_{-\frac{z_0}{2}}^{\frac{z_0}{2}}-\rho(x,y,z)(xy)\mathrm{d}z\mathrm{d}y\mathrm{d}x\\&amp;=0\end{aligned}\tag{5-2}\]</span> 有<br /><span class="math display">\[\begin{aligned}I_{body}=\frac{M}{12}\begin{pmatrix}y_0^2+z_0^2&amp; 0&amp; 0\\0&amp; x_0^2+z_0^2&amp; 0\\0&amp; 0&amp; x_0^2+y_0^2\end{pmatrix}\end{aligned}\tag{5-3}\]</span></p><h4 id="a-uniform-force-field">5.2 A Uniform Force Field</h4><p>假设一个均匀的力作用在物体的每一个粒子上。例如，我们通常将引力场描述为对刚体的每个粒子施加一个力，其中<span class="math inline">\(g\)</span>是指向向下的矢量。重力作用在物体上的合力 <spanclass="math inline">\(F_g\)</span> 是<br /><span class="math display">\[F_g=\sum m_ig=Mg\tag{5-4}\]</span> 扭矩：<br /><span class="math display">\[\sum(r_i(t)-x(t))\times m_ig=\textbf{0}\tag{5-5}\]</span> 这里用了一个式子2-20。由此可见，均匀的重力场对物体的角动量没有影响。这里引力场可以被视为一个<strong>单一合力</strong>，作用于物体的<strong>质心</strong>处，大小等于<span class="math inline">\(Mg\)</span>(其中 <spanclass="math inline">\(M\)</span> 是物体质量，<spanclass="math inline">\(g\)</span> 是重力加速度)。</p><h4 id="rotation-free-movement-of-a-body">5.3 Rotation Free Movement ofa Body</h4><p>让我考虑一下图中所示的两个力<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure8.png" /> 外力 <spanclass="math inline">\(F=(0,0,f)\)</span>分别作用在 <spanclass="math inline">\(x(t)+(-3,0,-2)\;,\;x(t)+(3,0,-2)\)</span><br />我们直观的想到这只会有线性加速度，而非角加速度。<br />合力为 <span class="math inline">\((0,0,2f)\)</span>，加速度 <spanclass="math inline">\(\frac{2f}{M}\)</span> 沿着 z 轴<br />有两力矩<br /><span class="math display">\[\begin{aligned}&amp;(x(t)+\begin{pmatrix}-3\\0\\-2\end{pmatrix}-x(t))\times F=\begin{pmatrix}-3\\0\\-2\end{pmatrix}\times F\\&amp;(x(t)+\begin{pmatrix}3\\0\\-2\end{pmatrix}-x(t))\times F=\begin{pmatrix}3\\0\\-2\end{pmatrix}\times F\\&amp;\tau=\begin{pmatrix}-3\\0\\-2\end{pmatrix}\times F +\begin{pmatrix}3\\0\\-2\end{pmatrix}\times F=\begin{pmatrix}0\\0\\-2\end{pmatrix}\times F\\&amp;=\begin{pmatrix}0\\0\\-2\end{pmatrix}\times\begin{pmatrix}0\\0\\f\end{pmatrix}=\textbf{0}\end{aligned}\]</span></p><h4 id="translation-free-movement-of-a-body">5.4 Translation FreeMovement of a Body</h4><p>现在假设外力 <spanclass="math inline">\(F_1=(0,0,f)\)</span>作用在物体的点 <spanclass="math inline">\(x(t)+(-3,0, -2)\)</span>上，外力 <spanclass="math inline">\(F_2=(0,0,-f)\)</span> 作用在物体的点 <spanclass="math inline">\(x(t)+(3,0,2)\)</span>上。由于F1=−F2，作用在物体上的合力是 <spanclass="math inline">\(F_1+F_2=0\)</span>​，所以没有质心加速度。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure9.png" />另一方面，扭矩合是<br /><span class="math display">\[\begin{aligned}&amp;(x(t)+\begin{pmatrix}-3\\0\\-2\end{pmatrix}-x(t))\times F_1+(x(t)+\begin{pmatrix}3\\0\\-2\end{pmatrix}-x(t))\times F_2=&amp;\\&amp;\begin{pmatrix}-3\\0\\-2\end{pmatrix}\times\begin{pmatrix}0\\0\\f\end{pmatrix}+\begin{pmatrix}3\\0\\-2\end{pmatrix}\times\begin{pmatrix}0\\0\\-f\end{pmatrix}=\\&amp;\begin{pmatrix}0\\3f\\0\end{pmatrix}+\begin{pmatrix}0\\3f\\0\end{pmatrix}=\begin{pmatrix}0\\6f\\0\end{pmatrix}\end{aligned}\]</span> 因此，合扭矩为<spanclass="math inline">\((0,6f,0)\)</span>，与y轴平行。最终的结果是，作用在物体上的力使物体沿y轴 呈角加速。</p><h4 id="force-vs.-torque-puzzle">5.5 Force vs. Torque Puzzle</h4><p>在分析一个力作用于物体某点所产生的影响时，有时会觉得这个力<strong>仿佛被重复考量了两次</strong>。也就是说，若力<span class="math inline">\(F\)</span> 作用于空间中某点 <spanclass="math inline">\(r+x(t)\)</span>处的物体，我们会先将其视为<strong>加速质心</strong>的力，再将其视为<strong>赋予物体自旋</strong>的力。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure10.png" /><br />这催生出一个看似矛盾的情境：观察上图中的长水平木块（初始静止）。假设力<span class="math inline">\(F\)</span>作用于木块的<strong>质心</strong>并持续一段时间（比如10秒)。由于力作用于质心，<strong>对物体不产生力矩</strong>。10秒后，物体将获得一定<strong>线速度</strong><em>v</em>；但物体不会获得任何<strong>角速度</strong>，因此木块的<strong>动能</strong>为<span class="math inline">\(\frac{1}{2}M|v|^2\)</span>。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure11.png" />现在假设相同的力 <span class="math inline">\(F\)</span><strong>偏置</strong>作用于物体（如图11所示）。由于作用于物体的力大小未变，<strong>质心的加速度也相同</strong>。因此，10秒后，物体将再次获得线速度<span class="math inline">\(v\)</span>。然而，由于力 F偏置作用，此时会对物体<strong>产生力矩</strong>，10秒后，物体将获得一定的<strong>角速度</strong><spanclass="math inline">\(\omega\)</span>。此时物体的动能（见附录C)为:<br /><span class="math display">\[\frac{1}{2}M|v|^2+\frac{1}{2}\omega^TI\omega\]</span>木块的动能<strong>比力作用于质心时更高</strong>。但若两次作用的是<strong>完全相同的力</strong>，木块的动能为何会不同？提示：能量（或功）是<strong>力对位移的积分</strong>（即力沿作用路径累积的效果）。<br /><img src="/imgs/Rigid%20Body%20Simulation%20Ⅰ/Figure12.png" />图12展示了<strong>偏置力为何会产生更高的动能</strong>：木块的动能等于<strong>力所做的功</strong>，而功是<strong>力对位移的积分</strong>（即力沿作用路径累积的效果）。<br />在图11中，力<strong>偏置作用于质心外</strong>时，需关注<strong>力作用点的运动轨迹</strong>——该轨迹明显长于图10中<strong>质心的运动轨迹</strong>。因此，当力偏置作用时，<strong>力作用点（记为p点）描出的路径更长</strong>，导致力做的功更多（因为功的本质是力对作用点位移的累积)。</p><h2 id="reference">Reference</h2><p><ahref="https://www.cs.cmu.edu/~baraff/sigcourse/index.html">PhysicallyBased Modeling</a><br /><ahref="https://www.cs.cmu.edu/~baraff/sigcourse/notesd1.pdf">UnconstrainedRigid Body Dynamics</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Differential Equation Basics</title>
    <link href="/2025/08/09/Differential%20Equation%20Basics/"/>
    <url>/2025/08/09/Differential%20Equation%20Basics/</url>
    
    <content type="html"><![CDATA[<p>微分方程描述的是<strong>未知函数</strong>及<strong>未知函数的导数</strong>之间的关系。<span id="more"></span> # Differential Equation Basics</p><h2 id="initial-value-problems">1. Initial Value Problems</h2><p>微分方程描述的是<strong>未知函数</strong>及<strong>未知函数的导数</strong>之间的关系。解微分方程的过程就是找到满足该关系的函数，该函数通常也需要满足一些其他条件。在这个课程中，我们将关注一类特殊问题——<strong>初值问题(InitialValueProblems)</strong>。在经典的初值问题中，系统行为以如下的<strong>常微分方程(</strong>ordinarydifferential equation - ODE<strong>)</strong>表示 <spanclass="math display">\[\dot{\textbf{x}}=f(\textbf{x},t)\]</span> 函数 f 是已知的，可以通过给定 <spanclass="math inline">\(\textbf{x},t\)</span> 进行计算，<spanclass="math inline">\(\textbf{x}\)</span> 表示系统的状态，<spanclass="math inline">\(\dot{\textbf{x}}\)</span> 是 <spanclass="math inline">\(\textbf{x}\)</span>在时间上的导数。值得注意的是，<spanclass="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(\dot{\textbf{x}}\)</span> 都是矢量(vector)。正如初始值问题 的名字一样，我们能得到在 <spanclass="math inline">\(t=t_0\)</span> 时 <spanclass="math inline">\(\textbf{x}(t_0)=\textbf{x}_0\)</span>，并且追踪<span class="math inline">\(\textbf{x}\)</span> 随着时间的变化。</p><p>一般的初值问题很好可视化。在 2D 平面中，<spanclass="math inline">\(\textbf{x}(t)\)</span> 绘制了一条描述点 <spanclass="math inline">\(\textbf{p}\)</span> 在平面上的运动轨迹。在任一点<span class="math inline">\(\textbf{x}\)</span> 方程 <spanclass="math inline">\(f\)</span> 可以求得一个二维向量，所以可以认为<span class="math inline">\(f\)</span> 在该平面定义了一个方向场(figure1.)。在 <span class="math inline">\(\textbf{x}\)</span> 的向量是 移动点<span class="math inline">\(\textbf{p}\)</span> 如果经过 <spanclass="math inline">\(\textbf{x}\)</span> 必须拥有的速度，当然 <spanclass="math inline">\(\textbf{p}\)</span> 可能经过该点也可能不会。<spanclass="math inline">\(f\)</span> 就像一股洋流使得 移动点 <spanclass="math inline">\(\textbf{p}\)</span>从一点移动到零一点。无论我们最初把 <spanclass="math inline">\(\textbf{p}\)</span>存放在何处，该点的“电流”都会将其捕获。<spanclass="math inline">\(\textbf{p}\)</span>的位置取决于我们最初把它扔到哪里，但是一旦扔到哪里，所有未来的运动都是由<span class="math inline">\(f\)</span> 决定的。<spanclass="math inline">\(f\)</span> 驱动点 <spanclass="math inline">\(\textbf{p}\)</span>产生的移动轨迹构成了向量场的积分曲线如 Figure 2 。<br />积分曲线也就是方程的解，其上的每一点斜率都是 <spanclass="math inline">\(f\)</span> 的 向量。</p><p>我们将 <span class="math inline">\(f\)</span> 写作 <spanclass="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(t\)</span>的方程，但是导数函数可能依赖时间也可能不会。如果导数函数真的和时间相关，点<span class="math inline">\(\textbf{p}\)</span>不仅会运动，整个向量场都会运动，这样 <spanclass="math inline">\(\textbf{p}\)</span>的速度不仅取决于他的位置，还取决于他什么时候到达该位置。在这种情况下，导数<span class="math inline">\(\dot{\textbf{x}}\)</span>在两个方面上受时间影响：首先，导数向量本身随时间变化。其次，因为点 <spanclass="math inline">\(\textbf{p}\)</span> 沿着轨迹 <spanclass="math inline">\(\textbf{x}(t)\)</span>运动，会在不同时间表现出不同的导数向量。可以想象一个粒子随着起伏变化的向量场而浮动就像起落的潮水……我的爱如潮水~爱如潮水将我向你推~</p><p><imgsrc="/imgs/Differential%20Equation%20Basics/Figure1.png" /><br /><img src="/imgs/Differential%20Equation%20Basics/Figure2.png" /></p><h2 id="numerical-solutions">2. Numerical Solutions</h2><p>初级的微分方程主要关注其解析解，即猜测其未知函数的函数形式。比如一个微分方程为<span class="math inline">\(\dot{x}=-kx\)</span>，解即为<spanclass="math inline">\(x=e^{-kt}\)</span>.</p><p>相比之下，我们关注的是数值解，即从初始值 <spanclass="math inline">\(\textbf{x}(t_0)\)</span>开始以时间为步进进行计算。为了进行步进，我们需要通过导函数 <spanclass="math inline">\(f\)</span> 计算在时间间隔 <spanclass="math inline">\(\Delta t\)</span> 内 <spanclass="math inline">\(\textbf{x}\)</span> 的变化 <spanclass="math inline">\(\Delta\textbf{x}\)</span>，然后在 <spanclass="math inline">\(\textbf{x}\)</span> 累加 <spanclass="math inline">\(\Delta\textbf{x}\)</span>获得新的函数值。在计算数值解时，导函数 <spanclass="math inline">\(f\)</span> 视作一个黑盒，我们提供 <spanclass="math inline">\(\textbf{x},t\)</span> 的数值，然后得到 <spanclass="math inline">\(\dot{\textbf{x}}\)</span> 的”数值“值。<br />数值方法是通过在每个时间步长内进行一次或多次这些导数的计算来运作的。</p><h3 id="eulers-method">2.1. Euler's Method</h3><p>最简单的数值方法被称为欧拉法。我们将 <spanclass="math inline">\(\textbf{x}\)</span> 的初始值记作 <spanclass="math inline">\(\textbf{x}_0 =\textbf{x}(t0)\)</span>，而我们对下一时刻 <spanclass="math inline">\(t_0 + h\)</span> 时 <spanclass="math inline">\(\textbf{x}\)</span> 的估计记作 <spanclass="math inline">\(\textbf{x}(t_0 + h)\)</span>，其中 <spanclass="math inline">\(h\)</span>是一个步长参数。欧拉法只是通过沿导数方向步进一步来计算 <spanclass="math inline">\(\textbf{x}(t_0 + h)\)</span>。<br /><span class="math display">\[\textbf{x}(t_0+h)=x_0+h\dot{\textbf{x}}(t_0)\]</span>可以借助二维向量场的图像来直观理解欧拉方法。与真实的积分曲线不同，点<span class="math inline">\(\textbf{p}\)</span>会沿着一个多边形路径移动，每条边的长度由在起点处计算向量 <spanclass="math inline">\(f\)</span> 的值，并乘以步长 <spanclass="math inline">\(h\)</span> 来确定。请参见 Figure.3自下而上表示了不同的步进精度。<br /><img src="/imgs/Differential%20Equation%20Basics/Figure3.png" />尽管这种方法简单，但并不精确。考虑一个二维函数 <spanclass="math inline">\(f\)</span> 的情况，其积分曲线是同心圆。由 <spanclass="math inline">\(f\)</span> 控制的点 <spanclass="math inline">\(\textbf{p}\)</span>应该永远在它开始所在的圆上绕圈运动。然而，每次使用欧拉法进行一步运算时，点<span class="math inline">\(\textbf{p}\)</span>都会沿着一条直线移动到半径更大的圆上，因此其路径会形成向外的螺旋状。减小步长可以减缓这种向外漂移的速度，但永远无法消除它。<br />此外，欧拉方法实际上是不稳定的。以一个一维函数为例 <spanclass="math inline">\(f=-kx\)</span>，应该使得点 <spanclass="math inline">\(\textbf{p}\)</span>以指数级速度下降至0。如果步长足够小我们能得到合理的结果，但当 <spanclass="math inline">\(h&gt;\frac{1}{k}\)</span>，则 <spanclass="math inline">\(\Deltax&gt;|x|\)</span>，所以结果会在零附近来回震荡，如果超过 <spanclass="math inline">\(h=\frac{2}{k}\)</span>，震荡将会发散，系统崩溃。<br /><img src="/imgs/Differential%20Equation%20Basics/Figure4.png" /><br />最后，欧拉方法甚至都不算高效。大多数数值求解方法几乎都将全部时间用于进行导数计算，因此每一步的计算成本取决于每一步的计算次数。尽管欧拉方法每一步只需进行一次计算，但方法的实际效率取决于它允许的步长大小（在保证精度和稳定性的同时)以及每一步的计算成本。更为复杂的算法，甚至有些每一步需要多达四到五次计算，都能大大优于欧拉方法，因为它们每一步的高计算成本被它们允许的更大步长所抵消。<br />要了解我们如何改进欧拉方法，我们需要更仔细地研究该方法所产生的误差。理解其原理的关键在于泰勒级数：假设函数 <span class="math inline">\(\textbf{x}(t)\)</span>是连续的，那么我们可以将其在该步进结束时的值，表示为一个初始时刻的函数值与各阶导数的无穷级数和：<br /><spanclass="math inline">\(\textbf{x}(t_0+h)=\textbf{x}(t_0)+h\dot{\textbf{x}}(t_0)+\frac{h^2}{2!}\ddot{\textbf{x}}(t_0)+\frac{h^3}{3!}\dddot{\textbf{x}}(t_0)+...+\frac{h^n}{n!}\frac{\delta^n{\textbf{x}}}{\delta t^n}\)</span><br />对上式进行截断只保留前两项就得到了欧拉更新公式。也就是说只有除第一个带导函数的子项外，其余导数全都为零欧拉公式才是正确的，也就是说只有在<span class="math inline">\(\textbf{x}(t)\)</span>线性时欧拉公式才正确。在欧拉公式和完整的泰勒级数式间的误差，主要由 <spanclass="math inline">\(\frac{h^2}{2!}\ddot{\textbf{x}}(t_0)\)</span>决定。因此，我们可以将误差项描述为 <spanclass="math inline">\(O(h^2)\;\;Order \; h\; squared\)</span>。假设我们将步长减半即 <span class="math inline">\(\frac{h}{2}\)</span>，这样的误差会缩小1/4，但是给定的时间间隔内计算量会达到两倍。这意味着在时间间隔<spanclass="math inline">\(t_0\)</span> 和 <spanclass="math inline">\(t_1\)</span> 之间的计算误差和 <spanclass="math inline">\(h\)</span>成线性相关。理论上我们可以挑选一个合适大小的 <spanclass="math inline">\(h\)</span> 来计算 <spanclass="math inline">\(t_0\)</span> 和 <spanclass="math inline">\(t_1\)</span> 间的 <spanclass="math inline">\(\textbf{x}\)</span>值，并保证较小的误差，可实际计算过程中根据误差和 <spanclass="math inline">\(f\)</span> 我们可能必须使用较大的步进。</p><h3 id="the-midpoint-method">2.2.The Midpoint Method</h3><p>如果我们能求 <span class="math inline">\(\dot{\textbf{x}}\)</span> 和<span class="math inline">\(\ddot{\textbf{x}}\)</span> ，就能实现 <spanclass="math inline">\(O(h^3)\)</span> 级别的误差：<br /><span class="math display">\[\textbf{x}(t_0+h)=\textbf{x}(t_0)+h\dot{\textbf{x}}(t_0)+\frac{h^2}{2!}\ddot{\textbf{x}}(t_0)+O(h^3)\tag{1}\]</span></p><p>时间导数 <span class="math inline">\(\dot{\textbf{x}}\)</span> 是函数<span class="math inline">\(f(\textbf{x}(t),t)\)</span>，为了简化情况，我们假设函数 <span class="math inline">\(f\)</span> 从<span class="math inline">\(\textbf{x}\)</span> 间接受到时间影响，所以<spanclass="math inline">\(\dot{\textbf{x}}=f(\textbf{x}(t))\)</span>，根据链式法则：<br /><span class="math display">\[\begin{aligned}&amp;chain\;rule:f(g(x))&#39;=f&#39;[g(x)]g&#39;(x)\\&amp;\ddot{\textbf{x}}=f(\textbf{x}(t))&#39;=f&#39;(\textbf{x}(t))\textbf{x}&#39;(t)=\frac{\deltaf}{\delta\textbf{x}}\dot{\textbf{x}}=f&#39;f\\\end{aligned}\]</span> 为了避免可能计算 <span class="math inline">\(f&#39;\)</span>出现复杂的计算，我们可以仅用 <span class="math inline">\(f\)</span>来近似二阶项，并将该近似值带入到 等式1，保留 <spanclass="math inline">\(O(h^3)\)</span>的误差，为此我们再次进行泰勒展开：<br /><span class="math display">\[f(\textbf{x}_0,\Delta\textbf{x})=f(\textbf{x}_0)+\Delta\textbf{x}f&#39;(\textbf{x}_0)+O(\Delta\textbf{x}^2)\tag{2}\]</span> 我们引入 <spanclass="math inline">\(\ddot{\textbf{x}}\)</span> 通过等式:<br /><span class="math display">\[\begin{aligned}&amp;\Delta\textbf{x}=\frac{h}{2}f(\textbf{x}_0)\\&amp;f(\textbf{x}_0+\frac{h}{2}f(\textbf{x}_0))=f(\textbf{x}_0)+\frac{h}{2}f(\textbf{x}_0)f&#39;(\textbf{x}_0)+O(h^2)\\&amp;=f(\textbf{x}_0)+\frac{h}{2}\ddot{\textbf{x}}(t_0)+O(h^2)\\&amp;这里\;\textbf{x}_0=\textbf{x}(t_0),我们两边乘上h,使\;O(h^2)\;为\;O(h^3)\\&amp;h[f(\textbf{x}_0+\frac{h}{2}f(\textbf{x}_0))]=hf(\textbf{x}_0)+\frac{h^2}{2}\ddot{\textbf{x}}(t_0)+O(h^3)\\&amp;\frac{h^2}{2}\ddot{\textbf{x}}+O(h^3)=h[f(\textbf{x}_0+\frac{h}{2}f(\textbf{x}_0))-f(\textbf{x}_0)]\\&amp;带入式子1,\\&amp;\textbf{x}(t_0+h)=\textbf{x}(t_0)+h\dot{\textbf{x}}(t_0)+[\frac{h^2}{2!}\ddot{\textbf{x}}(t_0)+O(h^3)]\\&amp;\textbf{x}(t_0+h)=\textbf{x}(t_0)+h\dot{\textbf{x}}(t_0)+h[f(\textbf{x}_0+\frac{h}{2}f(\textbf{x}_0))-f(\textbf{x}_0)]\\&amp;\textbf{x}(t_0+h)=\textbf{x}(t_0)+h[f(\textbf{x}_0+\frac{h}{2}f(\textbf{x}_0))]\end{aligned}\]</span>该方法先计算一步欧拉公式，然后在该步进中点进行二阶导计算，用中点值更新<span class="math inline">\(\textbf{x}\)</span> ，即中点法。<br /><img src="/imgs/Differential%20Equation%20Basics/Figure5.png"alt="Figure5" /><br />中点数值方法精度在 <span class="math inline">\(O(h^3)\)</span>但是需要进行两次 <span class="math inline">\(f\)</span> 的计算。<br />我们不必止步于 <span class="math inline">\(O(h^3)\)</span>这种误差。通过对函数 <span class="math inline">\(f\)</span>进行更多次的计算，我们可以消除更高阶的导数项。这种做法最常用的方法被称为4 阶 Runge-Kutta方法，其每一步的误差为 <spanclass="math inline">\(O(h^5)\)</span>。（中点法可以被称为 2 阶Runge-Kutta 方法。）我们不会推导出4阶 Runge-Kutta 方法，但计算 <spanclass="math inline">\(\textbf{x}(t_0 + h)\)</span>的公式如下所示：<br /><span class="math display">\[k_1&amp;=&amp;hf(\textbf{x}_0,t_0)\\k_2&amp;=&amp;hf(\textbf{x}_0+\frac{k_1}{2},t_0+\frac{h}{2})\\k_3&amp;=&amp;hf(\textbf{x}_0+\frac{k_2}{2},t_0+\frac{h}{2})\\k_4&amp;=&amp;hf(\textbf{x}_0+k_3,t_0+h)\\\textbf{x}(t_0+h)&amp;=&amp;\textbf{x}_0+\frac{1}{6}k_1+\frac{1}{3}k_2+\frac{1}{3}k_3+\frac{1}{6}k_4\]</span> ## Adaptive Stepsizes</p><p>无论我们使用哪种方法，一个核心问题就是步进大小的选择。理想情况我们希望有一个合理的步进尺寸，尽可能的大来减少计算，但不要太大以免带来额外的误差，或者导致函数不稳定。如果我们选择的步长固定，我们只能受限于<span class="math inline">\(\textbf{x}(t)\)</span>最差的区域所允许的步进速度。我们希望的是在随时间变化时动态选择 <spanclass="math inline">\(h\)</span> 。只要我们能使 <spanclass="math inline">\(h\)</span>变大而不产生太多误差，我们就应该这样做。当需要减少 <spanclass="math inline">\(h\)</span>以避免过多的误差时，我们也想这样做。这就是自适应步进调整的思想：在求解ODE的过程中改变<span class="math inline">\(h\)</span> 。<br />在这里，我们将介绍欧拉方法的自适应步长。其基本思想如下。假设我们有一个给定的步长<spanclass="math inline">\(h\)</span>，我们想知道我们可以考虑改变多少步长。<br />假设我们计算 <span class="math inline">\(\textbf{x}(t_0 + h)\)</span>的两个估计值。我们计算一个估计值 <spanclass="math inline">\(\textbf{x}_a\)</span> ，一个欧拉步进，步进大小为<span class="math inline">\(h\)</span>，范围从 <spanclass="math inline">\(t_0\)</span> 到 <spanclass="math inline">\(t_0+h\)</span> ，再计算另一个估计值 <spanclass="math inline">\(\textbf{x}_b\)</span> ，两次欧拉步进，其步进大小为<span class="math inline">\(\frac{h}{2}\)</span>，范围从 <spanclass="math inline">\(t_0\)</span> 到 <spanclass="math inline">\(t_0+h\)</span> 。<spanclass="math inline">\(\textbf{x}_a\)</span> 和 <spanclass="math inline">\(\textbf{x}_b\)</span> 和实际的 <spanclass="math inline">\(\textbf{x}(t_0+h)\)</span> 误差都在 <spanclass="math inline">\(O(h^2)\)</span>，那意味着 <spanclass="math inline">\(\textbf{x}_a\)</span> 和 <spanclass="math inline">\(\textbf{x}_b\)</span> 的差值也在 <spanclass="math inline">\(O(h^2)\)</span>。我们能确定这个正确的误差 <spanclass="math inline">\(e\)</span>：<spanclass="math inline">\(e=|\textbf{x}_a-\textbf{x}_b|\)</span><br />这为我们计算欧拉步长为 <span class="math inline">\(h\)</span>时的误差提供了一个方便的估算值。假设我们希望每步误差为 <spanclass="math inline">\(10^{−4}\)</span>，而当前误差仅为 <spanclass="math inline">\(10^{−8}\)</span>。由于误差是随 <spanclass="math inline">\(h^2\)</span> 变化，所以我们可以提升步长到: <spanclass="math inline">\((\frac{10^{−4}}{10^{−8}})^\frac{1}{2}h=100h\)</span>。相反如果我们实际误差为<span class="math inline">\(10^{-3}\)</span>，我们应降低步进为: <spanclass="math inline">\((\frac{10^{−4}}{10^{-3}})^\frac{1}{2}\approx.316h\)</span>。<br />强烈推荐使用自适应步进。</p><h2 id="implementation">Implementation</h2><p>我们试图解决的常微分方程 (ODE)可能能描述很多问题、情况——比如，一组有质量的物体和弹簧，一些刚体，或者一个可形变的物体。我们希望以一种方式实现ODE的求解器和模型，使得求解器和模型之间相互隔离，不会暴露各自的内部细节。这样能够方便的修改求解器并复用求解器的代码。好消息是这种设计并不难以实现，因为所有求解器都能被表示为一小组标准化操作。可以推测，受常微分方程支配的对象系统会以某种数据结构的形式存在。我们的实现思路是：先编写针对特定类型的代码来操作该数据结构、执行标准操作，再基于这些通用操作来实现求解器。<br />从求解器的视角来看，它所操作的方程组是一个黑盒函数 <spanclass="math inline">\(f(\textbf{x},t)\)</span>。求解器需要能够在 <spanclass="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(t\)</span> 的任意取值下，按需计算 <spanclass="math inline">\(f\)</span> 的值；随后在推进时间步时，将更新后的<span class="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(t\)</span>植入系统。为支持这些操作，代表待求解常微分方程的对象必须能够响应求解器的如下请求：</p><ul><li>返回 <span class="math inline">\(dim(\textbf{x})\)</span> 。因为<span class="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(\dot{\textbf{x}}\)</span>可能是向量，求解器必须知道其长度来分配内存空间，执行向量计算。</li><li>获取、设置 <spanclass="math inline">\(\textbf{x},t\)</span>。求解器需能在时间步结束时植入新值。此外，<strong>多步法</strong>在开展导数计算过程中，必须将<span class="math inline">\(\textbf{x}\)</span> 和 <spanclass="math inline">\(t\)</span> 设置为中间值。</li><li>能计算在当前 <span class="math inline">\(\textbf{x},t\)</span>计算函数 <span class="math inline">\(f\)</span> 值。</li></ul><p>在<strong>面向对象语言</strong>中，这些操作会天然以<strong>通用函数</strong>的形式实现，并通过<strong>类型专属</strong>的方式处理。在<strong>非面向对象语言</strong>中，“通用函数”会通过以下方式模拟：在结构体槽位中植入指向类型专属函数的指针，或直接将函数指针作为参数传递给求解器。稍后我们将详细探讨，这些操作如何在粒子- 弹簧系统等特定模型中落地实现。</p><h2 id="reference">Reference</h2><p><ahref="https://www.cs.cmu.edu/~baraff/sigcourse/index.html">PhysicallyBased Modeling</a></p><p><ahref="https://www.cs.cmu.edu/~baraff/sigcourse/notesb.pdf">DifferentialEquation Basics</a></p><p><a href="https://zhuanlan.zhihu.com/p/109532468">游戏物理引擎(一)刚体动力学 - 知乎</a></p><p><ahref="https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics">VideoGame Physics Tutorial - Part I: Rigid Body Dynamics | Toptal®</a></p><p><a href="https://box2d.org/publications/">Publications ::Box2D</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU Driven And Hierarchical Z-Bufferr</title>
    <link href="/2025/02/23/GPU%20Driven%20And%20Hierarchical%20Z-Buffer/"/>
    <url>/2025/02/23/GPU%20Driven%20And%20Hierarchical%20Z-Buffer/</url>
    
    <content type="html"><![CDATA[<p>关于 GPU Driven And Hierarchical Z-Buffer</p><h1 id="gpu-driven-and-hierarchical-z-buffer">GPU Driven AndHierarchical Z-Buffer</h1><h2 id="hierarchical-z-buffer">Hierarchical Z-Buffer</h2><h3 id="question">Question</h3><p>为什么<strong>遮挡查询</strong>，要2x2的像素。首先我们的做法是把包围盒投影到屏幕空间采样对应等级的Mipmap，那这个投影过程可能就会有精度缺失。如果之采样1个像素就会降低命中率，尤其是我们找寻最高LOD层级才能大概率找到对应的1x1 像素，这命中率是不高的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 SRP Batcher</title>
    <link href="/2025/02/22/%E5%85%B3%E4%BA%8ESRP%20Batcher/"/>
    <url>/2025/02/22/%E5%85%B3%E4%BA%8ESRP%20Batcher/</url>
    
    <content type="html"><![CDATA[<p>关于 SRP Batcher 的理解和内容</p><h1 id="关于-srp-batcher">关于 SRP Batcher</h1><h2 id="shader-和-material">Shader 和 Material</h2><p>首先我们得对 Shader 和 Material 以及渲染过程有一个基础的了解。</p><ul><li>Shader：运行在 <strong>GPU</strong> 上的一段程序， 将输入的 Mesh 和Texture 以及 其他 Properties 进行计算，然后输出结果。<font color= #999999>当然也有利用 GPU 并行能力计算的 Computer Shader主要是做数据计算和处理，比如计算LUT，或者滤波、图像处理等等，这个不是本文重点。</font></li><li>Material：描述(存储) 模型/物体 表面细节信息的资源。 定义外观属性Color，Tex，Smoothness……可以看作是对 Shader的实例。</li></ul><p>材质可以看作是一个配置Shader属性数值的面板。通过修改材质球里的属性数值，实际上就是在修改Shader的属性数值。当我们创建一个材质时，我们实际上是在创建一个Shader的实例。这个实例包含了Shader的所有属性，并且我们可以为这些属性提供具体的值。在Unity中，每个材质都关联了一个Shader。当我们将材质应用到一个物体上时，实际上是在告诉Unity使用这个材质所关联的Shader来渲染这个物体。</p><h2 id="简单的渲染过程">简单的渲染过程</h2><p>就现在的设计，简单来讲渲染物体主要分为四个步骤： 暂时用 DX举例吧，我记不得太多了……</p><ol type="1"><li><p><strong>初始化</strong>：</p><ul><li><p><strong>创建设备</strong> (ID3D11Device) 和<strong>设备上下文</strong>(ID3D11DeviceContext)，以及交换链管理 FrontBuffer 和 Back Buffer</p><p>创建渲染视图并绑定到输出合并阶段。</p></li></ul></li><li><p><strong>设置渲染状态</strong>：</p><ul><li><strong>定义顶点格式和输入布局</strong>：根据需要渲染的几何体定义顶点结构，并创建相应的输入布局（<code>ID3D11InputLayout</code>）描述顶点数据的格式和语义。</li><li><strong>创建顶点和索引缓冲区</strong>：将几何体的顶点数据存储在顶点缓冲区（<code>ID3D11Buffer</code>）中，如果有重复顶点，可以使用索引缓冲区（<code>ID3D11Buffer</code>）来优化内存使用和渲染效率。</li><li><strong>创建着色器</strong>：编写顶点着色器（VertexShader）和像素着色器（PixelShader），并使用<code>D3DCompile</code>函数编译成字节码，然后创建着色器对象（<code>ID3D11VertexShader</code>和<code>ID3D11PixelShader</code>）</li></ul></li><li><p><strong>绘制调用</strong>：</p><ul><li><strong>绑定着色器和常量缓冲区</strong>：将顶点着色器、像素着色器和常量缓冲区绑定到渲染管线的相应阶段。</li><li><strong>设置图元拓扑</strong>：指定要渲染的图元类型，如三角形列表、线列表等。</li><li><strong>设置混合状态、深度/模板状态等</strong>：根据需要设置渲染管线的其他状态，如混合模式、深度测试和模板测试等。</li><li>(可选)进行ClearRenderTargetView</li><li><strong>绘制几何体</strong>：使用<code>DrawIndexed</code>或<code>Draw</code>函数绘制几何体，根据索引缓冲区（如果有）或顶点缓冲区中的数据生成图元，</li><li>重复渲染过程。</li></ul></li><li><p><strong>结果展示</strong>：</p><p>前后帧交替显示渲染结果</p></li></ol><h3 id="一点关于dx的概念不是很重要">一点关于dx的概念，不是很重要……</h3><ul><li><p><code>ID3D11Device</code>接口，它用于创建资源和枚举显示适配器的功能，用以应用程序直接与图形硬件进行交互。</p></li><li><p>设备上下文<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>是设备的一个接口，用于设置管道状态、将资源绑定到图形管线和生成渲染命令。设备上下文在<code>ID3D11DeviceContext</code>接口中实现，它提供了对图形管线的直接控制，允许应用程序执行各种渲染操作。</p><ul><li><strong>即时上下文（ImmediateContext）</strong>：即时上下文直接与图形硬件进行交互，它允许应用程序立即执行渲染命令。每个设备都有一个且只有一个即时上下文。</li><li><strong>延迟上下文（DeferredContext）</strong>：延迟上下文将渲染命令记录到命令列表中，它主要用于多线程渲染。延迟上下文可以由工作线程使用，而即时上下文通常由主线程使用</li></ul></li></ul><h3 id="draw-call">Draw Call</h3><p><strong>Draw Call</strong> 是 CPU 调用图形 API（如 OpenGL 或DirectX）命令 GPU 进行渲染的操作。具体来说，Draw Call 是 CPU 向 GPU发送的绘制命令，告诉 GPU如何渲染场景的一部分，包括使用哪些顶点、纹理、着色器等。</p><h3 id="draw-call-的工作原理">Draw Call 的工作原理</h3><ol type="1"><li><strong>命令缓冲区</strong>：为了实现 CPU 和 GPU的并行工作，需要一个命令缓冲区（CommandBuffer），它包含一个命令队列。CPU 向其中添加命令，GPU从中读取命令并执行。</li><li><strong>Draw Call 命令</strong>：Draw Call 是 <strong>Command Buffer的一种命令</strong>，用于告诉 GPU 进行绘制操作。除了 Draw Call，CommandBuffer 中还有其他命令，如改变渲染状态等。</li><li><strong>CPU 和 GPU 的交互</strong>：CPU 通过图形 API向命令缓冲区添加命令，GPU 从中读取命令并执行。当 CPU需要渲染一个对象时，它会向命令缓冲区添加一个 Draw Call 命令，GPU完成上一个渲染任务后，会从命令缓冲区中取出这个命令并执行。</li></ol><h3 id="为什么-draw-call-多了会影响帧率">为什么 Draw Call多了会影响帧率？</h3><ol type="1"><li><strong>CPU 的准备工作</strong>：在每次调用 Draw Call 之前，CPU需要向 GPU 发送很多内容，包括数据、状态和命令等。CPU需要完成很多准备工作，如数据准备，资源绑定，命令提交，检查渲染状态等。</li><li><strong>GPU 的渲染能力</strong>：GPU的渲染能力很强，渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call的数量太多，CPU 就会把大量时间花费在提交 Draw Call 命令上，造成 CPU的过载。 可以粗浅地理解为 DrawIndexed 或Draw函数就是一次 Draw Call</li><li><strong>性能瓶颈</strong>：由于 CPU 的准备工作和 GPU的渲染能力不匹配，过多的 Draw Call 会导致 CPU成为性能瓶颈，影响帧率。</li></ol><h3 id="如何减少-draw-call">如何减少 Draw Call？</h3><ol type="1"><li><strong>批处理（Batching）</strong>：将多个小的 Draw Call合并成一个大的 Draw Call，减少 CPU 提交 Draw Call 的次数和时间。<ul><li><strong>静态批处理</strong>：适合静态物体，如不会移动的大地、石头等。将这些物体标记为静态，引擎会自动合并网格，减少Draw Call。</li><li><strong>动态批处理</strong>：适合动态物体，引擎每帧都会重新合并网格，但限制较多，如顶点数和着色器复杂度等。</li></ul></li><li><strong>减少材质使用</strong>：相同的材质会方便合并网格，减少 DrawCall。</li><li><strong>GPU 实例化（GPU Instancing）</strong>：将 mesh 信息存储在GPU 内存缓冲区中，并进行渲染而无需额外的 Draw Call。</li><li><strong>减少渲染状态切换</strong>：改变渲染状态比渲染模型更耗时，尽量减少渲染状态切换。</li></ol><h4 id="渲染状态">渲染状态</h4><p><strong>改变渲染状态</strong>是指在图形渲染过程中，通过设置或修改渲染器（如Direct3D或OpenGL）的各种参数，来控制渲染行为和效果的过程。这些参数通常被称为渲染状态，它们定义了渲染器在处理图形数据时的行为方式。</p><h5 id="渲染状态的类型">渲染状态的类型</h5><p>渲染状态有很多种，常见的包括：</p><ol type="1"><li><strong>填充模式（FillMode）</strong>：决定多边形是被填充还是只绘制轮廓。例如，线框模式（Wireframe）只绘制多边形的边框，而实心模式（Solid）会填充整个多边形。</li><li><strong>剔除模式（CullMode）</strong>：决定是否剔除（不渲染）某些面。例如，可以设置为剔除背面（BackfaceCulling），只渲染正面的三角形。</li><li><strong>深度测试（DepthTest）</strong>：决定是否根据深度值（Z值）来决定是否更新像素的颜色。如果开启深度测试，只有当新像素的深度值小于当前像素的深度值时，才会更新像素的颜色。</li><li><strong>混合模式（BlendMode）</strong>：决定如何将新像素的颜色与现有像素的颜色进行混合。例如，可以设置为Alpha混合，根据新像素的Alpha值来决定如何混合颜色。</li><li><strong>模板测试（StencilTest）</strong>：决定是否根据模板缓冲区中的值来决定是否更新像素的颜色。模板缓冲区可以用于实现各种高级渲染效果，如阴影、轮廓等。</li><li><strong>光照模式（LightingMode）</strong>：决定是否使用光照计算，以及如何计算光照。</li><li><strong>纹理过滤器（TextureFilter）</strong>：决定如何对纹理进行采样和过滤，以获得更好的图像质量。例如，可以设置为线性过滤（LinearFiltering）或各向异性过滤（Anisotropic Filtering）</li></ol><h2 id="unity-and-material">Unity And Material</h2><p><img src="/imgs/关于SRP Batcher/OldMaterial.jpg"> CPU 收集 Material信息，设置 CBUFFER</p><h2 id="srp-batcher">SRP Batcher</h2><p><img src="/imgs/关于SRP Batcher/SRPPipeline.jpg">在渲染循环里把材质信息保留在 GPU 内存中，只有材质内容改变才会重新 setupmaterial data。 在此流程中，CPU仅负责处理内置引擎属性（如<em>对象矩阵变换</em>）。所有材质的 CBUFFER均以持久化形式驻留在 GPU 内存中，随时可供调用。</p><ol type="1"><li><strong>材质数据持久化存储于 GPU内存</strong>，若材质内容未发生变更，则无需重复配置和上传缓冲区至GPU，显著减少数据传输开销。</li><li><strong>专用代码管理全局「按对象」GPU常量缓冲区</strong>，通过独立优化的代码路径，高效更新 GPU中存储大规模对象相关数据（如内置属性）的 CBUFFER，进一步降低 CPU-GPU通信负载。</li></ol><p><img src="/imgs/关于SRP Batcher/SRPPipeline2.jpg"> 左图为标准的SRP（可编程渲染管线）渲染循环，右图为 SRP Batcher 的渲染循环。在 SRPBatcher 的机制中，一个“批次”仅由连续的<code>Bind</code>（绑定资源）、<code>Draw</code>（绘制）、<code>Bind</code>、<code>Draw</code>...等 GPU 命令序列构成。</p><p><strong>SRP Batcher 的核心优化逻辑</strong>：</p><ul><li><strong>不减少 DrawCall 数量</strong> SRP Batcher 并不会直接降低DrawCall 的总数，其优化重点在于 <strong>减少 DrawCall 之间的 GPU资源设置开销</strong>。</li><li><strong>通过持久化与批次合并降低开销</strong> 借助材质数据在 GPU内存中的持久化存储，以及针对同着色器变体的批次合并机制，大幅减少重复的资源绑定与状态切换操作，从而提升整体渲染效率。</li></ul><h3 id="补充">补充</h3><h4 id="per-object-变量">“Per Object” 变量</h4><p><img src="/imgs/关于SRP Batcher/SRPPerObject.jpg"></p><h2 id="关于">关于</h2><ul><li></li></ul><section id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p><ahref="https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-devices-intro">Direct3D11 中的设备简介 - Win32 apps | Microsoft Learn</a><a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    
    <tags>
      
      <tag>渲染</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刀光特效果</title>
    <link href="/2024/05/01/%E5%88%80%E5%85%89%E7%89%B9%E6%95%88/"/>
    <url>/2024/05/01/%E5%88%80%E5%85%89%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>Unity 下实现的 刀光特效，但是主要是shader，所以可以用于其他引擎。</p><span id="more"></span><h1 id="刀光特效">刀光特效</h1><h2 id="shader">shader</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">Shader &quot;MyShader/Dao Guang&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        //_CopyColorRT (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        [HDR]_MainColor(&quot;Main Color&quot;, Color) = (1,1,1,1)<br>        _Alpha(&quot;Alpha Val&quot;, Range(0,1)) = 0.1<br>        _FlowVal(&quot;Flow Val&quot;, Range(0.0,1)) = 0<br>        _FadeInTime(&quot;Fade In Time&quot;, Range(0,0.5)) = 0<br>        _FadeOutKey(&quot;Fade Out Key&quot;, Range(0.0,1)) = 1<br>        _FadeOutTime(&quot;Fade Out Time&quot;, Range(0,1)) = 0.1<br>        [HDR]_FlowSpecularColor(&quot;Flow Specular Color&quot;, Color) = (1,1,1,1)<br>        [HDR]_NoiseColor(&quot;Noise Color&quot;, Color) = (1,1,1,1)<br>        [Toggle]_ReverseDir(&quot;Reverse Dir&quot;, Int) = 0<br>        <br>        [Header(Option)]<br>        [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  (&quot;BlendOp&quot;, Float) = 0<br>        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, Float) = 1<br>        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;DstBlend&quot;, Float) = 0<br>        [Enum(Off, 0, On, 1)]_ZWriteMode (&quot;ZWriteMode&quot;, float) = 1<br>        [Enum(UnityEngine.Rendering.CullMode)]_CullMode (&quot;CullMode&quot;, float) = 2<br>        [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (&quot;ZTestMode&quot;, Float) = 4<br>        //[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (&quot;ColorMask&quot;, Float) = 15<br><br>        //[Header(Stencil)]<br>        //[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (&quot;Stencil Comparison&quot;, Float) = 8<br>        //[IntRange]_StencilWriteMask (&quot;Stencil Write Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_StencilReadMask (&quot;Stencil Read Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_Stencil (&quot;Stencil ID&quot;, Range(0,255)) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilPass (&quot;Stencil Pass&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilFail (&quot;Stencil Fail&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail (&quot;Stencil ZFail&quot;, Float) = 0<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags<br>        &#123; <br>            &quot;RenderType&quot;=&quot;Transparent&quot;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>        &#125;<br>        <br>        ZWrite [_ZWriteMode]<br>        ZTest [_ZTestMode]<br>        BlendOp [_BlendOp]<br>        Blend [_SrcBlend] [_DstBlend]<br>        Pass<br>        &#123;<br>            Name &quot;Alpha Clip&quot;<br>            Tags <br>            &#123; <br>                //&quot;LightMode&quot; = &quot;UniversalForward&quot;<br>                &quot;LightMode&quot; = &quot;UniversalForward&quot;<br>            &#125;<br><br>            HLSLPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;<br><br>            struct appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f<br>            &#123;<br>                float2 uv : TEXCOORD0;<br>                float4 vertex : SV_POSITION;<br>            &#125;;<br><br>            //SAMPLER(sampler_ScreenOffRT);<br>            //TEXTURE2D(_ScreenOffRT);<br>            //float4 _ScreenOffRT_ST;<br><br>            CBUFFER_START(UnityPerMaterial)<br>                SAMPLER(sampler_MainTex);<br>                TEXTURE2D(_MainTex);<br>                float4 _MainTex_ST, _MainColor;<br>                float4 _FlowSpecularColor, _NoiseColor;<br>                float _Alpha, _FlowVal, _FadeInTime;<br>                float _FadeOutKey, _FadeOutTime;<br>                int _ReverseDir;<br>            CBUFFER_END<br><br>            v2f vert (appdata v)<br>            &#123;<br>                v2f o;<br>                o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);<br>                o.uv = TRANSFORM_TEX(v.uv,_MainTex);<br>                return o;<br>            &#125;<br><br>            half4 frag (v2f i) : SV_Target<br>            &#123;<br>                // sample the texture<br>                float flowUV = i.uv.x;<br>                if(_ReverseDir != 0)<br>                    flowUV = 1 - flowUV;<br>                //float val = i.uv.x;<br>                flowUV = flowUV + _FlowVal;<br>                float alphaFade = clamp((_FlowVal / _FadeInTime), 0 ,1);<br>                //flowUV *= _FlowVal;<br><br>                half4 mainCol = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(flowUV,i.uv.y));<br>                float alpha = alphaFade * mainCol.a;<br>                alpha *= 1 - clamp( (_FlowVal - _FadeOutKey) / _FadeOutTime, 0, 1);<br>                clip(_Alpha - mainCol.a);<br>                <br>                float3 col = _FlowSpecularColor * mainCol.g;<br>                col += mainCol.r * _MainColor;<br>                col += _NoiseColor * mainCol.b;<br>                return half4(col, alpha);<br>                //return col * flowUV * alphaValByFlow;// * _FlowSpecularColor;<br>            &#125;<br><br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主要思路就根据 uv.x 做渐入渐出和透明度的调整。</p>]]></content>
    
    
    
    <tags>
      
      <tag>特效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于透视矫正插值</title>
    <link href="/2024/04/14/%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC/"/>
    <url>/2024/04/14/%E5%85%B3%E4%BA%8E%E9%80%8F%E8%A7%86%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>把之前推导计算的透视矫正插值记录一下</p><span id="more"></span><h1 id="透视矫正插值">透视矫正插值</h1><p>首先我们要知道从 “<strong>顶点着色器</strong>” 到“<strong>片元着色器</strong>” 需要经过“<strong>光栅化(Rasterization)</strong>”而光栅化做的就是把三角形离散为一个一个片元，如果是对于一个三角形而言，我们能够通过重心坐标表示其中任意一点。</p><h2 id="重心坐标">重心坐标</h2><p>设有三角形 ABC，及内一点P</p><p>所谓重心坐标就是，三角形内一点可以写作 <span class="math display">\[P=\alpha A+\beta B+\gamma C\]</span> 如果 <span class="math inline">\((\alpha +\beta+\gamma)==1\)</span> 则点 <strong>P</strong> 在三角形内。</p><ul><li><p>为什么能用重心坐标表示一个点?</p></li><li><p>因为假设一个点P在一条直线上，取直线上两点 AB， P点的位置一定能由<span class="math inline">\(P=\alpha A+\beta B\)</span> 表示，并且<spanclass="math inline">\(\alpha+\beta==1\)</span>则 P 在 AB 之间。 而三角形重心坐标 可以看作 先在 AB上寻找一点 <spanclass="math inline">\(D=\alpha_1 A+\beta_1 B\)</span>, 而 点P 在线 CD上，有 <span class="math inline">\(P = \alpha_2D+\gammaC\)</span>.</p></li></ul><h3 id="屏幕坐标和ndc空间坐标">屏幕坐标和NDC空间坐标</h3><p>如何从 MVP 的 Vertex 到 ScreenPos</p><p>NDC 是GPU为了方便图像处理的空间，x-&gt;[0,1] y-&gt;[0,1]z-&gt;[-1,1]/[0,1] xy是线性变化，其实还好，问题关键在于z</p><h3 id="mvp-变换">MVP 变换</h3><p>M 是 Object 自己的变化</p><p>V 是 camra forwardVec 和 UpVec，推导rightVec，根据正交矩阵性质，转置就是其逆</p><p>P 是 View 到 ClipSpace， ClipSpace 后再经过齐次除法到 NDC 空间。</p><p>再NDC空间后再进行光栅化。</p><h4 id="projection-matrix">Projection Matrix</h4><p><span class="math display">\[\begin{bmatrix}\frac{near}{wid}&amp;0&amp;0&amp;0\\0&amp;\frac{near}{height}&amp;0&amp;0\\0&amp;0&amp;\frac{far}{near-far}&amp;\frac{near\cdot far}{near-far}\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\]</span></p><p>其实矩阵变换是线性的，问题在于后面的齐次除法</p><h2 id="screen-插值">Screen 插值</h2><p>我们首先要保证的是 Screen 上的点插值是正确的<br />因为我们只会对顶点进行齐次除法，而我们对于点P进行重心坐标插值时，三角形ABC都是经过齐次除法的，这没有问题，但是顶点中其他数据比如UV这种是没有经过齐次除法的。<br />所以根据屏幕点P的重心坐标，求经过矫正的插值：</p><p><span class="math display">\[\begin{aligned}    &amp;设屏幕上三角形点A_s、B_s、C_s\\    &amp;屏幕上三角形内一点P_s\\    &amp;对于点XY坐标而言有：\\    &amp;P_s = \alpha A_s+\beta B_s+\gamma C_s\\    &amp;因为屏幕空间的点都是经过齐次除法的，且 Z值是能够从[0,1]反向计算得到的\\    &amp;\frac{P_p}{z_P}= \alpha \frac{A_p}{z_A}+\beta\frac{B_p}{z_B}+\gamma \frac{C_p}{z_C}\\\\    &amp; \textbf{我们已知} A_s、B_s、C_s和点P_s;\\\\    &amp;也就是说P_s是Clip\;Space的P_p投影变换得到\\    &amp;P_p =z_p( \alpha \frac{A_p}{z_A}+\beta \frac{B_p}{z_B}+\gamma\frac{C_p}{z_C})    \\    &amp;且P_p,P_s \;都在\; \triangle ABC内\\    &amp; \alpha+\beta+\gamma=1\\    &amp;z_p( \frac{\alpha}{z_A}+\frac{\beta}{z_B}+\frac{\gamma}{z_C})=1\\\end{aligned}\]</span></p><p>所以能得到根据矫正插值和屏幕XY坐标计算的插值关系</p><p><span class="math display">\[\begin{aligned}    &amp;\frac{z_p\alpha}{z_A}=\alpha_p,\;\frac{z_p\beta}{z_B}=\beta_p,    \frac{z_p\gamma}{z_C}=\gamma_p\\    &amp;P_p=\alpha_pA_p+\beta_pB_p+\gamma_pC_p\\    &amp;但是z_p是未知的\\    &amp;\frac{\alpha_p}{\beta_p}=\frac{\alpha z_B}{\beta z_A}\\    &amp;得\;\;\alpha_p=\frac{\alpha z_B}{\beta z_A}\beta_p\\    &amp;所以\;\;\gamma_p=\frac{\gamma z_B}{\beta z_C}\beta_p\\    &amp;(\frac{\alpha z_B}{\beta z_A}+\frac{\gamma z_B}{\betaz_C}+1)\beta_p=1\\\end{aligned}\]</span></p><p>能够得到透视矫正插值</p><p><span class="math display">\[\begin{aligned}(\frac{\alpha z_Bz_C+\gamma z_Az_B + \beta z_Az_C}{\betaz_Az_C})\beta_p=1\\\beta_p=\frac{\beta z_Az_C}{\alpha z_Bz_C+\gamma z_Az_B + \betaz_Az_C}\\\alpha_p=\frac{\alpha z_Bz_C}{\alpha z_Bz_C+\gamma z_Az_B + \betaz_Az_C}\\\gamma_p=\frac{\gamma z_Az_B}{\alpha z_Bz_C+\gamma z_Az_B + \betaz_Az_C}\\\end{aligned}\]</span></p><p>对于 屏幕点P，我们知道其 XY 坐标，但是不知道该点在 ClipSpace的实际位置，所以对于 顶点内数据都要进行透视矫正插值。</p><h2 id="参考">参考</h2><p><ahref="https://matnoble.github.io/tech/latex/multi-line-equations/">Latex多行公式</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 主题变更</title>
    <link href="/2024/01/13/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9/"/>
    <url>/2024/01/13/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p>更换了Hexo 主题，之前 yilia主题作者是不是开摆了……我看很久没更新.<br />nalama！答案只有一个了，我将向你—— Fluid效忠！图源自Pix画师ID:67549695<br /><span id="more"></span></p><h1 id="hexo-主题切换">Hexo 主题切换</h1><p>这里以 yilia 切换到 Fluid为例，我这里只是分享一下自己是怎么做的，遇到什么问题，<br />肯定有不对的地方，欢迎大家教我。</p><h2 id="准备工作">准备工作</h2><p>鉴于前面我自己把 blog 干崩过，所有我强烈建议所有人都在 github存一个仓库备份本地的 Blog<br />因为 Hexo 这种静态blog<strong>本地磁盘的源文件</strong>和<strong>生成的网页</strong>，是两个部分。</p><p>你能不能说人话什么本地，网页的！<br />好好好，你先别急，我知道你很急，但是你先别急。</p><ul><li>本地的源文件：<br /><img src="/imgs/Hexo主题变更/deskt.png" /><br /></li><li>生成的网页：<br /><img src="/imgs/Hexo主题变更/web.png" /> 我们可以将本地文件存储到 github备份，也方便 fallback 和 迁移。</li></ul><h2 id="切换">切换</h2><p>将 Hexo 博客主题从 yilia 切换到 Fluid 的步骤如下：</p><ol type="1"><li><p>首先，您需要在本地安装 Fluid 主题。<br />可以使用以下命令从 GitHub 上下载 Fluid 主题并将其保存到您的 Hexo 博客的themes 文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid  <br></code></pre></td></tr></table></figure></li><li><p>下载完成后，进入 Hexo 博客的根目录，并打开 _config.yml文件。<br />将 theme 字段的值更改为 "fluid"，如下所示：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <br></code></pre></td></tr></table></figure></li></ol><h3 id="修改主题配置">修改主题配置</h3><p>主题配置指的是 hexo 所采用的 theme 所用配置，而并非对 Hexo blog的配置</p><blockquote><p>TIP<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Hexo Fulid 官方Doc](https://hexo.fluid-dev.com/docs)">[1]</span></a></sup></p><p>致主题的新用户：</p><ul><li>本指南经过数个版本打磨，<br />绝大部分的功能都有详细说明，请仔细阅读，节约自己和他人的时间；<br /></li><li>本指南中提到的："<strong>站点配置</strong>" 指的 Hexo 博客目录下的<code>_config.yml</code>，"<strong>主题配置</strong>" 指的是<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>，注意区分；<br /></li><li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>目录；<br /></li><li>每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用<code>hexo clean</code> 清除本地缓存；<br /></li><li>页面结果以本地 <code>hexo s</code>为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常；<br /></li><li>由于主题的不同版本会存在配置差异，本指南以最新版本为准。</li></ul></blockquote><p>这里按照官方文档所说去做就行，为什么这么配文档也有说，我这里是 Hexo6.1.0。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#覆盖配置)">[2]</span></a></sup><br />所以在Blog 根目录创建 <code>_config.fluid.yml</code><br /><img src="/imgs/Hexo主题变更/Fluid_Config.png" /><br />然后在该文件内，粘贴 Fluid官方给定的配置<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[主题配置](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)">[3]</span></a></sup>就行，当然你可以根据他的自定义，<br />但是我不会，因为我不会……</p><h4id="code建议别从我这里复制这个blog会崩溃去官网吧5">code，建议别从我这里复制，这个blog会崩溃，去官网吧<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[hexo-theme-fluid/_config.yml at master · fluid-dev/hexo-theme-fluid (github.com)](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)">[5]</span></a></sup></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># Hexo Theme Fluid</span><br><span class="hljs-comment"># Author: Fluid-dev</span><br><span class="hljs-comment"># Github: https://github.com/fluid-dev/hexo-theme-fluid</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 配置指南: https://hexo.fluid-dev.com/docs/guide/</span><br><span class="hljs-comment"># 你可以从指南中获得更详细的说明</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Guide: https://hexo.fluid-dev.com/docs/en/guide/</span><br><span class="hljs-comment"># You can get more detailed help from the guide</span><br><span class="hljs-comment">#---------------------------</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 全局</span><br><span class="hljs-comment"># Global</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># 用于浏览器标签的图标</span><br><span class="hljs-comment"># Icon for browser tab</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/fluid.png</span><br><br><span class="hljs-comment"># 用于苹果设备的图标</span><br><span class="hljs-comment"># Icon for Apple touch</span><br><span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/img/fluid.png</span><br><br><span class="hljs-comment"># 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名</span><br><span class="hljs-comment"># Title separator in browser tab, eg: article - site</span><br><span class="hljs-attr">tab_title_separator:</span> <span class="hljs-string">&quot; - &quot;</span><br><br><span class="hljs-comment"># 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）</span><br><span class="hljs-comment"># Force all links to be HTTPS (applicable to HTTP mixed error)</span><br><span class="hljs-attr">force_https:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 代码块的增强配置</span><br><span class="hljs-comment"># Enhancements to code blocks</span><br><span class="hljs-attr">code:</span><br>  <span class="hljs-comment"># 是否开启复制代码的按钮</span><br>  <span class="hljs-comment"># Enable copy code button</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 代码语言</span><br>  <span class="hljs-comment"># Code language</span><br>  <span class="hljs-attr">language:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">default:</span> <span class="hljs-string">&quot;TEXT&quot;</span><br><br>  <span class="hljs-comment"># 代码高亮</span><br>  <span class="hljs-comment"># Code highlight</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 代码块是否显示行号</span><br>    <span class="hljs-comment"># If true, the code block display line numbers</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 实现高亮的库，对应下面的设置</span><br>    <span class="hljs-comment"># Highlight library</span><br>    <span class="hljs-comment"># Options: highlightjs | prismjs</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-comment"># 在链接中挑选 style 填入</span><br>      <span class="hljs-comment"># Select a style in the link</span><br>      <span class="hljs-comment"># See: https://highlightjs.org/static/demo/</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;github gist&quot;</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span><br><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-comment"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><br>      <span class="hljs-comment"># Select the style button on the right side of the link page, you can also set the CSS link</span><br>      <span class="hljs-comment"># See: https://prismjs.com/</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;tomorrow night&quot;</span><br><br>      <span class="hljs-comment"># 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><br>      <span class="hljs-comment"># If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 一些好玩的功能</span><br><span class="hljs-comment"># Some fun features</span><br><span class="hljs-attr">fun_features:</span><br>  <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>  <span class="hljs-comment"># Typing animation for subtitle</span><br>  <span class="hljs-attr">typing:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 打印速度，数字越大越慢</span><br>    <span class="hljs-comment"># Typing speed, the larger the number, the slower</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span><br><br>    <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-comment"># Cursor character</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span><br><br>    <span class="hljs-comment"># 是否循环播放效果</span><br>    <span class="hljs-comment"># If true, loop animation</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 在指定页面开启，不填则在所有页面开启</span><br>    <span class="hljs-comment"># Enable in specified page, all pages by default</span><br>    <span class="hljs-comment"># Options: home | post | tag | category | about | links | page | 404</span><br>    <span class="hljs-attr">scope:</span> []<br><br>  <span class="hljs-comment"># 为文章内容中的标题添加锚图标</span><br>  <span class="hljs-comment"># Add an anchor icon to the title on the post page</span><br>  <span class="hljs-attr">anchorjs:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">element:</span> <span class="hljs-string">h1,h2,h3,h4,h5,h6</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br>    <span class="hljs-comment"># Options: hover | always | touch</span><br>    <span class="hljs-attr">visible:</span> <span class="hljs-string">hover</span><br>    <span class="hljs-comment"># Options: § | # | ❡</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-comment"># 加载进度条</span><br>  <span class="hljs-comment"># Progress bar when loading</span><br>  <span class="hljs-attr">progressbar:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">height_px:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#29d&quot;</span><br>    <span class="hljs-comment"># See: https://github.com/rstacruz/nprogress</span><br>    <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">showSpinner:</span> <span class="hljs-literal">false</span>, <span class="hljs-attr">trickleSpeed:</span> <span class="hljs-number">100</span> &#125;<br><br><span class="hljs-comment"># 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换</span><br><span class="hljs-comment"># Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor&#x27;s browser will store his switch option</span><br><span class="hljs-attr">dark_mode:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式</span><br>  <span class="hljs-comment"># Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time</span><br>  <span class="hljs-comment"># Options: auto | light | dark</span><br>  <span class="hljs-attr">default:</span> <span class="hljs-string">auto</span><br><br><span class="hljs-comment"># 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发</span><br><span class="hljs-comment"># Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below</span><br><span class="hljs-comment"># See: https://www.webdesignrankings.com/resources/lolcolors/</span><br><span class="hljs-attr">color:</span><br>  <span class="hljs-comment"># body 背景色</span><br>  <span class="hljs-comment"># Color of body background</span><br>  <span class="hljs-attr">body_bg_color:</span> <span class="hljs-string">&quot;#eee&quot;</span><br>  <span class="hljs-comment"># 暗色模式下的 body 背景色，下同</span><br>  <span class="hljs-comment"># Color in dark mode, the same below</span><br>  <span class="hljs-attr">body_bg_color_dark:</span> <span class="hljs-string">&quot;#181c27&quot;</span><br><br>  <span class="hljs-comment"># 顶部菜单背景色</span><br>  <span class="hljs-comment"># Color of navigation bar background</span><br>  <span class="hljs-attr">navbar_bg_color:</span> <span class="hljs-string">&quot;#2f4154&quot;</span><br>  <span class="hljs-attr">navbar_bg_color_dark:</span> <span class="hljs-string">&quot;#1f3144&quot;</span><br><br>  <span class="hljs-comment"># 顶部菜单字体色</span><br>  <span class="hljs-comment"># Color of navigation bar text</span><br>  <span class="hljs-attr">navbar_text_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">navbar_text_color_dark:</span> <span class="hljs-string">&quot;#d0d0d0&quot;</span><br><br>  <span class="hljs-comment"># 副标题字体色</span><br>  <span class="hljs-comment"># Color of navigation bar text</span><br>  <span class="hljs-attr">subtitle_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">subtitle_color_dark:</span> <span class="hljs-string">&quot;#d0d0d0&quot;</span><br><br>  <span class="hljs-comment"># 全局字体色</span><br>  <span class="hljs-comment"># Color of global text</span><br>  <span class="hljs-attr">text_color:</span> <span class="hljs-string">&quot;#3c4858&quot;</span><br>  <span class="hljs-attr">text_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 全局次级字体色（摘要、简介等位置）</span><br>  <span class="hljs-comment"># Color of global secondary text (excerpt, introduction, etc.)</span><br>  <span class="hljs-attr">sec_text_color:</span> <span class="hljs-string">&quot;#718096&quot;</span><br>  <span class="hljs-attr">sec_text_color_dark:</span> <span class="hljs-string">&quot;#a7a9ad&quot;</span><br><br>  <span class="hljs-comment"># 主面板背景色</span><br>  <span class="hljs-comment"># Color of main board</span><br>  <span class="hljs-attr">board_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">board_color_dark:</span> <span class="hljs-string">&quot;#252d38&quot;</span><br><br>  <span class="hljs-comment"># 文章正文字体色</span><br>  <span class="hljs-comment"># Color of post text</span><br>  <span class="hljs-attr">post_text_color:</span> <span class="hljs-string">&quot;#2c3e50&quot;</span><br>  <span class="hljs-attr">post_text_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 文章正文字体色（h1 h2 h3...）</span><br>  <span class="hljs-comment"># Color of Article heading (h1 h2 h3...)</span><br>  <span class="hljs-attr">post_heading_color:</span> <span class="hljs-string">&quot;#1a202c&quot;</span><br>  <span class="hljs-attr">post_heading_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 文章超链接字体色</span><br>  <span class="hljs-comment"># Color of post link</span><br>  <span class="hljs-attr">post_link_color:</span> <span class="hljs-string">&quot;#0366d6&quot;</span><br>  <span class="hljs-attr">post_link_color_dark:</span> <span class="hljs-string">&quot;#1589e9&quot;</span><br><br>  <span class="hljs-comment"># 超链接悬浮时字体色</span><br>  <span class="hljs-comment"># Color of link when hovering</span><br>  <span class="hljs-attr">link_hover_color:</span> <span class="hljs-string">&quot;#30a9de&quot;</span><br>  <span class="hljs-attr">link_hover_color_dark:</span> <span class="hljs-string">&quot;#30a9de&quot;</span><br><br>  <span class="hljs-comment"># 超链接悬浮背景色</span><br>  <span class="hljs-comment"># Color of link background when hovering</span><br>  <span class="hljs-attr">link_hover_bg_color:</span> <span class="hljs-string">&quot;#f8f9fa&quot;</span><br>  <span class="hljs-attr">link_hover_bg_color_dark:</span> <span class="hljs-string">&quot;#364151&quot;</span><br><br>  <span class="hljs-comment"># 分隔线和表格边线的颜色</span><br>  <span class="hljs-comment"># Color of horizontal rule and table border</span><br>  <span class="hljs-attr">line_color:</span> <span class="hljs-string">&quot;#eaecef&quot;</span><br>  <span class="hljs-attr">line_color_dark:</span> <span class="hljs-string">&quot;#435266&quot;</span><br><br>  <span class="hljs-comment"># 滚动条颜色</span><br>  <span class="hljs-comment"># Color of scrollbar</span><br>  <span class="hljs-attr">scrollbar_color:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br>  <span class="hljs-attr">scrollbar_color_dark:</span> <span class="hljs-string">&quot;#687582&quot;</span><br>  <span class="hljs-comment"># 滚动条悬浮颜色</span><br>  <span class="hljs-comment"># Color of scrollbar when hovering</span><br>  <span class="hljs-attr">scrollbar_hover_color:</span> <span class="hljs-string">&quot;#a6a6a6&quot;</span><br>  <span class="hljs-attr">scrollbar_hover_color_dark:</span> <span class="hljs-string">&quot;#9da8b3&quot;</span><br><br>  <span class="hljs-comment"># 按钮背景色</span><br>  <span class="hljs-comment"># Color of button</span><br>  <span class="hljs-attr">button_bg_color:</span> <span class="hljs-string">&quot;transparent&quot;</span><br>  <span class="hljs-attr">button_bg_color_dark:</span> <span class="hljs-string">&quot;transparent&quot;</span><br>  <span class="hljs-comment"># 按钮悬浮背景色</span><br>  <span class="hljs-comment"># Color of button when hovering</span><br>  <span class="hljs-attr">button_hover_bg_color:</span> <span class="hljs-string">&quot;#f2f3f5&quot;</span><br>  <span class="hljs-attr">button_hover_bg_color_dark:</span> <span class="hljs-string">&quot;#46647e&quot;</span><br><br><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-comment"># Font</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br><br><span class="hljs-comment"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span><br><span class="hljs-comment"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span><br><span class="hljs-attr">custom_js:</span><br><br><span class="hljs-comment"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span><br><span class="hljs-comment"># The usage is the same as custom_js</span><br><span class="hljs-attr">custom_css:</span><br><br><span class="hljs-comment"># 网页访问统计</span><br><span class="hljs-comment"># Analysis of website visitors</span><br><span class="hljs-attr">web_analytics:</span>  <span class="hljs-comment"># 网页访问统计</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># 遵循访客浏览器&quot;请勿追踪&quot;的设置，如果开启则不统计其访问</span><br>  <span class="hljs-comment"># Follow the &quot;Do Not Track&quot; setting of the visitor&#x27;s browser</span><br>  <span class="hljs-comment"># See: https://www.w3.org/TR/tracking-dnt/</span><br>  <span class="hljs-attr">follow_dnt:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串</span><br>  <span class="hljs-comment"># Baidu analytics, get the string behind `hm.js?`</span><br>  <span class="hljs-comment"># See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376</span><br>  <span class="hljs-attr">baidu:</span><br><br>  <span class="hljs-comment"># Google Analytics 4 的媒体资源 ID</span><br>  <span class="hljs-comment"># Google Analytics 4 MEASUREMENT_ID</span><br>  <span class="hljs-comment"># See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article</span><br>  <span class="hljs-attr">google:</span><br>    <span class="hljs-attr">measurement_id:</span><br><br>  <span class="hljs-comment"># 腾讯统计的 H5 App ID，开启高级功能才有cid</span><br>  <span class="hljs-comment"># Tencent analytics, set APP ID</span><br>  <span class="hljs-comment"># See: https://mta.qq.com/h5/manage/ctr_app_manage</span><br>  <span class="hljs-attr">tencent:</span><br>    <span class="hljs-attr">sid:</span><br>    <span class="hljs-attr">cid:</span><br><br>  <span class="hljs-comment"># 51.la 站点统计 ID</span><br>  <span class="hljs-comment"># 51.la analytics</span><br>  <span class="hljs-comment"># See: https://www.51.la/user/site/index</span><br>  <span class="hljs-attr">woyaola:</span>  <span class="hljs-comment"># 51.la 站点统计 ID，参见</span><br><br>  <span class="hljs-comment"># 友盟/cnzz 站点统计 web_id</span><br>  <span class="hljs-comment"># cnzz analytics</span><br>  <span class="hljs-comment"># See: https://web.umeng.com/main.php?c=site&amp;a=show</span><br>  <span class="hljs-attr">cnzz:</span><br><br>  <span class="hljs-comment"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>  <span class="hljs-comment"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span><br>  <span class="hljs-attr">leancloud:</span><br>    <span class="hljs-attr">app_id:</span><br>    <span class="hljs-attr">app_key:</span><br>    <span class="hljs-comment"># REST API 服务器地址，国际版不填</span><br>    <span class="hljs-comment"># Only the Chinese mainland users need to set</span><br>    <span class="hljs-attr">server_url:</span><br>    <span class="hljs-comment"># 统计页面时获取路径的属性</span><br>    <span class="hljs-comment"># Get the attribute of the page path during statistics</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>    <span class="hljs-comment"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class="hljs-comment"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class="hljs-attr">ignore_local:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载</span><br><span class="hljs-comment"># Lazy loading of images and comment plugin on the page</span><br><span class="hljs-attr">lazyload:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 加载时的占位图片</span><br>  <span class="hljs-comment"># The placeholder image when loading</span><br>  <span class="hljs-attr">loading_img:</span> <span class="hljs-string">/img/loading.gif</span><br><br>  <span class="hljs-comment"># 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`</span><br>  <span class="hljs-comment"># If true, only enable lazyload on the post page. For custom pages, you can set &#x27;lazyload: true&#x27; in front-matter</span><br>  <span class="hljs-attr">onlypost:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节</span><br>  <span class="hljs-comment"># The factor of viewport height that triggers loading</span><br>  <span class="hljs-attr">offset_factor:</span> <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/</span><br><span class="hljs-comment"># Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/</span><br><span class="hljs-attr">iconfont:</span> <span class="hljs-string">//at.alicdn.com/t/font_1736178_lbnruvf0jn.css</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 页头</span><br><span class="hljs-comment"># Header</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># 导航栏的相关配置</span><br><span class="hljs-comment"># Navigation bar</span><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class="hljs-comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br><br>  <span class="hljs-comment"># 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效</span><br>  <span class="hljs-comment"># Navigation bar frosted glass special animation. It is an experimental feature</span><br>  <span class="hljs-attr">ground_glass:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 模糊像素，只能为数字，数字越大模糊度越高</span><br>    <span class="hljs-comment"># Number of blurred pixel. the larger the number, the higher the blur</span><br>    <span class="hljs-attr">px:</span> <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体</span><br>    <span class="hljs-comment"># Ratio of opacity, 1.0 is completely opaque</span><br>    <span class="hljs-comment"># available: 0 - 1.0</span><br>    <span class="hljs-attr">alpha:</span> <span class="hljs-number">0.7</span><br><br>  <span class="hljs-comment"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br>  <span class="hljs-comment"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>    <span class="hljs-comment">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br><br><span class="hljs-comment"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件</span><br><span class="hljs-comment"># Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files</span><br><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 搜索索引文件的路径，可以是相对路径或外站的绝对路径</span><br>  <span class="hljs-comment"># Path for search index file, it can be a relative path or an absolute path</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/local-search.xml</span><br><br>  <span class="hljs-comment"># 文件生成在本地的位置，必须是相对路径</span><br>  <span class="hljs-comment"># The location where the index file is generated locally, it must be a relative location</span><br>  <span class="hljs-attr">generate_path:</span> <span class="hljs-string">/local-search.xml</span><br><br>  <span class="hljs-comment"># 搜索的范围</span><br>  <span class="hljs-comment"># Search field</span><br>  <span class="hljs-comment"># Options: post | page | all</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br><br>  <span class="hljs-comment"># 搜索是否扫描正文</span><br>  <span class="hljs-comment"># If true, search will scan the post content</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 首屏图片的相关配置</span><br><span class="hljs-comment"># Config of the big image on the first screen</span><br><span class="hljs-attr">banner:</span><br>  <span class="hljs-comment"># 视差滚动，图片与板块会随着屏幕滚动产生视差效果</span><br>  <span class="hljs-comment"># Scrolling parallax</span><br>  <span class="hljs-attr">parallax:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0</span><br>  <span class="hljs-comment"># Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0</span><br>  <span class="hljs-attr">width_height_ratio:</span> <span class="hljs-number">1.0</span><br><br><span class="hljs-comment"># 向下滚动的箭头</span><br><span class="hljs-comment"># Scroll down arrow</span><br><span class="hljs-attr">scroll_down_arrow:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 头图高度不小于指定比例，才显示箭头</span><br>  <span class="hljs-comment"># Only the height of the banner image is greater than the ratio, the arrow is displayed</span><br>  <span class="hljs-comment"># Available: 0 - 100</span><br>  <span class="hljs-attr">banner_height_limit:</span> <span class="hljs-number">80</span><br><br>  <span class="hljs-comment"># 翻页后自动滚动</span><br>  <span class="hljs-comment"># Auto scroll after page turning</span><br>  <span class="hljs-attr">scroll_after_turning_page:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 向顶部滚动的箭头</span><br><span class="hljs-comment"># Scroll top arrow</span><br><span class="hljs-attr">scroll_top_arrow:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Open Graph metadata</span><br><span class="hljs-comment"># See: https://hexo.io/docs/helpers.html#open-graph</span><br><span class="hljs-attr">open_graph:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">twitter_card:</span> <span class="hljs-string">summary_large_image</span><br>  <span class="hljs-attr">twitter_id:</span><br>  <span class="hljs-attr">twitter_site:</span><br>  <span class="hljs-attr">google_plus:</span><br>  <span class="hljs-attr">fb_admins:</span><br>  <span class="hljs-attr">fb_app_id:</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 页脚</span><br><span class="hljs-comment"># Footer</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题</span><br>  <span class="hljs-comment"># HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><br><span class="hljs-string">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><br><span class="hljs-string">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><br><span class="hljs-string">  &#x27;</span><br><br>  <span class="hljs-comment"># 展示网站的 PV、UV 统计数</span><br>  <span class="hljs-comment"># Display website PV and UV statistics</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br>    <span class="hljs-comment"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span><br>    <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br><br>  <span class="hljs-comment"># 国内大陆服务器的备案信息</span><br>  <span class="hljs-comment"># For Chinese mainland website policy, other areas keep disable</span><br>  <span class="hljs-attr">beian:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># ICP证号</span><br>    <span class="hljs-attr">icp_text:</span> <span class="hljs-string">京ICP证123456号</span><br>    <span class="hljs-comment"># 公安备案号，不填则只显示ICP</span><br>    <span class="hljs-attr">police_text:</span> <span class="hljs-string">京公网安备12345678号</span><br>    <span class="hljs-comment"># 公安备案的编号，用于URL跳转查询</span><br>    <span class="hljs-attr">police_code:</span> <span class="hljs-number">12345678</span><br>    <span class="hljs-comment"># 公安备案的图片. 为空时不显示备案图片</span><br>    <span class="hljs-attr">police_icon:</span> <span class="hljs-string">/img/police_beian.png</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 首页</span><br><span class="hljs-comment"># Home Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同</span><br>  <span class="hljs-comment"># Path of Banner image, can be a relative path or an absolute path, the same on other pages</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br><br>  <span class="hljs-comment"># 头图高度，屏幕百分比</span><br>  <span class="hljs-comment"># Height ratio of banner image</span><br>  <span class="hljs-comment"># Available: 0 - 100</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br><br>  <span class="hljs-comment"># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明</span><br>  <span class="hljs-comment"># Opacity of the banner mask, 1.0 is completely opaque</span><br>  <span class="hljs-comment"># Available: 0 - 1.0</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-comment"># Independent config of home page subtitle</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 为空则按 hexo config.subtitle 显示</span><br>    <span class="hljs-comment"># If empty, text based on `subtitle` in hexo config</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;An elegant Material-Design theme for Hexo&quot;</span><br><br>    <span class="hljs-comment"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>    <span class="hljs-comment"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>    <span class="hljs-attr">api:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>      <span class="hljs-comment"># 请求地址</span><br>      <span class="hljs-comment"># Request url</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;&quot;</span><br><br>      <span class="hljs-comment"># 请求方法</span><br>      <span class="hljs-comment"># Request method</span><br>      <span class="hljs-comment"># Available: GET | POST | PUT</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;GET&quot;</span><br><br>      <span class="hljs-comment"># 请求头</span><br>      <span class="hljs-comment"># Request headers</span><br>      <span class="hljs-attr">headers:</span> &#123;&#125;<br><br>      <span class="hljs-comment"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span><br>      <span class="hljs-comment"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span><br>      <span class="hljs-attr">keys:</span> []<br><br>  <span class="hljs-comment"># 自动截取文章摘要</span><br>  <span class="hljs-comment"># Auto extract post</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 打开文章的标签方式</span><br>  <span class="hljs-comment"># The browser tag to open the post</span><br>  <span class="hljs-comment"># Available: _blank | _self</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br><br>  <span class="hljs-comment"># 是否显示文章信息（时间、分类、标签）</span><br>  <span class="hljs-comment"># Meta information of post</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章通过 sticky 排序后，在首页文章标题前显示图标</span><br>  <span class="hljs-comment"># If the posts are sorted by `sticky`, an icon is displayed in front of the post title</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-top&quot;</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 文章页</span><br><span class="hljs-comment"># Post Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">70</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片</span><br>  <span class="hljs-comment"># Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed</span><br>  <span class="hljs-attr">default_index_img:</span><br><br>  <span class="hljs-comment"># 文章标题下方的元信息</span><br>  <span class="hljs-comment"># Meta information below title</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>    <span class="hljs-comment"># Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>    <span class="hljs-comment"># Post date, based on `date` field in front-matter, if not set, based on create date of .md file</span><br>    <span class="hljs-attr">date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>      <span class="hljs-comment"># ISO-8601 date format</span><br>      <span class="hljs-comment"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL a&quot;</span><br><br>    <span class="hljs-comment"># 字数统计</span><br>    <span class="hljs-comment"># Word count</span><br>    <span class="hljs-attr">wordcount:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 估计阅读全文需要的时长</span><br>    <span class="hljs-comment"># Estimated reading time</span><br>    <span class="hljs-attr">min2read:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节</span><br>      <span class="hljs-comment"># Average word length (chars count in word), ZH ≈ 2, EN ≈ 5</span><br>      <span class="hljs-attr">awl:</span> <span class="hljs-number">2</span><br>      <span class="hljs-comment"># 每分钟阅读字数，如果大部分是技术文章可适度调低</span><br>      <span class="hljs-comment"># Words per minute</span><br>      <span class="hljs-attr">wpm:</span> <span class="hljs-number">60</span><br><br>    <span class="hljs-comment"># 浏览量计数</span><br>    <span class="hljs-comment"># Number of visits</span><br>    <span class="hljs-attr">views:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 统计数据来源</span><br>      <span class="hljs-comment"># Data Source</span><br>      <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br><br>  <span class="hljs-comment"># 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）</span><br>  <span class="hljs-comment"># Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)</span><br>  <span class="hljs-attr">updated:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-comment"># ISO-8601 date format</span><br>    <span class="hljs-comment"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>    <span class="hljs-attr">date_format:</span> <span class="hljs-string">&quot;LL a&quot;</span><br><br>    <span class="hljs-comment"># 是否使用相对时间表示，比如：&quot;3 天前&quot;</span><br>    <span class="hljs-comment"># If true, it will be a relative time, such as: &quot;3 days ago&quot;</span><br>    <span class="hljs-attr">relative:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 提示标签类型</span><br>    <span class="hljs-comment"># Note class</span><br>    <span class="hljs-comment"># Options: default | primary | info | success | warning | danger | light</span><br>    <span class="hljs-attr">note_class:</span> <span class="hljs-string">info</span><br><br>  <span class="hljs-comment"># 侧边栏展示当前分类下的文章</span><br>  <span class="hljs-comment"># Sidebar of category</span><br>  <span class="hljs-attr">category_bar:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class="hljs-comment"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br><br>    <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>    <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;title&quot;</span><br><br>    <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class="hljs-attr">post_limit:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 侧边栏展示文章目录</span><br>  <span class="hljs-comment"># Table of contents (TOC) in the sidebar</span><br>  <span class="hljs-attr">toc:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">right</span><br><br>    <span class="hljs-comment"># 目录会选择这些节点作为标题</span><br>    <span class="hljs-comment"># TOC will select these nodes as headings</span><br>    <span class="hljs-attr">headingSelector:</span> <span class="hljs-string">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class="hljs-comment"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class="hljs-attr">collapseDepth:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class="hljs-comment"># Copyright, will be displayed at the end of each post</span><br>  <span class="hljs-attr">copyright:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># CreativeCommons license</span><br>    <span class="hljs-comment"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class="hljs-attr">license:</span> <span class="hljs-string">&#x27;BY&#x27;</span><br><br>    <span class="hljs-comment"># 显示作者</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 显示发布日期</span><br>    <span class="hljs-comment"># Show post date</span><br>    <span class="hljs-attr">post_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>    <span class="hljs-comment"># 显示更新日期</span><br>    <span class="hljs-comment"># Show update date</span><br>    <span class="hljs-attr">update_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>  <span class="hljs-comment"># 文章底部上一篇下一篇功能</span><br>  <span class="hljs-comment"># Link to previous/next post</span><br>  <span class="hljs-attr">prev_next:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片标题</span><br>  <span class="hljs-comment"># Image caption</span><br>  <span class="hljs-attr">image_caption:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片可点击放大</span><br>  <span class="hljs-comment"># Zoom feature of images</span><br>  <span class="hljs-attr">image_zoom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;, &#x27;&#x27;]</span><br>    <span class="hljs-comment"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;,&#x27;&#x27;]</span><br>    <span class="hljs-attr">img_url_replace:</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><br>  <span class="hljs-comment"># 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突</span><br>  <span class="hljs-comment"># Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict</span><br>  <span class="hljs-attr">footnote:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 脚注的节标题，也可以在 front-matter 中通过 `foot<span class="hljs-doctag">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` 这种形式修改单独页面的 header</span><br>    <span class="hljs-comment"># The section title of the footnote, you can also modify the header of a single page in the form of `foot<span class="hljs-doctag">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` in front-matter</span><br>    <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-comment"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br>  <span class="hljs-comment"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>    <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># Options: mathjax | katex</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br>  <span class="hljs-comment"># 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图</span><br>  <span class="hljs-comment"># Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid</span><br>  <span class="hljs-attr">mermaid:</span><br>    <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`</span><br>    <span class="hljs-comment"># If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class="hljs-comment"># If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># See: http://mermaid-js.github.io/mermaid/</span><br>    <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">theme:</span> <span class="hljs-string">&#x27;default&#x27;</span> &#125;<br><br>  <span class="hljs-comment"># 评论插件</span><br>  <span class="hljs-comment"># Comment plugin</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugins</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数</span><br><span class="hljs-comment"># Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># Utterances</span><br><span class="hljs-comment"># 基于 GitHub Issues</span><br><span class="hljs-comment"># Based on GitHub Issues</span><br><span class="hljs-comment"># See: https://utteranc.es</span><br><span class="hljs-attr">utterances:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">issue_term:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">label:</span> <span class="hljs-string">utterances</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">github-light</span><br>  <span class="hljs-attr">theme_dark:</span> <span class="hljs-string">github-dark</span><br><br><span class="hljs-comment"># Disqus</span><br><span class="hljs-comment"># 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs</span><br><span class="hljs-comment"># Based on third-party service</span><br><span class="hljs-comment"># See: https://disqus.com</span><br><span class="hljs-attr">disqus:</span><br>  <span class="hljs-attr">shortname:</span><br>  <span class="hljs-comment"># 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用</span><br>  <span class="hljs-comment"># The following are Disqusjs configurations, please ignore if DisqusJS is not required</span><br>  <span class="hljs-comment"># See: https://github.com/SukkaW/DisqusJS</span><br>  <span class="hljs-attr">disqusjs:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">apikey:</span><br><br><span class="hljs-comment"># Gitalk</span><br><span class="hljs-comment"># 基于 GitHub Issues</span><br><span class="hljs-comment"># Based on GitHub Issues</span><br><span class="hljs-comment"># See: https://github.com/gitalk/gitalk#options</span><br><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">clientID:</span><br>  <span class="hljs-attr">clientSecret:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">owner:</span><br>  <span class="hljs-attr">admin:</span> [<span class="hljs-string">&#x27;name&#x27;</span>]<br>  <span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br>  <span class="hljs-attr">labels:</span> [<span class="hljs-string">&#x27;Gitalk&#x27;</span>]<br>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">pagerDirection:</span> <span class="hljs-string">last</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">createIssueManually:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 默认 proxy 可能会失效，解决方法请见下方链接</span><br>  <span class="hljs-comment"># The default proxy may be invalid, refer to the links for solutions</span><br>  <span class="hljs-comment"># https://github.com/gitalk/gitalk/issues/429</span><br>  <span class="hljs-comment"># https://github.com/Zibri/cloudflare-cors-anywhere</span><br>  <span class="hljs-attr">proxy:</span> <span class="hljs-string">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span><br><br><span class="hljs-comment"># Valine</span><br><span class="hljs-comment"># 基于 LeanCloud</span><br><span class="hljs-comment"># Based on LeanCloud</span><br><span class="hljs-comment"># See: https://valine.js.org/</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span><br>  <span class="hljs-attr">appKey:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">placeholder:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;retro&#x27;</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredFields:</span> []<br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">highlight:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">serverURLs:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">emojiCDN:</span><br>  <span class="hljs-attr">emojiMaps:</span><br>  <span class="hljs-attr">enableQQ:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 畅言 Changyan</span><br><span class="hljs-comment"># 基于第三方的服务</span><br><span class="hljs-comment"># Based on third-party service, insufficient support for regions outside China</span><br><span class="hljs-comment"># http://changyan.kuaizhan.com</span><br><span class="hljs-attr">changyan:</span><br>  <span class="hljs-attr">appid:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">appkey:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># 来必力 Livere</span><br><span class="hljs-comment"># 基于第三方的服务</span><br><span class="hljs-comment"># Based on third-party service</span><br><span class="hljs-comment"># See: https://www.livere.com</span><br><span class="hljs-attr">livere:</span><br>  <span class="hljs-attr">uid:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># Remark42</span><br><span class="hljs-comment"># 需要自托管服务端</span><br><span class="hljs-comment"># Based on self-hosted service</span><br><span class="hljs-comment"># See: https://remark42.com</span><br><span class="hljs-attr">remark42:</span><br>  <span class="hljs-attr">host:</span><br>  <span class="hljs-attr">site_id:</span><br>  <span class="hljs-attr">max_shown_comments:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">locale:</span> <span class="hljs-string">zh</span><br>  <span class="hljs-attr">components:</span> [<span class="hljs-string">&#x27;embed&#x27;</span>]<br><br><span class="hljs-comment"># Twikoo</span><br><span class="hljs-comment"># 支持腾讯云、Vercel、Railway 等多种平台部署</span><br><span class="hljs-comment"># Based on Tencent CloudBase</span><br><span class="hljs-comment"># See: https://twikoo.js.org</span><br><span class="hljs-attr">twikoo:</span><br>  <span class="hljs-attr">envId:</span><br>  <span class="hljs-attr">region:</span> <span class="hljs-string">ap-shanghai</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br><br><span class="hljs-comment"># Cusdis</span><br><span class="hljs-comment"># 基于第三方服务或自托管服务</span><br><span class="hljs-comment"># Based on third-party or self-hosted service</span><br><span class="hljs-comment"># See https://cusdis.com</span><br><span class="hljs-attr">cusdis:</span><br>  <span class="hljs-attr">host:</span><br>  <span class="hljs-attr">app_id:</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-comment"># Giscus</span><br><span class="hljs-comment"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class="hljs-comment"># Based on GitHub Discussions, similar to Utterances</span><br><span class="hljs-comment"># See: https://giscus.app/</span><br><span class="hljs-attr">giscus:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">repo-id:</span><br>  <span class="hljs-attr">category:</span><br>  <span class="hljs-attr">category-id:</span><br>  <span class="hljs-attr">theme-light:</span> <span class="hljs-string">light</span><br>  <span class="hljs-attr">theme-dark:</span> <span class="hljs-string">dark</span><br>  <span class="hljs-attr">mapping:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">reactions-enabled:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">emit-metadata:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">input-position:</span> <span class="hljs-string">top</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br><br><span class="hljs-comment"># Discuss</span><br><span class="hljs-comment"># 多平台、多数据库、自托管、免费开源评论系统</span><br><span class="hljs-comment"># Self-hosted, small size, multi-platform, multi-database, free and open source commenting system</span><br><span class="hljs-comment"># See: https://discuss.js.org</span><br><span class="hljs-attr">discuss:</span><br>  <span class="hljs-attr">serverURLs:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 归档页</span><br><span class="hljs-comment"># Archive Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">archive:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 分类页</span><br><span class="hljs-comment"># Category Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">category:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 分类的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class="hljs-comment"># Sort field for categories, with a minus sign is reverse order</span><br>  <span class="hljs-comment"># Options: length | name</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">&quot;-length&quot;</span><br><br>  <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开</span><br>  <span class="hljs-comment"># Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories</span><br>  <span class="hljs-attr">collapse_depth:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>  <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>  <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;-date&quot;</span><br><br>  <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>  <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>  <span class="hljs-attr">post_limit:</span> <span class="hljs-number">10</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 标签页</span><br><span class="hljs-comment"># Tag Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">tagcloud:</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#BBBBEE&quot;</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#337ab7&quot;</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 关于页</span><br><span class="hljs-comment"># About Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/img/avatar.png</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Fluid&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br>  <span class="hljs-comment"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class="hljs-comment"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-douban-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://douban.com&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;豆瓣&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-wechat-fill&quot;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span> &#125;<br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 自定义页</span><br><span class="hljs-comment"># Custom Page</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 通过 hexo new page 命令创建的页面</span><br><span class="hljs-comment"># Custom Page through `hexo new page`</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">page:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 404页</span><br><span class="hljs-comment"># 404 Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">page404:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">85</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-comment"># 重定向到首页的延迟(毫秒)</span><br>  <span class="hljs-comment"># Delay in redirecting to home page (milliseconds)</span><br>  <span class="hljs-attr">redirect_delay:</span> <span class="hljs-number">5000</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 友链页</span><br><span class="hljs-comment"># Links Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-comment"># 友链的成员项</span><br>  <span class="hljs-comment"># Member item of page</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Blog&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题博客&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://hexo.fluid-dev.com/&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Docs&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题使用指南&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://hexo.fluid-dev.com/docs/&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Repo&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题 GitHub 仓库&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br><br>  <span class="hljs-comment"># 当成员头像加载失败时，替换为指定图片</span><br>  <span class="hljs-comment"># When the member avatar fails to load, replace the specified image</span><br>  <span class="hljs-attr">onerror_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br><br>  <span class="hljs-comment"># 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字</span><br>  <span class="hljs-comment"># Custom content at the bottom of the links</span><br>  <span class="hljs-attr">custom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;&lt;hr&gt;&lt;p&gt;在下方留言申请加入我的友链，按如下格式提供信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客名：Fluid&lt;/li&gt;&lt;li&gt;简介：Fluid 主题官方博客&lt;/li&gt;&lt;li&gt;链接：https://hexo.fluid-dev.com&lt;/li&gt;&lt;li&gt;图片：https://hexo.fluid-dev.com/img/favicon.png&lt;/li&gt;&lt;/ul&gt;&#x27;</span><br><br>  <span class="hljs-comment"># 评论插件</span><br>  <span class="hljs-comment"># Comment plugin</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 以下是配置 JS CSS 等静态资源的 URL 前缀，可以自定义成 CDN 地址，</span><br><span class="hljs-comment"># 如果需要修改，最好使用与默认配置相同的版本，以避免潜在的问题，</span><br><span class="hljs-comment"># ** 如果你不知道如何设置，请不要做任何改动 **</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Here is the url prefix to configure the static assets. Set CDN addresses you want to customize.</span><br><span class="hljs-comment"># Be aware that you would better use the same version as default ones to avoid potential problems.</span><br><span class="hljs-comment"># DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-attr">static_prefix:</span><br>  <span class="hljs-comment"># 内部静态</span><br>  <span class="hljs-comment"># Internal static</span><br>  <span class="hljs-attr">internal_js:</span> <span class="hljs-string">/js</span><br>  <span class="hljs-attr">internal_css:</span> <span class="hljs-string">/css</span><br>  <span class="hljs-attr">internal_img:</span> <span class="hljs-string">/img</span><br><br>  <span class="hljs-attr">anchor:</span> <span class="hljs-string">https://lib.baomitu.com/anchor-js/4.3.1/</span><br><br>  <span class="hljs-attr">github_markdown:</span> <span class="hljs-string">https://lib.baomitu.com/github-markdown-css/4.0.0/</span><br><br>  <span class="hljs-attr">jquery:</span> <span class="hljs-string">https://lib.baomitu.com/jquery/3.6.4/</span><br><br>  <span class="hljs-attr">bootstrap:</span> <span class="hljs-string">https://lib.baomitu.com/twitter-bootstrap/4.6.1/</span><br><br>  <span class="hljs-attr">prismjs:</span> <span class="hljs-string">https://lib.baomitu.com/prism/1.29.0/</span><br><br>  <span class="hljs-attr">tocbot:</span> <span class="hljs-string">https://lib.baomitu.com/tocbot/4.20.1/</span><br><br>  <span class="hljs-attr">typed:</span> <span class="hljs-string">https://lib.baomitu.com/typed.js/2.0.12/</span><br><br>  <span class="hljs-attr">fancybox:</span> <span class="hljs-string">https://lib.baomitu.com/fancybox/3.5.7/</span><br><br>  <span class="hljs-attr">nprogress:</span> <span class="hljs-string">https://lib.baomitu.com/nprogress/0.2.0/</span><br><br>  <span class="hljs-attr">mathjax:</span> <span class="hljs-string">https://lib.baomitu.com/mathjax/3.2.2/</span><br><br>  <span class="hljs-attr">katex:</span> <span class="hljs-string">https://lib.baomitu.com/KaTeX/0.16.2/</span><br><br>  <span class="hljs-attr">busuanzi:</span> <span class="hljs-string">https://busuanzi.ibruce.info/busuanzi/2.3/</span><br><br>  <span class="hljs-attr">clipboard:</span> <span class="hljs-string">https://lib.baomitu.com/clipboard.js/2.0.11/</span><br><br>  <span class="hljs-attr">mermaid:</span> <span class="hljs-string">https://lib.baomitu.com/mermaid/8.14.0/</span><br><br>  <span class="hljs-attr">valine:</span> <span class="hljs-string">https://lib.baomitu.com/valine/1.5.1/</span><br><br>  <span class="hljs-attr">waline:</span> <span class="hljs-string">https://cdn.staticfile.org/waline/2.15.5/</span><br><br>  <span class="hljs-attr">gitalk:</span> <span class="hljs-string">https://lib.baomitu.com/gitalk/1.8.0/</span><br><br>  <span class="hljs-attr">disqusjs:</span> <span class="hljs-string">https://lib.baomitu.com/disqusjs/1.3.0/</span><br><br>  <span class="hljs-attr">twikoo:</span> <span class="hljs-string">https://lib.baomitu.com/twikoo/1.6.8/</span><br><br>  <span class="hljs-attr">discuss:</span> <span class="hljs-string">https://lib.baomitu.com/discuss/1.2.1/</span><br><br>  <span class="hljs-attr">hint:</span> <span class="hljs-string">https://lib.baomitu.com/hint.css/2.7.0/</span><br><br>  <span class="hljs-attr">moment:</span> <span class="hljs-string">https://lib.baomitu.com/moment.js/2.29.4/</span><br></code></pre></td></tr></table></figure><h3 id="站点配置">站点配置</h3><p>现在对我而言还有两个问题，我换到 Fluid 就是为了 Latex<br />所以……<br />这里还是按官方来，<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#latex-数学公式)">[4]</span></a></sup></p><ol type="1"><li><p><strong>设置主题配置</strong><br /><spanclass="math inline">\(我这里使用的是\;mathjax+pandoc,\;\)</span><br /><spanclass="math inline">\(好处是别人可以复制你写的\;Latex\)</span><br /><span class="math inline">\(\begin{aligned}坏处是\hspace{340px}\\他的换行不能像typora的&#39;\backslash\backslash&#39;直接换行,\hspace{115px}\\要使用\backslash begin\{aligned\}\backslashend\{aligned\}\hspace{100px}\\才能&#39;\backslash\backslash&#39;换行\hspace{300px}\\而且不能使用\backslash hfill只能使用\backslash hspace\{num\;cm/px\}\hspace{10px}\end{aligned}\)</span><br />而且换行前必须打两个空格</p><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span>  <br>  <span class="hljs-attr">math:</span>  <br>   <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <br>   <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span>  <br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span>  <br></code></pre></td></tr></table></figure></p><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <ahref="https://hexo.io/zh-cn/docs/front-matter">front-matter (opens newwindow)</a>里指定 <code>math: true</code>才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或<code>katex</code>。</p></li><li><p><strong>更换 Markdown 渲染器</strong><br />由于 Hexo 默认的 Markdown渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><ul><li><p>mathjax <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></p><p><strong>并且还需<ahref="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装Pandoc</a></strong></p></li><li><p>katex <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-markdown-it --save<br>npm install @traptitech/markdown-it-katex --save<br></code></pre></td></tr></table></figure></p><p>然后在站点配置中添加： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;@traptitech/markdown-it-katex&quot;</span><br></code></pre></td></tr></table></figure> ### 我安装Pandoc过程</p></li></ul></li></ol><p>环境说明：Windows11</p><ol type="1"><li><a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">下载Pandoc</a><br />下载链接<a href="https://github.com/jgm/pandoc/releases/latest">downloadpage</a><br /><img src="/imgs/Hexo主题变更/pandoc1.png" />找到 window，我使用的是msi：<br /><img src="/imgs/Hexo主题变更/pandoc1-1.png" /><br /></li><li>按照提示安装就可以，这里可以自选目录<br />pandoc 和hexo-renderer-pandoc不一样，一个是程序，一个是hexo的渲染插件</li></ol><h3 id="插入图片">插入图片</h3><p>我还是用的老办法，<code>![](/imgs/xxxx)</code>，<br />想要在 typora也显示，那就把文档的图片放到一个文件夹<code>/imgs/</code>内<br />Fluid会在<code>..\Blog\source</code>目录下寻找图片资源文件，其他类型应该也是一样。</p><h2 id="待解决问题">待解决问题</h2><ul><li>换行异常：<br />typora 可以换行，但是 web blog 不能换行只能换段<br />latex 公式不能换行<ul><li><p>因为pandoc和typora语法不一样</p></li><li><p>这里给出修改代码<br />这里的代码有问题哦，但是我不改了……也都有注释，如果你需要可以自行修改<br />编译原理的自动机学过伐，一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 指定需要修改的 Markdown 文件夹路径  </span><br>folder_path = <span class="hljs-string">&#x27;/path/to/markdown_folder/&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_md_file</span>(<span class="hljs-params">file_path</span>):  <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>        content = f.readlines()<br><br>    modified_content = []  <br>    code_block = <span class="hljs-literal">False</span>  <br>    latex_block = <span class="hljs-literal">False</span>  <br>    setting_block = <span class="hljs-literal">False</span>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(content)):  <br>        line = content[i].rstrip(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>        <span class="hljs-comment"># 判断是否进入或退出代码块  </span><br>        <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">&#x27;~~~&#x27;</span>):  <br>            code_block = <span class="hljs-keyword">not</span> code_block<br><br>        <span class="hljs-comment"># 判断是否进入或退出 LaTeX 段落  </span><br>        <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">&#x27;$$&#x27;</span>):  <br>            latex_block = <span class="hljs-keyword">not</span> latex_block<br><br>        <span class="hljs-comment"># 判断是否进入或退出设置段  </span><br>        <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">&#x27;---&#x27;</span>):  <br>            setting_block = <span class="hljs-keyword">not</span> setting_block<br><br>        <span class="hljs-comment"># 如果在代码块内、LaTeX 段落内或设置段内，则不做修改  </span><br>        <span class="hljs-keyword">if</span> code_block <span class="hljs-keyword">or</span> latex_block <span class="hljs-keyword">or</span> setting_block:  <br>            modified_content.append(line)  <br>        <span class="hljs-keyword">else</span>:  <br>            <span class="hljs-comment"># 如果行首是标题，则不加空格  </span><br>            <span class="hljs-keyword">if</span> line.startswith(<span class="hljs-string">&#x27;#&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class="hljs-comment"># 如果行首以 &lt;img 开头，则不做修改  </span><br>            <span class="hljs-keyword">elif</span> line.lstrip().startswith(<span class="hljs-string">&#x27;&lt;img&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class="hljs-comment"># 如果行首以 &lt; 开头，则不加空格（除了 &lt;img 外）  </span><br>            <span class="hljs-keyword">elif</span> line.startswith(<span class="hljs-string">&#x27;&lt;&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class="hljs-keyword">else</span>:  <br>                <span class="hljs-comment"># 如果行尾已经有两个空格，则不做修改  </span><br>                <span class="hljs-keyword">if</span> line.endswith(<span class="hljs-string">&#x27;  &#x27;</span>):  <br>                    modified_content.append(line)  <br>                <span class="hljs-keyword">else</span>:  <br>                    <span class="hljs-comment"># 判断下一行是否为空行  </span><br>                    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(content) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> content[i+<span class="hljs-number">1</span>].strip() == <span class="hljs-string">&#x27;&#x27;</span>:  <br>                        modified_content.append(line)  <br>                    <span class="hljs-keyword">else</span>:  <br>                        modified_content.append(line + <span class="hljs-string">&#x27;  &#x27;</span>)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>        f.write(<span class="hljs-string">&#x27;\n&#x27;</span>.join(modified_content))<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;已修改文件: <span class="hljs-subst">&#123;file_path&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 遍历 Markdown 文件夹下的所有文件  </span><br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(folder_path):  <br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:  <br>        <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):  <br>            file_path = os.path.join(root, file)  <br>            process_md_file(file_path)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;所有文件修改完成&#x27;</span>)  <br></code></pre></td></tr></table></figure></li></ul></li></ul><p>标题段落间隔大 : 主题问题</p><h2 id="参考">参考</h2><p><a href="https://docs.mathjax.org/en/latest/index.html">MathJax 文档— MathJax 3.2 文档</a></p><p><a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter |Hexo</a></p><p><a href="https://github.com/hexojs/hexo-math">hexojs/hexo-math: Ahexo plugin that uses MathJax to render math equations.(github.com)</a></p><ahref="https://github.com/jgm/pandoc/blob/main/INSTALL.md">pandoc/INSTALL.md在主 ·JGM/PANDOC的 (github.com)</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:0"class="footnote-text"><span><a href="https://saucenao.com/">图片搜索:saucenao</a><a href="#fnref:0" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:1"class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs">HexoFulid 官方Doc</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#覆盖配置">配置指南| Hexo Fluid 用户手册 (fluid-dev.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">主题配置</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><ahref="https://hexo.fluid-dev.com/docs/guide/#latex-数学公式">配置指南 |Hexo Fluid 用户手册 (fluid-dev.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">hexo-theme-fluid/_config.ymlat master · fluid-dev/hexo-theme-fluid (github.com)</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>主题变更</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn PBR</title>
    <link href="/2023/11/14/LearnPBR/"/>
    <url>/2023/11/14/LearnPBR/</url>
    
    <content type="html"><![CDATA[<p>关于PBR的一些知识点</p><h1 id="learn-pbr">Learn PBR</h1><h1 id="pbr理论">PBR理论</h1><h2 id="简介"><strong>简介</strong></h2><p><strong>PBR</strong>（<strong>Physically BasedRendering</strong>）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。</p><h3 id="pbr-特征"><strong>PBR</strong> <strong>特征</strong></h3><p>更高质量的着色效果和更多复杂的材质特性。</p><ul><li>表面细节</li><li>物体粗糙度</li><li>区别明显的金属和绝缘体</li><li>物体的浑浊程度</li><li>菲涅尔现象：不同角度有不同强度的反射光</li><li>半透明物体</li><li>多层混合材质</li><li>清漆效果</li><li>其它更复杂的表面特征</li></ul><blockquote><p>近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：</p><ul><li>PBR Diffuse for GGX + Smith (2017)</li><li>MultiScattering Diffuse (2018)</li><li>Layers Material（分层材质）</li><li>Mixed Material（混合材质）</li><li>Mixed BxDF（混合BxDF）</li><li>Advanced Rendering（进阶渲染）</li></ul></blockquote><h3 id="output"><strong>OutPut</strong></h3><figure><img src="/imgs/LearnPBR/output.PNG" alt="output" /><figcaption aria-hidden="true">output</figcaption></figure><h2 id="pbr-和-游戏引擎"><strong>PBR</strong> <strong>和游戏引擎</strong></h2><h3 id="ue4-的-pbr"><strong>UE4 的</strong> <strong>PBR</strong></h3><ul><li><strong>Base Color</strong>，基础的纹理颜色非金属物体只有<strong>单色</strong>，即强度</li></ul><table><thead><tr><th>Material</th><th>Base Color Intensity</th></tr></thead><tbody><tr><td>木炭(Charcoal)</td><td>0.02</td></tr><tr><td>新沥青(Fresh asphalt)</td><td>0.02</td></tr><tr><td>旧沥青(Worn asphalt)</td><td>0.08</td></tr><tr><td>土壤(Bare soil)</td><td>0.13</td></tr><tr><td>绿草(Green Grass)</td><td>0.21</td></tr><tr><td>沙漠沙(desert sand)</td><td>0.36</td></tr><tr><td>新混泥土(Fresh concrete)</td><td>0.51</td></tr><tr><td>海洋冰(Ocean Ice)</td><td>0.56</td></tr><tr><td>鲜雪(Fresh snow)</td><td>0.81</td></tr></tbody></table><ul><li><strong>金属</strong>材质，在 Linear 空间的值</li></ul><table><thead><tr><th>材质(Material)</th><th>基础色(BaseColor)</th></tr></thead><tbody><tr><td>铁(Iron)</td><td>(0.560, 0.570, 0.580)</td></tr><tr><td>银(Silver)</td><td>(0.972, 0.960, 0.915)</td></tr><tr><td>铝(Aluminum)</td><td>(0.913, 0.921, 0.925)</td></tr><tr><td>金(Gold)</td><td>(1.000, 0.766, 0.336)</td></tr><tr><td>铜(Copper)</td><td>(0.955, 0.637, 0.538)</td></tr><tr><td>铬(Chromium)</td><td>(0.550, 0.556, 0.554)</td></tr><tr><td>镍(Nickel)</td><td>(0.660, 0.609, 0.526)</td></tr><tr><td>钛(Titanium)</td><td>(0.542, 0.497, 0.449)</td></tr><tr><td>钴(Cobalt)</td><td>(0.662, 0.655, 0.634)</td></tr><tr><td>铂(Platinum)</td><td>(0.672, 0.637, 0.585)</td></tr></tbody></table><ul><li><strong>粗糙度(Roughness)</strong>：表面的粗糙程度,[0,1]，越粗糙高光越弱。</li></ul><figure><img src="/imgs/LearnPBR/roughness.png" alt="roughness" /><figcaption aria-hidden="true">roughness</figcaption></figure><figure><img src="/imgs/LearnPBR/roughness2.png" alt="roughness2" /><figcaption aria-hidden="true">roughness2</figcaption></figure><p>上为非金属，下为金属，粗糙度从0至1</p><ul><li><strong>金属度(Metallic)</strong>：表示材质像金属的程度，0是绝缘体(电介质)，1是金属，金属只有镜面反射，没有漫反射。</li></ul><figure><img src="/imgs/LearnPBR/metallic.png" alt="metallic" /><figcaption aria-hidden="true">metallic</figcaption></figure><p>金属度从0至1</p><ul><li><strong>镜面度(Specular)</strong>：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)</li></ul><figure><img src="/imgs/LearnPBR/specular.png" alt="specular" /><figcaption aria-hidden="true">specular</figcaption></figure><p>From 0 ~ 1</p><table><thead><tr><th>材质(Material)</th><th>镜面度(Specular)</th></tr></thead><tbody><tr><td>草(Glass)</td><td>0.5</td></tr><tr><td>塑料(Plastic)</td><td>0.5</td></tr><tr><td>石英(Quartz)</td><td>0.57</td></tr><tr><td>冰(Ice)</td><td>0.224</td></tr><tr><td>水(Water)</td><td>0.255</td></tr><tr><td>牛奶(Milk)</td><td>0.277</td></tr><tr><td>皮肤(Skin)</td><td>0.35</td></tr></tbody></table><h3 id="unity-的-pbr"><strong>Unity 的</strong><strong>PBR</strong></h3><ul><li><strong>Albedo</strong>，和 UE 的 Base Color 一样。可以用颜色或者Tex</li><li><strong>Metallic</strong>，可以用金属贴图，但是用了 Smoothness参数就消失了</li><li><strong>Smoothness</strong>，光滑度，和 UE 的 粗糙度正相反<ul><li><strong>SmoothnessSource</strong>，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha或基础色的 Alpha</li></ul></li><li><strong>Occlusion</strong>：遮蔽图，指定材质接收间接光的光照强度和反射强度。能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。</li><li><strong>Fresnel</strong>，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。</li></ul><h2 id="pbr-基本原理"><strong>PBR</strong><strong>基本原理</strong></h2><p>满足以下条件的光照模型才能称之为PBR光照模型：</p><ul><li>基于微平面模型（Be based on the microfacet surface model）。</li><li>能量守恒（Be energy conserving）。</li><li>使用基于物理的BRDF（Use a physically based BRDF）。</li></ul><h3id="微表面理论microfacet"><strong>微表面理论(Microfacet)</strong></h3><p>很多 PBR 技术都是基于理论认为<strong>在微观上</strong>，所有的物体表面都是由很多的朝向不一的微小平面组成的。</p><blockquote><p>真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至<em>光栅化后的像素尺度</em>来看待的话，这种假设的结果和实际差别甚微。</p></blockquote><figure><img src="/imgs/LearnPBR/microfacet.png" alt="microfacet" /><figcaption aria-hidden="true">microfacet</figcaption></figure><p>基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度Roughness，用统计学的方法去估算微表面的粗糙度。</p><p>...</p><h3 id="energy-conservation-能量守恒"><strong>Energy Conservation(能量守恒)</strong></h3><p>在 Microfacet中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，</p><p>所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。</p><h4id="镜面反射specular和漫反射diffuse"><strong>镜面反射(specular)和漫反射(diffuse)</strong></h4><p>一束光打到物体，会发生 <strong>reflection</strong> 反射 和<strong>refraction</strong>折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。</p><figure><img src="/imgs/LearnPBR/reflect.png" alt="reflect" /><figcaption aria-hidden="true">reflect</figcaption></figure><p><em>照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。</em>通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(SubsurfaceScattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。</p><p>根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。</p><p>float kS = calculateSpecularComponent(...); // 反射/镜面部分</p><p>float kD = 1.0 - kS; // 折射/漫反射部分</p><p>ks + kd 不会超过1，所以近似地能量守恒。</p><h3 id="reflectance-equation"><strong>Reflectance Equation</strong></h3><p><spanclass="math display">\[L_0(p,w_0)=\int\limits_{\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\,\mathrm{d}w_i\]</span></p><h2 id="辐射度量学"><strong>辐射度量学</strong></h2><h3 id="概念表"><strong>概念表</strong></h3><figure><img src="/imgs/LearnPBR/chart1.png" alt="chart1" /><figcaption aria-hidden="true">chart1</figcaption></figure><figure><img src="/imgs/LearnPBR/chart2.png" alt="chart2" /><figcaption aria-hidden="true">chart2</figcaption></figure><blockquote><p>微分符号 d的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx</p></blockquote><h3 id="辐射通量radiant-flux"><strong>辐射通量（RadiantFlux)</strong></h3><p>光源单位时间内的输出<spanclass="math display">\[\Phi=\frac{\mathrm{d}Q}{\mathrm{d}t}\]</span></p><blockquote><p>光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。</p></blockquote><p>传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。</p><h3 id="radiant-insensity辐射强度"><strong>RadiantInsensity(辐射强度)</strong></h3><p>单位球面上，一个光源向单位立体角所投送的辐射通量。</p><p><spanclass="math display">\[I=\frac{\mathrm{d}\Phi}{\mathrm{d}w}\]</span></p><p>the power per unit angle</p><p>假如光源均匀向四周发散</p><p><span class="math display">\[I = \frac{\Phi}{4\pi}\]</span></p><h3 id="irradiance"><strong>Irradiance</strong></h3><p>The power per (perpendicular/projected) unit area incident on asurface point.</p><p><spanclass="math display">\[E(x)=\frac{\mathrm{d}\Phi(x)}{\mathrm{d}A^\perp}\]</span></p><p>面要和光源垂直。</p><p>即 Lambert‘s Consine Law</p><h3 id="radiance"><strong>Radiance</strong></h3><p>The radiance(luminance) is the power emitted, reflected, transmittedor received by a surface, <em>per unit solid angle, per projected unitarea.</em> 在单位立体角并且在单位的面积上</p><p><spanclass="math display">\[L(p,w)=\frac{\mathrm{d}^2\Phi(p,w)}{\mathrm{d}w\,\mathrm{d}A\cos\theta}=\frac{\mathrm{d}^2\Phi(p,w)}{\mathrm{d}w\,\mathrm{d}A^\perp}\]</span></p><ul><li>Irradiance: power per projected unit area</li><li>Intensity: power per solid angle</li></ul><p>So</p><ul><li>Radiance : Irrandiance pre solid angle</li><li>Radiance : Intensity pre unit projected area</li></ul><p>Irradiance 是 dA 收到的能量</p><p>Irradiance per solid angle 是 dA 的能量向某一个方向辐射</p><figure><img src="/imgs/LearnPBR/Radiance.png" alt="Radiance" /><figcaption aria-hidden="true">Radiance</figcaption></figure><p>该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E里面……</p><p>Incident Radiance 延申理解：</p><p>一小块面积 dA 向某个方向辐射的能量</p><p>反过来就是，从一个方向打向一个小面，到达这个面时的能量</p><p><spanclass="math display">\[L(p,w)=\frac{\mathrm{d}I(p,w)}{\mathrm{d}A\cos\theta}=\frac{\mathrm{d}I(p,w)}{\mathrm{d}A^\perp}\]</span></p><h3 id="irradiance-vs.-radiace"><strong>Irradiance vs.Radiace</strong></h3><p><spanclass="math display">\[\mathrm{d}E(p,w)=L_i(p,w)\cos\theta\,\mathrm{d}w\\\]</span></p><p>两边同时积分</p><p><spanclass="math display">\[E(p)=\int_H^2L_i(p,w)\cos\theta\,\mathrm{d}w\\Uint\;Hemisphere:H^2\]</span></p><p>每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。</p><p>再回到渲染方程</p><p><span class="math display">\[L_0(p,w_0)=\int\limits_\Omegaf_r(p,w_i,w_0)\underbrace{L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i}_{Radiace}\]</span></p><p>其中只有 f 项待解。</p><h2id="brdf双向反射分布函数"><strong>BRDF(双向反射分布函数)</strong></h2><p>Bidirectional Reflectance Distribution Function，BRDF</p><p>一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。</p><figure><img src="/imgs/LearnPBR/BRDF.svg" alt="BRDF" /><figcaption aria-hidden="true">BRDF</figcaption></figure><p>BRDF描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，</p><p>假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.</p><p><spanclass="math display">\[f_r(p,w_0,w_i)=\frac{\mathrm{d}L_0(p,w_0)}{\mathrm{d}E(p,w_i)}=\frac{\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\cos\theta_i\,\mathrm{d}w_i}\]</span></p><p>BRDF 有多种模拟表面光照的算法，实时渲染所用的基本是<strong>Cook-Torrance BRDF</strong></p><h3 id="参考"><strong>参考</strong></h3><ul><li><strong>PBRT-BRDF章节：</strong><ahref="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection">SurfaceReflection (pbr-book.org)</a></li></ul><h3 id="cook-torrance-brdf"><strong>Cook-Torrance BRDF</strong></h3><p><spanclass="math display">\[f_r=k_df_{lambert}+k_sf_{cook-torrance}\\k_d是入射光被折射比例，\\ k_s是被镜面反射比例\]</span></p><p>而左侧的 f_lambert 表示漫反射部分，LambertianDiffuse，一般是恒定的算式：</p><p><span class="math display">\[f_{lambert}=\frac{c}{\pi}\]</span></p><p>c 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的</p><h4 id="brdf的高光项"><strong>BRDF的高光项</strong></h4><p><span class="math display">\[f_{cook-torrance}=\frac{DFG}{4(w_0\cdotn)(w_i\cdot n)}\]</span></p><ul><li><strong>D( Normal Distribution Function, NDF )</strong> :法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(halfDir)的一致性或者说微表面的数量。 估算微表面的主要函数。</li><li><strong>F( Fresnel Equation)</strong>：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。不同表面角下，表面反射光线的比例。</li><li><strong>G( Geometry Function )</strong> :几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。</li></ul><p><ahref="https://www.zhihu.com/question/28476602/answer/41003204">brdf为什么要定义为一个单位是sr-1的量？- 知乎 (zhihu.com)</a> <ahref="https://www.zhihu.com/question/28476602/answer/41003204">brdf为什么要定义为一个单位是sr-1的量？- 文刀秋二的回答:</a></p><h3 id="dnormal-distribution-function-ndf"><strong>D(Normal DistributionFunction, NDF)</strong></h3><p>描述和微表面法线和半角向量的一致性，从统计学上近似<strong>Trowbridge-Reitz GGX(GGXTR) :</strong></p><p><spanclass="math display">\[{NDF}_{GGXTR}(n,h,\alpha)=\frac{\alpha^2}{\pi((n\cdoth)^2(\alpha^2-1)+1)^2}\\ h=normalize(viewDir+lightDir)\\\alpha={roughness}^2\]</span></p><figure><img src="/imgs/LearnPBR/ggx.png" alt="ggx" /><figcaption aria-hidden="true">ggx</figcaption></figure><p><ahref="https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN">Trowbridge-ReitzGGX | Desmos</a></p><p>当 粗糙度 为零时函数值变为零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float DoubleDistributeGGX(float3 N, float3 H, float roughness)<br>&#123;<br>    float a = roughness * roughness;<br>    float a2 = a * a;<br>    float NdotH = max(0.0, dot(N, H));<br>    float NdotH2 = NdotH * NdotH;<br><br>    float p = (NdotH2 * (a2 - 1.0) + 1.0);<br>    p = PI * p * p;<br>    return a2 / p;<br>&#125;<br><br>roughness += 0.0001;<br>float NDF = DoubleDistributeGGX(N, H, roughness);<br></code></pre></td></tr></table></figure><p><ahref="https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">2013SiggraphPresentationsNotes-26915738.pdf(unrealengine.com): Specular D</a></p><h4id="generalized-trowbridge-reitzgtr分布"><strong>Generalized-Trowbridge-Reitz（GTR）分布</strong></h4><p>GTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。</p><p><span class="math display">\[D_{GTR}(m)=\frac{c}{(1+(n\cdotm)^2(\alpha^2-1))^\gamma}\]</span></p><ul><li>关于形状不变性的好处，可以总结为：<ul><li>方便推导出该NDF归一化的各向异性版本</li><li>方便推导出遮蔽阴影项 Smith G</li><li>方便基于NDF或可见法线分布推导其重要性采样<ul><li>对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性</li></ul></li></ul></li></ul><h4 id="参考-1"><strong>参考</strong></h4><p><ahref="https://zhuanlan.zhihu.com/p/69380665">【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结- 知乎 (zhihu.com)</a>:关于形状不变性。</p><h3 id="ffresnel-equation"><strong>F(Fresnel Equation)</strong></h3><p><spanclass="math display">\[F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5\]</span></p><p>F_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0越大菲涅尔反射现象越强。</p><p>当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。</p><figure><img src="/imgs/LearnPBR/fresnel.png" alt="fresnel" /><figcaption aria-hidden="true">fresnel</figcaption></figure><p><strong>Fresnel-Schlick</strong>只适用于绝缘体的表面算法。金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以：预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。这样就可以使用同一个公式了。</p><p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<ahref="http://refractiveindex.info/">RefractiveIndex</a>。</p><p>所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</p><figure><img src="/imgs/LearnPBR/chart3.png" alt="chart3" /><figcaption aria-hidden="true">chart3</figcaption></figure><p>由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非非零即一的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。</p><p>我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick近似，但是对于金属表面通常这样做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 F0 = vec3(0.04,0.04,0.04);<br>F0 = mix(F0, surfaceColor.rgb, metalness);<br></code></pre></td></tr></table></figure><p>我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 fresnelSchlick(float cosTheta, vec3 F0)<br>&#123;<br>    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br>// cosTheta = dot(N,V)<br></code></pre></td></tr></table></figure><p>这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的fresnelSchlick</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)<br>&#123;<br>    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 FresnelReflection： <ahref="https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission">SpecularReflection and Transmission (pbr-book.org)</a></p><blockquote><ol type="1"><li>The first class is <em>dielectrics</em>, which are materials thatdon’t conduct electricity. They have real-valued indices of refraction(usually in the range 1-3) and transmit† a portion of the incidentillumination. Examples of dielectrics are glass, mineral oil, water, andair.</li><li>The second class consists of <em>conductors</em> such as metals.Valence electrons can freely move within the their atomic lattice,allowing electric currents to flow from one place to another. Thisfundamental atomic property translates into a profoundly differentbehavior when a conductor is subjected to electromagnetic radiation suchas visible light: the material is opaque and reflects back a significantportion of the illumination. A portion of the light is also transmittedinto the interior of the conductor, where it is rapidly absorbed: totalabsorption typically occurs within the top 0.1 μm of the material, henceonly extremely thin metal films are capable of transmitting appreciableamounts of light. We ignore this effect in <code>pbrt</code> and onlymodel the reflection component of conductors. In contrast todielectrics, conductors have a complex-valued index of refractionn=n0+ik.</li><li>Semiconductors such as silicon or germanium are the third classthough we will not consider them in this book.</li><li>The first class is dielectrics, which are materials that don'tconduct electricity. They have real-valued indices of refraction(usually in the range 1-3) and transmitt a portion of the incidentillumination. Examples of dielectrics are glass, mineral oil, water, andair.</li><li>The second class consists of conductors such as metals. Valenceelectrons can freely move within the their atomic lattice, allowingelectric currents to flow from one place to another. This fundamentalatomic property translates into a profoundly different behavior when aconductor is subjected to electromagnetic radiation such as visiblelight: the material is opaque and reflects back a significant portion ofthe illumination. A portion of the light is also transmitted into theinterior of the conductor, where it is rapidly absorbed: totalabsorption typically occurs within the top 0.1 um of the material, henceonly extremely thin metal films are capable of transmitting appreciableamounts of light. We ignore this effect in pbrt and only model thereflection component of conductors. In contrast to dielectrics,conductors have a complex-valued index of refraction = n + ik.</li><li>Semiconductors such as silicon or germanium are the third classthough we will not consider them in this book.</li></ol><p>第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。</p><p>第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率=n + ik。</p><p>硅或锗等半导体是第三类，但我们在本书中不考虑它们。</p></blockquote><h3 id="ggeometry-function"><strong>G(Geometry Function)</strong></h3><p>几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。</p><p>类似 NDF，也使用 Roughness作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和Schlick-Beckmann 组合而成的模拟函数 <strong>Schlick-GGX</strong>：</p><p><span class="math display">\[G_{SchlickGGX}(n,v,k)=\frac{n\cdotv}{(n\cdot v)(1-k)+k}\]</span></p><figure><img src="/imgs/LearnPBR/G.png" alt="G" /><figcaption aria-hidden="true">G</figcaption></figure><p>这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL光照的几何函数参数:</p><p><span class="math display">\[k_{direct}=\frac{(\alpha+1)^2}{8}\\k_{IBL}=\frac{\alpha^2}{2}\]</span></p><p>这里的 α 取决于我们怎么从粗糙度转换。</p><p>为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影)几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 <strong>Smith</strong>函数将其放在一起:</p><p><spanclass="math display">\[G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float GeometrySchlickGGX(float NdotV, float k)<br>&#123;<br>    float nom = NdotV;<br>    float denom =  NdotV * (1 - k) + k;<br>    return nom / denom;<br>&#125;<br><br>float GeometeySmith(vec3 N, vec3 V, vec3 L, float k)<br>&#123;<br>    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);<br>    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);<br>    return Gsub * Gsub2;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kulla-conty-approximation"><strong>Kulla-ContyApproximation</strong></h3><p>由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF只是考虑一次反射罢了。</p><p>所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。</p><p><spanclass="math display">\[E(\mu_o)=\int_0^{2\pi}\int_0^1f_r(\mu_o,\mu_i,\phi)u_i\,\mathrm{d}\mu_i\,\mathrm{d}\phi\\u=\sin\theta\]</span></p><ul><li>Key idea<ul><li>损失的能量就是 1 - E(_o)，不过E(_o)是和观察方向相关的。我要做的就是补上这部分能量，能量加起来就是1了啊。</li><li>E(_0)是和观察方向相关的。</li><li>要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为BRDF 具有对称性，有1 - E(_o)那么应该也有一项1 -E(_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(_i))(1 -E(_o)) 这么设计只是为了简单……</li><li><span class="math display">\[c=\frac{1}{\pi(1-E_{avg})}\\E_{avg}=2\int_0^1E(\mu)\mu\,\mathrm{d}\mu\\f_{ms}(\mu_o,\mu_i)=\frac{(1-E(\mu_i))(1 -E(\mu_o))}{\pi(1-E_{avg})}\]</span></li><li></li></ul></li><li>但E_{avg}还是不知道的，这个可以预计算。<ul><li>Precompute / tabulate</li><li><spanclass="math display">\[E_{avg}(\mu_o)=2\int_0^1E(\mu_i)\mu_i\,\mathrm{d}\mu_i\\\]</span></li><li><span class="math display">\[E_{avg}\]</span>和<spanclass="math display">\[\mu_o\]</span>, 以及 BRDF(或者说roughness) 相关这个预计算的结果会根据 brdf 的不同而改变。</li></ul></li></ul><figure><img src="/imgs/LearnPBR/Kulla-Conty.png" alt="Kulla-Conty" /><figcaption aria-hidden="true">Kulla-Conty</figcaption></figure><ul><li>如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。</li><li>Define the average Fresnel不管入射角多大，每次反射平均反射掉多少能量</li></ul><p><spanclass="math display">\[F_{avg}=\frac{\int_0^1F(\mu)\mu\,\mathrm{d}\mu}{\int_0^1\mu\,\mathrm{d}\mu}=2\int_0^1F(\mu)\mu\,\mathrm{d}\mu\]</span></p><ul><li><span class="math display">\[E_{avg}\]</span>表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participatein further bounces</li><li>所以最后的 能量/颜色<ul><li>能够直接看到的 <spanclass="math display">\[F_{avg}E_{avg}\]</span></li><li>光反射一次被看到：<spanclass="math display">\[F_{avg}(1-E_{avg})\cdot F_{avg}E_{avg}\]</span><spanclass="math display">\[F_{avg}(1-E_{avg})\]</span>是反射后(F)未能从物体表面反射出去的能量(1-E)，<spanclass="math display">\[F_{avg}(1-E_{avg})\underline{F_{avg}}\]</span>未能出去的能量发生第二次 <spanclass="math display">\[F_{avg}(1-E_{avg})\cdotF_{avg}\underline{E_{avg}}\]</span> 发生反射后有多少能量被看到</li><li>反射k次：F_{avg}<sup>k(1-E_{avg})</sup>kF_{avg}E_{avg}</li><li>累加得到 color term：</li><li><spanclass="math display">\[\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\]</span></li><li>最后将 color term directly multiplied on the uncolored<strong>additional BRDF</strong></li></ul></li></ul><h3 id="cook-torrance-反射方程"><strong>Cook-Torrance反射方程</strong></h3><p><spanclass="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i\]</span></p><h4 id="直接光-附加光">直接光 + 附加光</h4><figure><img src="/imgs/LearnPBR/output2.PNG" alt="output2" /><figcaption aria-hidden="true">output2</figcaption></figure><h2 id="ibl"><strong>IBL</strong></h2><h3 id="diffuse-irradiance"><strong>Diffuse Irradiance</strong></h3><p>Imaged base lighting, IBL是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，<strong>而是将周围环境整体视为一个大光源</strong>。IBL(取自现实世界或者在3D场景生成)环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL对 PBR很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p><p><spanclass="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i\]</span></p><p>对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的<strong>每个</strong>方向w_i都有可能具有一定的Radiance，这就很麻烦了。 我们需要：</p><ul><li>对给定任何方向w_i，能获取到该方向的场景 Radiance。</li><li>积分需要快，因为是实时渲染。</li></ul><p>第一个思路就是用环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。</p><p>为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:</p><p><spanclass="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i\\Because\;diffuse\;k_d\;and\;specular\;are\;independent\;for\;each\;other.\\We\;can\;break\;up.\\L_0(p,w_0)=\int_{\Omega}k_d\frac{c}{\pi}L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i + \int_{\Omega}k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdotn)}L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\]</span></p><p>先来研究diffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。</p><p><spanclass="math display">\[L_0(p,w_0)=k_d\frac{c}{\pi}\int_{\Omega}L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i\]</span></p><p>卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球上的所有其他采样方向。</p><p>为了对环境贴图进行卷积，我们通过对半球 ，来计算每个输出采样方向w_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。</p><figure><img src="/imgs/LearnPBR/ibl1.png" alt="ibl1" /><figcaption aria-hidden="true">ibl1</figcaption></figure><p>是不是看不懂，看不懂就对了，因为应该是这样的！</p><figure><img src="/imgs/LearnPBR/ibl2.png" alt="ibl2" /><figcaption aria-hidden="true">ibl2</figcaption></figure><p>该预计算的立方体贴图在每个采样方向w_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。</p><p>辐射方程也依赖了位置 p，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置p处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值</p><p>关于在半球的积分，可以将立体角 soiled angle 展开</p><p><span class="math display">\[L_0(p,w_0)= k_d\frac{c}{\pi}\int_{\phi=0}^{2\pi}\int_{\theta=0}^{\frac{1}{2}\pi}L_i(p,\phi_i,\theta_i)\cos\theta\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\phi\\  Here\;\cos\theta\sin\theta,\;\sin\theta\;for\;soiled\;angle,\;\cos\theta\;for\;\overrightarrow{up}:w_i\cdotn\\  L_0(p,w_0)=k_d\frac{c}{\pi}\frac{1}{n_1n_2}\sum\limits^{n_1}_{\phi=0}\sum\limits^{n_2}_{\theta=0}L_i(p,\phi_i,\theta_i)\cos\theta\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\phi\]</span></p><h3 id="实现"><strong>实现</strong></h3><p>Roughness in [0,1]-&gt;[0,5]</p><p>做五级的skybox，存在cubemap tex内</p><h4 id="参考-2"><strong>参考</strong></h4><p><ahref="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">漫反射辐照- LearnOpenGL CN (learnopengl-cn.github.io)</a> <ahref="http://www.codinglabs.net/article_physically_based_rendering.aspx">codinglabs.net/article_physically_based_rendering.aspx</a></p><h3 id="specular-ibl"><strong>Specular IBL</strong></h3><h4 id="the-split-sum-1st-stage"><strong>The Split Sum: 1stStage</strong></h4><p>现在来看镜面反射部分，反射方程为：</p><p><spanclass="math display">\[L_0(p,w_0)=\int\limits_\Omega(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(w_0\cdotn)(w_i\cdot n)})L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\]</span></p><p>这下坏了，因为 ks是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。Epic Games提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（<strong>splitsum approximation</strong>）。分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在PBR 着色器中求和，以用于间接镜面反射部分IBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：</p><p><spanclass="math display">\[L_0(p,w_0)=\int\limits_\Omega(k_s\frac{DFG}{4(w_0\cdotn)(w_i\cdot n)})L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\\=\int\limits_\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\cdotw_i\,\mathrm{d}w_i\]</span></p><p>我们依然想计算出一个类似镜面 IBL贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于w_i，但是这次积分还依赖于 BRDF</p><p><span class="math display">\[f_r(p,w_i,w_0)=\frac{DFG}{4(w_0\cdotn)(w_i\cdot n)}\]</span></p><p>BRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。</p><p><spanclass="math display">\[\int_{\Omega}f(x)g(x)\,\mathrm{d}x\approx\frac{\int_{\Omega_G}f(x)\,\mathrm{d}x}{\int_{\Omega_G}\,\mathrm{d}x}\cdot\int_{\Omega}g(x)\,\mathrm{d}x\]</span></p><p>所以E宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。</p><p><span class="math display">\[L_0(p,w_0)=\int\limits_\OmegaL_i(p,w_i)\,\mathrm{d}w_i*\int\limits_\Omega f_r(p,w_i,w_0)n\cdotw_i\,\mathrm{d}w_i\]</span></p><p>卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的mipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5个不同粗糙度值的预卷积结果，如下图所示：</p><figure><img src="/imgs/LearnPBR/IBLCubemap.png" alt="IBLCubemap" /><figcaption aria-hidden="true">IBLCubemap</figcaption></figure><p>为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。</p><figure><img src="/imgs/LearnPBR/iblAlpha.png" alt="iblAlpha" /><figcaption aria-hidden="true">iblAlpha</figcaption></figure><p>从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的fliter 进行采样的，当越粗糙时这个 filter 越大。</p><p>为什么两部分分开了还要前面项会受到 BRDF影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。</p><figure><img src="/imgs/LearnPBR/boban.jpg" alt="boban" /><figcaption aria-hidden="true">boban</figcaption></figure><p>我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据brdf 定义可知：</p><p><spanclass="math display">\[R=reflection(w_o,n)，w_o就是\overrightarrow{view}。\]</span></p><p><strong>假设不同方向入射，波瓣变化不大</strong>，我们可以得到:</p><p><span class="math display">\[f(w_o,w_i(n),n)\approxf(R,w_i(R),R)，也就是 N=V=R。\]</span>f(w_o,w_i(n),n)f(R,w_i(R),R)，也就是 N=V=R。</p><figure><img src="/imgs/LearnPBR/poban.jpg" alt="poban" /><figcaption aria-hidden="true">poban</figcaption></figure><p>我们使用 Cook-Torrance BRDF的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此Epic Games假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：</p><p>vec3 N = normalize(w_o);</p><p>vec3 R = N;</p><p>vec3 V = R;</p><p>但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。</p><p>Moving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probefiltering</p><p>To simplify this evaluation, we can pre-integrate the integral bymaking some approximations. Pre-integrating this equation for every vand Θ would require a huge memory footprint. Thus, a first approximationis to remove the view dependency. This leads to a coarse approximationof the BRDF but it is an acceptable trade-off: the shape of a BRDF basedon the micro-facets framework and/or half-angle parametrization isstrongly dependent on the view angle as shown on Figure 54. At normalincident direction, the shape of a BRDF is isotropic. At grazing anglesthe shape of a BRDF is anisotropic. Removing the view dependency forpre-integrating Equation 46 would make the assumption that the BRDFshape is isotropic at all view angles. This leads to key visualdifferences, preventing stretched reflections. This approximation can bequite noticeable on flat surfaces as shown on Figure 55 but less oncurvy surfaces38</p><figure><img src="/imgs/LearnPBR/ueReference.png" alt="ueReference" /><figcaption aria-hidden="true">ueReference</figcaption></figure><h4 id="the-split-sum-2nd-stage"><strong>The Split Sum: 2ndStage</strong></h4><p><spanclass="math display">\[Lo(p,w_o)\approx\frac{\int_{\Omega_{fr}}L_i(p,w_i)\,\mathrm{d}w_i}{\int_{\Omega_{fr}}\,\mathrm{d}w_i}\cdot\underline{\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i}\]</span></p><p>这部分计算和 F_0,,，但是3D贴图太大了！！！</p><p>菲涅项其实比较好拆，我们可以对这部分做一些处理</p><p><span class="math display">\[R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\R_0-R_0(1-\cos\theta)^5+(1-\cos\theta)^5\\\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i\approx\\R_0\int_{\Omega^+}\frac{f_r}{F}(1-(1-\cos\theta)^5)\cos\theta_i\,\mathrm{d}w_i+\int_{\Omega^+}\frac{f_r}{F}(1-\cos\theta)^5\cos\theta_i\,\mathrm{d}w_i\]</span></p><figure><img src="/imgs/LearnPBR/uecode1.png" alt="uecode1" /><figcaption aria-hidden="true">uecode1</figcaption></figure><h3 id="the-split-sum-1st-stage-sample"><strong>The Split Sum: 1st StageSample</strong></h3><p>在上一节教程中，我们使用球面坐标生成均匀分布在半球 <spanclass="math display">\[\Omega\]</span>上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：</p><figure><img src="/imgs/LearnPBR/sample.png" alt="sample" /><figcaption aria-hidden="true">sample</figcaption></figure><p>所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。</p><p>F = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);</p><p>float3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st,sampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);</p><p>col += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;</p><figure><img src="/imgs/LearnPBR/uecode2.png" alt="uecode2" /><figcaption aria-hidden="true">uecode2</figcaption></figure><h3id="蒙特卡洛monte-carlo积分和重要性采样importance-sampling"><strong>蒙特卡洛(MonteCarlo)积分和重要性采样(Importance Sampling)</strong></h3><p><a href="https://zhuanlan.zhihu.com/p/146144853">蒙特卡洛积分 - 知乎(zhihu.com)</a></p><p>有了蒙特卡洛，那么如何对半球面上的进行采样。</p><h3 id="低差异序列"><strong>低差异序列</strong></h3><p>Hammersley 序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float RadicalInverse_VdC(uint bits)<br>&#123;<br>    bits = (bits &lt;&lt; 16u) | (bits &gt;&gt; 16u);<br>    bits = ((bits &amp; 0x55555555u) &lt;&lt; 1u) | ((bits &amp; 0xAAAAAAAAu) &gt;&gt; 1u);<br>    bits = ((bits &amp; 0x33333333u) &lt;&lt; 2u) | ((bits &amp; 0xCCCCCCCCu) &gt;&gt; 2u);<br>    bits = ((bits &amp; 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits &amp; 0xF0F0F0F0u) &gt;&gt; 4u);<br>    bits = ((bits &amp; 0x00FF00FFu) &lt;&lt; 8u) | ((bits &amp; 0xFF00FF00u) &gt;&gt; 8u);<br>    return float(bits) * 2.3283064365386963e-10; // / 0x100000000<br>&#125;<br>// ----------------------------------------------------------------------------<br>float2 Hammersley(uint i, uint N)<br>&#123;<br>    return float2(float(i)/float(N), RadicalInverse_VdC(i));<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/343666731">看懂蒙特卡洛积分(三)低差异采样序列</a> <ahref="https://zhuanlan.zhihu.com/p/20197323">低差异序列（一）-常见序列的定义及性质 - 知乎 (zhihu.com)</a> <ahref="https://zhuanlan.zhihu.com/p/20374706">低差异序列（二）-高效实现以及应用 - 知乎 (zhihu.com)</a></p><h4 id="ggx-重要性采样"><strong>GGX 重要性采样</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)<br>&#123;<br>    // use roughness for better view<br>    float alpha2 = roughness * roughness;<br><br>    float phi = 2.0 * PI * Xi.x;<br>    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));<br>    float sinTheta = sqrt(1 - cosTheta * cosTheta);<br><br>    float3 H;<br>    H.x = cos(phi) * sinTheta;<br>    H.y = sin(phi) * sinTheta;<br>    H.z = cosTheta;<br><br>    float3 up = abs(N.z) &lt; 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);<br>    float3 tangent = normalize(cross(up,N));<br>    float3 biTangent = normalize(cross(N, tangent));<br><br>    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;<br>    return normalize(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="the-split-sum">The Split Sum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// 1st<br>void PrefilteredColor(float3 dir, uint3 id)<br>&#123;<br>    float3 N = normalize(dir);<br>    float3 R = N;<br>    float3 V = R;<br><br>    const uint SAMPLE_COUNT = 1024;<br>    float totalWeight[5] = &#123;0.0, 0.0, 0.0, 0.0, 0.0&#125;;<br>    float3 preColor[5] = &#123; float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)&#125;;<br>    for(uint i = 0; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, SAMPLE_COUNT);<br>        float3 H[5];<br>        float3 L[5];<br>        float NdotL[5];<br>        for(uint a = 0; a &lt; 5; a++)<br>        &#123;<br>            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);<br>            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);<br>            NdotL[a] = max(0.0,dot(N,L[a]));<br>            if(NdotL[a] &gt; 0.0)<br>            &#123;<br>                float D = DistributeGGX(N, H[a], (float)a/5.0);<br>                float NdotH = max(0.0, dot(N, H[a]));<br>                float HdotV = max(0.0, dot(H[a], V));<br>                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;<br><br>                float res = 512.0;<br>                float saTexel = 4.0 * PI / (6.0 * res * res);<br>                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);<br>                float roughness = (float)a / 5.0;<br>                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); <br>                <br>                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];<br>                totalWeight[a] += NdotL[a];<br>            &#125;<br>        &#125;         <br>    &#125;<br>    int powLog = 1;<br>    for(uint b = 0; b &lt; 5; b++)<br>    &#123;    <br>        preColor[b] = preColor[b] / totalWeight[b];<br>        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);<br>        powLog *= 2;<br>    &#125;<br>&#125;<br><br>// 2nd<br>float2 IntegrateBRDF(float NdotV, float roughness)<br>&#123;<br>    float3 V;<br>    V.x = sqrt(1 - NdotV * NdotV);<br>    V.y = 0.0;<br>    V.z = NdotV;<br><br>    float A = 0.0;<br>    float B = 0.0;<br><br>    float3 N = float3(0.0, 0.0, 1.0);<br><br>    int sampleCount = 1024;<br>    for(int i = 0; i &lt; sampleCount; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, sampleCount);<br>        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF<br>        float3 L = normalize(2.0 * dot(V,H) * H - V);<br><br>        float NdotL = max(L.z, 0.0);<br>        float NdotH = max(H.z, 0.0);<br>        float VdotH = max(0.0, dot(V, H));<br><br>        if(NdotL &gt; 0.0)<br>        &#123;<br>            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G<br>            float G_Vis = (G * VdotH) / (NdotH * NdotV);    <br>            float Fc = pow(1 - VdotH, 5.0);<br>            <br>            A += (1.0 - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= float(sampleCount);<br>    B /= float(sampleCount);<br>    return float2(A, B);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射探针"><strong>反射探针</strong></h3><p>在unity中添加 probe 然后 baked</p><p>使用 sampleSH 对 probe 进行采样</p><h3 id="environment-diffuse-ibl-specular">Environment Diffuse + IBLSpecular</h3><figure><img src="/imgs/LearnPBR/output3.PNG" alt="output3" /><figcaption aria-hidden="true">output3</figcaption></figure><p>中间是粗糙度越来越小 下面是金属度越来越大</p><h3 id="ibl-参考"><strong>IBL 参考</strong></h3><p><ahref="https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/">ImageBased Lighting | Chetan Jags (wordpress.com)</a> <ahref="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">course_notes_moving_frostbite_to_pbr_v32.pdf(wordpress.com)</a>:4.9章节 <ahref="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/">镜面IBL- LearnOpenGL CN (learnopengl-cn.github.io)</a> <ahref="https://zhuanlan.zhihu.com/p/66518450">深入理解 PBR/基于图像照明(IBL) - 知乎 (zhihu.com)</a> <ahref="https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture5Real-time Environment Mapping哔哩哔哩bilibili</a>: Split Sum</p><h2 id="杂项"><strong>杂项</strong></h2><ul><li>ComputeShader 使用 cubetex：[<ahref="https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/">Computeshader] Use TextureCube(Resolved)</a></li><li>TextureCube&lt;float4 cubemap; SamplerState _LinearClamp; float3dir; cubemap.SampleLevel(_LinearClamp, dir, 0);</li><li>如何向Tex指定mipmap层级写入，在 setrendertarget 指定</li><li>compute Shader sample<ul><li><code>float4 c = tex[id];</code></li><li>mipmap: <code>float4 c = tex.mips[0][id]</code> or<code>tex.Load(uint3(id,0))</code></li><li>SampleLevel:</li><li>SampleState Sampler1 { Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4t = tex.SampleLevel(Sample1, uv, 0);</li></ul></li><li>Sample filter <a href="https://enjoyphysics.cn/Article1554">8.5纹理采样 (enjoyphysics.cn)</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// 在倍增、缩减、多级渐进纹理上使用线性过滤。<br>SamplerState mySampler0 <br>&#123;<br>    Filter = MIN_MAG_MIP_LINEAR; <br>&#125;; <br><br>// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。<br>SamplerState mySampler1 <br>&#123; <br>    Filter = MIN_LINEAR_MAG_MIP_POINT; <br>&#125;; <br><br>// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。<br>SamplerState mySampler2 <br>&#123; <br>    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; <br>&#125;; <br><br>// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。<br>SamplerState mySampler3 <br>&#123; <br>    Filter = ANISOTROPIC; <br>    MaxAnisotropy = 4;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="unity-and-mipmap"><strong>Unity And Mipmap</strong></h3><p><ahref="https://zhuanlan.zhihu.com/p/419644293">【渲染】用计算着色器生成Mipmap- 知乎 (zhihu.com)</a></p><h3 id="computer-指定-mipmap-写入"><strong>Computer 指定 Mipmap写入</strong></h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">computeShader.SetTexture(kernal, “<span class="hljs-keyword">name</span>”, tex, mipmapLevel);<br></code></pre></td></tr></table></figure><h3 id="不同光源的衰减"><strong>不同光源的衰减</strong></h3><p><ahref="https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/">投光物- LearnOpenGL CN (learnopengl-cn.github.io)</a> <ahref="https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/">Pointand Spot Lights (catlikecoding.com)</a></p><h4 id="point-light"><strong>Point Light</strong></h4><ul><li><span class="math inline">\((\,max(0,1-(\frac{d^2}{r^2})^2)\,)^2\)</span>，r 是 point light 的范围</li><li><spanclass="math inline">\(\frac{1.0}{K_c+K_l*d+K_q*d^2}\)</span></li></ul><h3 id="shadergui"><strong>ShaderGUI</strong></h3><p>通过编写 ShaderGUI 在 Material 面板控制 shader properties</p><p>或 en/dis able keyword</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">public class MyShaderGUI : ShaderGUI<br>&#123;<br>    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)<br>    &#123;<br>        base.OnGUI(materialEditor, properties);<br>        Material material = materialEditor.target as Material;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Shader 结尾加上</p><p>CustomEditor "MyLearnPBRGUI";</p><h2 id="urp-光"><strong>URP 光</strong></h2><p><ahref="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html">Light组件参考 | Universal RP | 12.1.1 (unity3d.com)</a> <ahref="https://docs.unity3d.com/cn/current/Manual/LightModes.html">光照模式- Unity 手册 (unity3d.com)</a> <ahref="https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html">光源模式：Baked- Unity 手册 (unity3d.com)</a></p><h3 id="lighting"><strong>Lighting</strong></h3><ul><li>Scene/Mixed Lighting/Lighting Mode<ul><li><strong>Baked Indirect</strong>: <ahref="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html">LightingMode：Baked Indirect - Unity 手册</a> 混合光源的行为类似于<ahref="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html">实时光源</a>，但有额外的好处是会<strong>将间接光照烘焙到光照贴图中</strong>。<strong>混合(Mixed)光源照亮的游戏对象会投射实时阴影</strong>，最大距离是在项目中定义的<ahref="https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html">阴影距离(Shadow Distance)</a>。</li><li><strong>Shadow Mask</strong>: <ahref="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html">LightingMode：Shadowmask - Unity 手册</a>与烘焙间接照明模式类似，阴影遮罩照明模式将<strong>实时直接照明</strong>与<strong><ahref="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html">烘焙间接照明</a>(BakedIndirect LightingMode)</strong>相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使Unity可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在<ahref="https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html">光照探针</a>中存储其他信息来实现此目的。Unity为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。</li><li><strong>Subtractive</strong>: <ahref="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html">LightingMode：Subtractive - Unity 手册</a> 在 Subtractive光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。因为阴影被烘焙到光照贴图中，所以 Unity在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity提供了 <strong>Realtime Shadow Color</strong>属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。Subtractive光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。</li></ul></li></ul><h2 id="isotropic-anisotropic-brdfs"><strong>Isotropic / AnisotropicBRDFs</strong></h2><p><span class="math display">\[f_r(\theta_i,\phi_i;\theta_r,\phi_r)\nef_r(\theta_i,\phi_i,\phi_r-\phi_i)\\i\;is\;input,\;r\;is\;reflection\;dir.\]</span></p><h3 id="ndf"><strong>NDF</strong></h3><p><strong>形状不变性</strong></p><ul><li><p>是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。</p></li><li><p>若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：</p></li><li><p><span class="math display">\[D(m)=\frac{1}{\alpha_2(n\cdotm)^4}g(\frac{\sqrt{1-(n\cdot m)^2}}{\alpha(n\cdot m)})\]</span></p></li><li><p>其中g（）代表一个表示了NDF形状的一维函数。</p></li></ul><h4 id="anisotropic-beckmann-distribution"><strong>Anisotropic BeckmannDistribution</strong></h4><p><spanclass="math display">\[D_{Baniso}(m)=\frac{1}{\pi\alpha_x\alpha_y(n\cdotm)^4}exp(-\frac{\frac{(t\cdot m)^2}{\alpha_x^2}+\frac{(b\cdotm)^2}{\alpha_y^2}}{(n\cdot m)^2})\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// Anisotropic Beckmann<br>float D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;<br>*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="trowbridge-reitz-ggx-anisotropic"><strong>Trowbridge-Reitz GGXAnisotropic</strong></h4><p><spanclass="math display">\[D_{GGXaniso}(m)=\frac{1}{\pi\alpha_x\alpha_y}\frac{1}{(\frac{(x\cdotm)^2}{\alpha_x^2}+\frac{(y\cdot m)^2}{\alpha_y^2}+(n\cdotm))^2}\]</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// Anisotropic GGX<br>// [Burley 2012, &quot;Physically-Based Shading at Disney&quot;]<br>float D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;<br>*    return 1 / ( PI * ax*ay * d*d );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中，X为tangent，t切线方向，Y为binormal，b，副法线方向</li><li>需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线</li></ul><p><ahref="https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf">2010-anisobrdf.pdf(cuni.cz)</a> <a href="https://www.shadertoy.com/view/3tyXRt">Slope: GGXAnisotropic (shadertoy.com)</a></p><h3 id="geometry-function"><strong>Geometry Function</strong></h3><p><span class="math display">\[G_1(m,v)=\frac{clamp(0,1,m\cdotv)}{1+\Lambda(v)}\]</span></p><h4 id="beckmann"><strong>Beckmann</strong></h4><p><spanclass="math display">\[\Lambda(v)=\frac{erf(a)-1}{2}+\frac{1}{2a\sqrt{\pi}}exp(-a^2)\\a=\frac{1}{\alpha\tan\theta_o}\]</span></p><h4 id="ggx"><strong>GGX</strong></h4><p><spanclass="math display">\[\Lambda(v)=\frac{-1+\sqrt{1+\frac{1}{a^2}}}{2}\\a=\frac{1}{\alpha\tan\theta_o}\]</span></p><h3 id="anisotropic-geometry-function"><strong>Anisotropic GeometryFunction</strong></h3><h4 id="smith"><strong>Smith</strong></h4><p>假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。</p><p>假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴</p><p><span class="math display">\[a_x&#39;=a_x\frac{a_y}{a_x}=a_y\\a_y&#39;=a_y\]</span></p><p>也就是粗糙度=_y</p><p><spanclass="math display">\[v&#39;=(\frac{\alpha_x}{\alpha_y}x_o,y_o,z_o)=(\frac{\alpha_x}{\alpha_y}\cos\phi_o\sin\theta_o,\sin\phi_o\sin\theta_o,\cos\theta_o)\\\frac{1}{\tan\theta&#39;_o}=\frac{z_o}{\sqrt{\frac{\alpha_x^2}{\alpha_y^2}x_o^2+y_o^2}}=\frac{1}{\sqrt{\frac{\alpha_x^2}{\alpha_y^2}\cos^2\phi_o+\sin^2\phi_o}\cdot\tan\theta_o}\\Because:a=\frac{1}{\alpha\tan\theta_o}\\a&#39;=\frac{1}{a_y\tan\theta_o}=\frac{1}{a_y\sqrt{\frac{\alpha_x^2}{\alpha_y^2}\cos^2\phi_o+\sin^2\phi_o}\cdot\tan\theta_o}\\=\frac{1}{\sqrt{\alpha_x^2\cos^2\phi_o+\alpha_y^2\sin^2\phi_o}\cdot\tan\theta_o}\]</span></p><p><ahref="https://blog.csdn.net/haozi2008/article/details/112284028">PBR 五几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客</a></p><p><ahref="https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md">PBR-White-Paper/content/part5/README.md at master · QianMo/PBR-White-Paper (github.com)</a></p><h3 id="output-1"><strong>Output</strong></h3><p><img src="/imgs/LearnPBR/output4-1.PNG" alt="output4-1" style="zoom:50%;" /></p><p><img src="/imgs/LearnPBR/AnisoSphere2.png" alt="AnisoSphere2" style="zoom:50%;" /></p><h3 id="anisotropic-ibl"><strong>Anisotropic IBL</strong></h3><h4 id="split-sum-2nd"><strong>Split Sum 2nd</strong></h4><p><span class="math display">\[R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\R_0-R_0(1-\cos\theta)^5+(1-\cos\theta)^5\\\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i\approx\\R_0\int_{\Omega^+}\frac{f_r}{F}(1-(1-\cos\theta)^5)\cos\theta_i\,\mathrm{d}w_i+\int_{\Omega^+}\frac{f_r}{F}(1-\cos\theta)^5\cos\theta_i\,\mathrm{d}w_i\]</span></p><p>roughness_x, roughness_y, theta 相关3D LUT了</p><h2id="todo动态天空的环境光怎么计算"><strong>[TODO]动态天空的环境光怎么计算</strong></h2><p>提前烘焙，插值。</p><p>TOD</p><p>像大气散射，其实已经计算了 LUT 所以可以直接使用。</p><h2 id="unity-specular-cube0">Unity Specular Cube0</h2><p><ahref="https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620">Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlslat 19518485b3edcf19f267f293f899d5d25e734a17 ·Unity-Technologies/Graphics (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);<br>    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);<br>    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);<br>    return irradiance * occlusion;<br></code></pre></td></tr></table></figure><h3id="perceptualroughnesstomipmaplevel">PerceptualRoughnessToMipmapLevel</h3><p><ahref="https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27">Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlslat 19518485b3edcf19f267f293f899d5d25e734a17 ·Unity-Technologies/Graphics (github.com)</a></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-built_in">real</span> PerceptualRoughnessToMipmapLevel(<span class="hljs-built_in">real</span> perceptualRoughness, <span class="hljs-built_in">uint</span> maxMipLevel)<br>&#123;<br>    perceptualRoughness = perceptualRoughness * (<span class="hljs-number">1.7</span> - <span class="hljs-number">0.7</span> * perceptualRoughness);<br><br>    <span class="hljs-keyword">return</span> perceptualRoughness * maxMipLevel;<br>&#125;<br></code></pre></td></tr></table></figure><p>SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0,reflectVector, mip);</p><h2 id="参考-3"><strong>参考</strong></h2><p><ahref="https://www.cnblogs.com/timlly/p/10631718.html">由浅入深学习PBR的原理和实现- 0向往0 - 博客园 (cnblogs.com)</a><br /><ahref="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">course_notes_moving_frostbite_to_pbr_v32.pdf(wordpress.com)</a><br /><ahref="https://zhuanlan.zhihu.com/p/53086060">【基于物理的渲染（PBR）白皮书】（一）开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)</a><br /><a href="https://www.pbr-book.org/3ed-2018/contents">Physically BasedRendering: From Theory to Implementation (pbr-book.org)</a><br />Real-Time Rendering Fourth Edition 第九章<br /><ahref="https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture10Real-Time Physically-based Materials (surfacemodels)哔哩哔哩bilibili</a><br /><ahref="https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture11Real-Time Physically-based Materials (surface modelscont.)哔哩哔哩bilibili</a><br />UE4: <ahref="https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">2013SiggraphPresentationsNotes-26915738.pdf(unrealengine.com)</a><br /><ahref="https://zhuanlan.zhihu.com/p/144611412">寒霜引擎的PBR实践3.0（一）材质篇- 知乎 (zhihu.com)</a><br /><ahref="https://zhuanlan.zhihu.com/p/158261389">寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源- 知乎 (zhihu.com)</a><br /><ahref="https://zhuanlan.zhihu.com/p/186541854">寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光- 知乎 (zhihu.com)</a><br />[<a href="https://zhuanlan.zhihu.com/p/121719442">译]Real Shading inUnreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)</a><br /><ahref="https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/">使用ComputeShader计算球谐全局光照 | ZZNEWCLEAR13</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大气散射</title>
    <link href="/2023/11/05/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/"/>
    <url>/2023/11/05/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1id="raymarchingatmospheric-scattering-rayleighscattering">RayMarching:AtmosphericScattering-RayleighScattering</h1><h2 id="rayleigh-scattering">Rayleigh Scattering</h2><p>一般的渲染都是在物体的一个表面上进行计算，而诸如半透明物体是光线和其内部结构相互作用造成的，还有比如皮肤的渲染，可以用次表面散射去模拟这种效果。但是大气散射不是在表面上计算，是模拟光线透过大气会发生什么，也就是体积渲染。这里是学习<strong>体积单散射</strong>，渲染实体半透明物体。 ## Single Scattering大多数游戏引擎的光线都是在真空传播，散射需要做的就是模拟光在空气介质中传播。## Out Scattering &amp; In Scattering光和粒子最显著的现象就是粒子偏转光的方向，当一束光偏离 Camera也就是外散射，偏离到 Camera 方向就是 <strong>内散射</strong>。</p><p><img src="/imgs/大气散射/OutScattering.png"></p><h2 id="volumetric-signle-scattering"><strong>Volumetric SignleScattering</strong></h2><p>实际上光可以反射/散射很多次，但是这需要大量计算，这里只是计算<strong>光的单次散射事件</strong>。</p><p>关键在于如何模拟光线穿过大气。 即从 A 到 B的光如何受到散射的影响，因为 AB 上任一点 P 都可能会发生散射。</p><figure><img src="/imgs/大气散射/SingleScattering.PNG" alt="SingleScattering" /><figcaption aria-hidden="true">SingleScattering</figcaption></figure><p>所以在计算每个点 P 有多少 Out Scattering时，第一步要先知道 P点有多少光。假设所有光都来自太阳，一些会发生in-Scattering，转向摄像机:</p><figure><img src="/imgs/大气散射/InScattering.PNG" alt="InScattering" /><figcaption aria-hidden="true">InScattering</figcaption></figure><p>内散射到 P，从 P 到 A 散射，能够描述大部分散射情况，但实际上 P点接收的光，是太阳射向P并经过 CP 路径的 out-scattering后的。</p><figure><img src="/imgs/大气散射/OutScattering2.PNG" alt="OutScattering2" /><figcaption aria-hidden="true">OutScattering2</figcaption></figure><h2id="需要做的可公开的情报"><strong>[需要做的]可公开的情报</strong></h2><ul><li>摄像机的视线，从 A 出发，进入大气，并从 B 点离开。</li><li>我们需要考虑每个点 P∈AB 的 in-scattering 和 out-scattering贡献/影响。</li><li>P 点从太阳接收的光线</li><li>P 点经路径CP接受光，收到 out-scattering 的影响</li><li>P 点发生多少 in-scattering，使光线向相机方向。</li><li>从 P 射向摄像机的光受到 out-scattering 影响偏离相机的视线。</li></ul><h2 id="transmittance-function"><strong>TransmittanceFunction</strong></h2><p>要计算传播到 Camera的有多少光，那么所有的计算应该在光线从太阳出发开始；</p><p>上图中光经过真空到达C点，其路径上没有其他物体影响，C点的光还没有散射；设 C点的光量为 Ic，全部从太阳接收，从太阳真空传播过来，无散射影响。经过路径CP，光线进入大气，和大气中的粒子发生散射，到达P的光量为Ip(肯定小于Ic) 则 Ip和Ic的比率为 <strong>transmittance</strong>:</p><p><span class="math display">\[ T(\overline{CP})=\frac{I_P}{I_C}\]</span></p><figure><img src="/imgs/大气散射/Trasmittance.png" alt="Trasmittance" /><figcaption aria-hidden="true">Trasmittance</figcaption></figure><p>可以用 transmittance 表示在 CP 路径上为散射的光量百分比，也就是经过CP 后能到得到的光量。这个函数我们后面会进行更详细的推导。</p><p><span class="math display">\[ I_P=I_CT(\overline{CP}) \]</span></p><h2 id="scattering-function"><strong>Scattering Function</strong></h2><p>假设我们先不考虑 <strong>Transmittance Function</strong><em>T</em>，然后我们得到了P点的光量，我们现在需要考虑的就是在P点有多少光因为 scattering 偏转到camera 方向。 也就是 <strong>Scattering Function</strong><em>S</em>，目的是描述某点处，有多少光沿某个角度发生偏转。</p><p>这里光的偏转角度为 θ，<em>S</em>(λ,θ,h)的值表示沿theta偏转的光量比率。受到波长，角度，高度的影响，高度是因为大气密度会随高度而改变。</p><p><span class="math display">\[I_{PA}=I_P*S(\lambda,\theta,h)*T(\overline{PA})\\I_{PA}=I_C*T(\overline{CP})*S(\lambda,\theta,h)*T(\overline{PA})\\=\underbrace{I_C*S(\lambda,\theta,h)}_{in-scattering}*\underbrace{T(\overline{CP})*T(\overline{PA})}_{out-scattering}\\\]</span></p><figure><img src="/imgs/大气散射/ScatteringFunc.png" alt="ScatteringFunc" /><figcaption aria-hidden="true">ScatteringFunc</figcaption></figure><p>S 计算折射到视线，T算的沿路径的损失，就是in-scattering 和out-scattering</p><h2 id="numerical-integration"><strong>NumericalIntegration</strong></h2><p>看起来挺好，但可能你已经意识到了，这不太对吧，用 Ipa 表示 点P 传输到A 的光量，但是刚才的公式并不能描述 A 所有接受到的光。 A接收的光应该是P∈AB 所有点的累加贡献，我们应该计算 AB上所有的点，这需要用到积分的思想，将AB划分为无数的微小段——ds，再进行累加，就是数值积分。</p><p><span class="math display">\[ I_A=\sum_{P\in\overline{AB}}I_{PA}ds\]</span></p><figure><img src="/imgs/大气散射/NumericalIntegration.png"alt="NumericalIntegration" /><figcaption aria-hidden="true">NumericalIntegration</figcaption></figure><ul><li>为什么要乘 ds 因为用 ds 中一个点 P0代表所有这段上所有点的光线如何散射</li></ul><blockquote><p>假设不划分，以 E 为 AB 每个点的光照散射结果，那么 IA = E * dis_AB</p></blockquote><h2 id="direcation-light"><strong>Direcation Light</strong></h2><p>如果离太阳近可以建模点光源解决，不过通常我们都离太阳很远，而且这里最终目的是做山麓之间的那种大气散射，所有还是以direction light 建模。 因此每个点接收相同数量的光，且方向保持不变。</p><p>现在可以对 IC 进行简化。</p><p><span class="math display">\[ I_A=\sum_{P\in\overline{AB}}I_{PA}ds\\\=\sum_{P\in\overline{AB}}I_C*S(\lambda,\theta,h)*T(\overline{CP})*T(\overline{PA})ds\\=I_S\sum_{P\in\overline{AB}}S(\lambda,\theta,h)*T(\overline{CP})*T(\overline{PA})ds\\\]</span></p><figure><img src="/imgs/大气散射/DirectionLight.png" alt="DirectionLight" /><figcaption aria-hidden="true">DirectionLight</figcaption></figure><blockquote><p>如果这里阳光和camera 都不动，theta 固定，甚至还可以优化</p></blockquote><h2 id="absorption-coefficient"><strong>AbsorptionCoefficient</strong></h2><blockquote><p>在描述光和空气分子之间相互作用的可能结果时，我们只介绍了两个。直接通过，或偏转。还有第三种可能。一些化合物吸收光。地球上的大气中有很多具有这种特性的化学物质。例如，臭氧存在于高等大气中，并且已知对紫外线有强烈反应。然而，它的存在对天空的颜色几乎没有影响，因为它吸收了可见光谱之外的光。在地球上，吸光化学物质的贡献往往被忽视。在地球上，吸光化学物质的贡献往往被忽视。其他行星不能这样做。例如，海王星和天王星的典型颜色是由大气中大量存在的甲烷引起的。甲烷以吸收红光而闻名，导致蓝色色调。在本教程的其余部分，我们将忽略吸收系数，尽管我们将添加一种为大气着色的方法。</p></blockquote><h2 id="scattering-model"><strong>Scattering Model</strong></h2><p>模拟大气散射现象是十分复杂的，几乎没有一个完美的模型去描述。通常使用两种模型 : <strong>Rayleigh scattering</strong> 和 <strong>Miescattering</strong>. Rayleigh Scattering描述光和微小粒子的散射，比如空气，氧、氮分子。 Mie Scattering描述的是光的波长和粒子大小相近的散射情况，比如用 Mie scattering画太阳，花粉、粉尘、污染物。</p><p>Rayleigh Scattering 导致天空是蓝的，日落是红的，Mie Scattering导致云是白的。</p><h2 id="rayleigh-scattering-1"><strong>Rayleigh Scattering</strong></h2><p>需要明确的一点是 Rayleigh Scattering 只能描述粒子小于光的波长。当光子撞击到粒子后，因为粒子足够小，主要有两部分光，一部分不受影响继续传播，一部分以相反方向反射回来，其他可能沿其他方向传播，不过因为光的方向导致其不太可能沿90° 。</p><blockquote><p>可以想象一个胖人去撞一个比较瘦的人，或者撞一根很细的柱子</p></blockquote><figure><img src="/imgs/大气散射/RayleighScattering.png"alt="RayleighScattering" /><figcaption aria-hidden="true">RayleighScattering</figcaption></figure><p>其 <strong>Rayleigh scattering equation</strong></p><p><span class="math display">\[ I=I_0S(\lambda,\theta,h)\\S(\lambda,\theta,h)=\frac{\pi^2(n^2-1)^2}{2}\underbrace{\frac{\rho(h)}{N}}_{density}\overbrace{\frac{1}{\lambda^4}}^{wavelength}\underbrace{(1+\cos^2\theta)}_{geometry}\]</span></p><ul><li>λ: the <strong>wavelength</strong> of the incoming light;</li><li>θ : the <strong>scattering angle</strong>;</li><li>h : the <strong>altitude</strong> of the point;</li><li>n=1.00029 : the <strong>refractive index</strong> ofair;(空气的<strong>折射率</strong>)</li><li>: the <strong>molecular number density</strong> of the standardatmosphere. This is the number of molecules per cubicmetre;(标准大气的<strong>分子数密度</strong>。这是每立方米的分子数;)</li><li>: the <strong>density ratio</strong>. This number is equal to</li><li>at sea level, and decreases exponentially with</li><li>. There is a lot to say about this function, and we will do it in afuture post of this series.(<strong>密度比</strong>。此数字等于海平面1时的数字，后面细嗦)</li></ul><p>该方程来自：<ahref="http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf">nishitalab.org/user/nis/cdrom/sig93_nis.pdf</a></p><figure><img src="/imgs/大气散射/chart.png" alt="chart" /><figcaption aria-hidden="true">chart</figcaption></figure><ul><li>某些方向比其他方向接收更多光</li><li>散射的光量多少受光波长的影响，波长越长越少，红少蓝多(所以天是蓝的)</li></ul><h2 id="rayleigh-scattering-coefficient"><strong>Rayleigh ScatteringCoefficient</strong></h2><p>前面的Rayleigh只描述了散射的方向，但是没有描述某一点散射现象的能量衰减。要考虑能量的损失，我们得考虑各个方向上的光能的散射。很简单对相位函数做积分即可，不过记得这是一个三维空间，不是二维的可别在[0,2pi] 积分。</p><p><span class="math display">\[\beta(\lambda,h)=\int_0^{2\pi}\int_0^\pi S(\lambda,\theta,h)\sin\thetad\theta d\phi\\=\int_0^{2\pi}\int_0^\pi\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}(1+\cos^2\theta)\sin\thetad\thetad\phi\\  =\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\int_0^{2\pi}\int_0^\pi(1+\cos^2\theta)\sin\thetad\thetad\phi\\  =\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\int_0^{2\pi}\int_0^\pi(\sin\theta+\sin\theta\cos^2\theta)d\thetad\phi\\  =\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\int_0^{2\pi}(\cos0+\frac{\cos0}{3}-\cos\pi-\frac{\cos^3\pi}{3})d\phi\\=\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\int_0^{2\pi}\frac{8\pi}{3}d\phi\\=\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\frac{16\pi}{3}\\=\frac{8\pi^3(n^2-1)^2}{3}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\\\\  \beta(\lambda,h)  =\frac{8\pi^3(n^2-1)^2}{3}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\\\]</span></p><p>所以能量的散射受波长和海拔高度的影响。</p><figure><img src="/imgs/大气散射/chart2.png" alt="chart2" /><figcaption aria-hidden="true">chart2</figcaption></figure><p>所以地球大气分子会更多反射蓝光，所以当傍晚时，光线要经过更多大气，传播时间更长，所有的蓝光基本都被散射，我们观察到的就是红色的天空。而白天天空为什么是蓝色的，首先，白天我们观察时日光方向基本固定，因为蓝色更容易发生散射，在空中蓝色光波被散射到四面八方，我们观察天空接收到的自然也就是蓝光。</p><h2 id="rayleigh-phase-function"><strong>Rayleigh PhaseFunction</strong></h2><p>关于 Rayleigh Scattering Equation 可以分解为两个部分，一部分是Rayleig Scattering Coefficient，也就是刚刚推导的；另一部分是 Geometry ofScattering，并控制其反射方向。</p><p><span class="math display">\[S(\lambda,\theta,h)=\beta(\lambda,h)\gamma(\theta)\\\gamma(\theta)=\frac{S(\lambda,\theta,h)}{\beta(\lambda,h)}=\\\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}(1+\cos^2\theta)\frac{3}{8\pi^3(n^2-1)^2}\frac{N}{\rho(h)}\lambda^4=\\\frac{3}{16\pi}(1+\cos^2\theta) \]</span></p><h2 id="可公开的情报"><strong>[可公开的情报]</strong></h2><ul><li><strong>Rayleigh Scattering Equation</strong>描述在某方向的光偏转比率</li></ul><p><span class="math display">\[S(\lambda,\theta,h)=\frac{\pi^2(n^2-1)^2}{2}\frac{\rho(h)}{N}\frac{1}{\lambda^4}(1+\cos^2\theta)\\S(\lambda,\theta,h)=\beta(\lambda,h)\gamma(\theta) \]</span></p><ul><li><strong>Rayleigh Scattering Coefficient</strong>在某点发生散射后，多少比例的能量损失情况</li></ul><p><span class="math display">\[\beta(\lambda,h)=\frac{8\pi^3(n^2-1)^2}{3}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\\\]</span></p><ul><li><p><strong>Rayleigh Scattering Coefficient in Sealevel</strong></p></li><li><p><span class="math display">\[\beta(\lambda,0)=\frac{8\pi^3(n^2-1)^2}{3}\frac{1}{N}\frac{1}{\lambda^4}\\\]</span></p></li><li><p><strong>Rayleigh Scattering Phase Function</strong>描述散射的形状，在特定方向光的损失相对比率。</p></li><li><p><span class="math display">\[\gamma(\theta)=\frac{3}{16\pi}(1+\cos^2\theta) \]</span></p></li><li><p><strong>Density ratio</strong> 模拟大气密度的函数</p></li><li><p><span class="math display">\[ \rho(h)=\exp(\frac{h}{H})\]</span></p></li></ul><p>H = 8500 是 scale heigh</p><h2 id="atmospheric-density-ratio"><strong>Atmospheric DensityRatio</strong></h2><p>当大气密度越大时大气中粒子越多，会有更多的散射现象发生。大气密度和高度示意图：</p><figure><img src="/imgs/大气散射/height.png" alt="height" /><figcaption aria-hidden="true">height</figcaption></figure><p>H 为 Scale Height，通常取 8500</p><h2 id="exponential-decay"><strong>Exponential Decay</strong></h2><p>我们前面的得到了 <strong>scattering coefficient</strong><em>β</em>，我们有能求得解析解的 close form 函数</p><p><span class="math display">\[\beta(\lambda,h)=\frac{8\pi^3(n^2-1)^2}{3}\frac{\rho(h)}{N}\frac{1}{\lambda^4}\\\]</span></p><p>上式描述了<strong>光和粒子单次散射后</strong>光量损失的比例。</p><p>现在假设如果初始光量为I0，然后以衰减系数为β，经过大气中粒子的一次散射后所剩的光量会是：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p><p><span class="math display">\[I_1=\underbrace{I_0}_{initial\;energy}-\underbrace{I_0\beta}_{energy\;lost}=(1-\beta)I_0\]</span></p><p>但这只适用于一次散射/单次散射碰撞，我们希望求得<strong>在一均匀介质中</strong>，传播一定距离后光的衰减：假设我们将这个过程分为两次散射看待，考虑两次散射：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p><p><span class="math display">\[First\;Scattering\;:\;I_1=I_0(1-\beta\frac{S}{2})\\Second\;Scattering\;:\;I_2=I_1(1-\beta\frac{S}{2})=I_0(1-\beta\frac{S}{2})^2\\About\;N\;Scattering\;:\;I=\lim_{n\rightarrow\infty}I_0(1-\beta\frac{S}{n})^n=\exp\{-\betaS\} \]</span></p><h2 id="uniform-transmittance"><strong>UniformTransmittance</strong></h2><p><strong>transmittance</strong> T描述了光量穿越大气时经过散射所剩余的光量比例。</p><figure><img src="/imgs/大气散射/OutScattering2.PNG" alt="OutScattering2" /><figcaption aria-hidden="true">OutScattering2</figcaption></figure><p>根据刚才的欧拉数推导我们能写出一个 P位置光量</p><p><span class="math display">\[ I_P=I_S\exp\{-\beta\overline{CP}\}\\\overline{CP}:\;distance \; of \; CP \]</span></p><p>但实际上CP中的散射系数β不是一个均匀值我们延续前面类似的思路，将CP分为两段CQ，QP</p><figure><img src="/imgs/大气散射/Trasmittance2.png" alt="Trasmittance2" /><figcaption aria-hidden="true">Trasmittance2</figcaption></figure><p><span class="math display">\[I_Q=I_S\exp\{-\beta(\lambda,h_0)\overline{CQ}\}\\I_P=I_Q\exp\{-\beta(\lambda,h_1)\overline{QP}\}\\I_P=I_S\exp\{-\beta(\lambda,h_0)\overline{CQ}\}\exp\{-\beta(\lambda,h_1)\overline{QP}\}\\I_P=I_S\exp\{-\beta(\lambda,h_0)\overline{CQ}-\beta(\lambda,h_1)\overline{QP}\}\]</span></p><p>如果CQ和QP长度相同还可以再次简化，那不妨设其相同且为<strong><em>ds</em></strong> (方便后面采用积分思想推导)</p><p><span class="math display">\[I_P=I_S\exp\{-(\beta(\lambda,h_0)+\beta(\lambda,h_1))ds\} \]</span></p><p>延续该思路我们可以将 CP段化为无数等长的小段，累加这个过程,也就是数值积分</p><p><span class="math display">\[I_P=I_S\exp\{-\sum_{Q\in\overline{CP}}\beta(\lambda,h_Q)ds\}\]</span></p><p>将 Rayleigh Scattering 带入</p><p><span class="math display">\[T(\overline{CP})=I_S\exp\{-\sum_{Q\in\overline{CP}}\frac{8\pi^3(n^2-1)^2}{3}\frac{\rho(h_Q)}{N}\frac{1}{\lambda^4}ds\}\\=\underbrace{-\frac{8\pi^3(n^2-1)^2}{3}\frac{1}{N}\frac{1}{\lambda^4}}_{constant\;\beta(\lambda)}\overbrace{\sum_{Q\in\overline{CP}}\rho(h_Q)ds}^{optical\;depth\;D(\overline{CP})}\\\]</span></p><p>求和部分为 Optical Depth ，需要我们在 shader中计算，其他都是常数。</p><p><span class="math display">\[T(\overline{CP})=\exp\{-\beta(\lambda)D(\overline{CP})\} \]</span></p><h2 id="intersecting-the-atmosphere"><strong>Intersecting theAtmosphere</strong></h2><blockquote><p>这个教程是渲染星球的</p></blockquote><p>所以其要求 AB 的 optical depth，其中 O 点是大气层表面一点也就是我们的fragment</p><figure><img src="/imgs/大气散射/math.png" alt="math" /><figcaption aria-hidden="true">math</figcaption></figure><p>D 是 camera 的视线方向，L外壳半径，R大气半径</p><p><span class="math display">\[ A=O+D\overline{OA}\\B=O+D\overline{OB}\\ \overline{OA}=\overline{OT}-\overline{AT}\\\overline{OB}=\overline{OT}+\overline{TB}\\\overline{AT}=\overline{TB}\\ \overline{OT}=(C-O)\cdot D=L\cdot D\\R^2=(\overline{CT})^2+(\overline{AT})^2\\(\overline{CT})^2=L^2-(\overline{OT})^2\\(\overline{AT})^2=R^2-(\overline{CT})^2 \]</span></p><p>如果 CT 大于 R 则无解</p><h3 id="colliding-with-the-planet"><strong>Colliding with thePlanet</strong></h3><p>和 plant 相交 只需要按和大气球求交点再求一次和plant球的交点即可如果有解则 大气的 B点要改为 plant 的A点</p><figure><img src="/imgs/大气散射/math2.png" alt="math2" /><figcaption aria-hidden="true">math2</figcaption></figure><h2 id="sampling-the-view-ray"><strong>Sampling the ViewRay</strong></h2><p><span class="math display">\[ I=I_S\sum_{P\inAB}S(\lambda,\theta,h)T(\overline{CP})T(\overline{PA})ds\\\\ Decompose\;S(\lambda,\theta,h):\\S(\lambda,\theta,h)=\beta(\lambda,h)\gamma(\theta)=\beta(\lambda)\rho(h)\gamma(\theta)\\\beta(\lambda)=\frac{8\pi^3(n^2-1)^2}{3N\lambda^4}\\\rho(h)=\exp\{-\frac{h}{H}\}\\\gamma(\theta)=\frac{3}{16\pi}(1+\cos^2(\theta))\\We\;get:I=I_S\beta(\lambda)\gamma(\theta)\sum_{P\inAB}\underbrace{T(\overline{CP})T(\overline{PA})\rho(h_P)ds}_{light\;contribution\;of\;L(P)}\\\]</span></p><p><span class="math display">\[ For\;T(\overline{Dis}):\\T(\overline{CP})T(\overline{PA})=\exp\{-\beta(\lambda)D(\overline{CP})\}\exp\{-\beta(\lambda)D(\overline{PA})\}\\=\exp\{-\beta(\lambda)(D(\overline{CP})+D(\overline{PA}))\}\\D(\overline{CP})=\sum_{Q\in CP}\exp\{-\frac{h_Q}{H}\}dt\\D(\overline{PA})=\sum_{Q\in AP}\exp\{-\frac{h_P}{H}\}dx\\\\I=I_S\beta(\lambda)\gamma(\theta)\sum_{P\inAB}\underbrace{T(\overline{CP})T(\overline{PA})\rho(h)ds}_{light\;contribution\;of\;L(P)}\\\]</span></p><p><span class="math display">\[ \sum_{P\inAB}T(\overline{CP})T(\overline{PA})\rho(h_P)ds=\sum_{P\inAB}\rho(h_P)\exp\{-\beta(\lambda)(D(\overline{CP})+D(\overline{PA}))\}ds\\实际上 D(\overline{PA}) 可以在最外层循环\sum_{P\in AB}做累加,\\不必每次在里面的循环做，即不必每次从A开始累加 \]</span></p><h2 id="to-domie-scattering"><strong>[To Do]Mie Scattering</strong></h2><p>和波长无关，只和粒子大小相干</p><p><span class="math display">\[ phase\;function:\\ S(\theta)=\frac{1}{4\pi}\frac{3(1-g^2)}{(1-2g\cos\theta+g^2)^{\frac{3}{2}}}\\or:S(\theta)=\frac{3}{8\pi}\frac{1-g^2}{2+g^2}\frac{1+\cos^2\theta}{(1-2g\cos\theta+g^2)^{\frac{3}{2}}}\]</span></p><h1 id="待更新">待更新</h1><p>我们知道了基本的计算思路，但是实际实现还有所不同，后面陆续更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio 解决项目默认的配置奇奇怪怪的问题</title>
    <link href="/2023/08/28/VisualStudioPro/"/>
    <url>/2023/08/28/VisualStudioPro/</url>
    
    <content type="html"><![CDATA[<p>因为之前年轻配环境的时候不懂事，那时候应该是配OpenCv直接配到用户默认的项目配置里面去了，不小心修改了默认的配置。</p><span id="more"></span><h1 id="修改默认配置">修改默认配置</h1><h2 id="第一步">第一步：</h2><p>打开：视图-&gt;属性管理器<br /><img src="/imgs/VisualStudioPro/Vs1.png"></p><p>顺利的话会在右侧看见对应的窗口，然后修改 对应的Microsoft.Cpp.x64.user(这个对应你自己要用的啊，我这里只用了Debug|x64)<br /><img src="/imgs/VisualStudioPro/Vs2.png"></p><p>后面应该不用教了吧，该配置里的库引用啊，lib还有连接器什么的……<br />这个都不会的话，可以多做几个需要外部库的项目，比如LearnOpenGL<br />然后可以理解一些编译，链接的东西，不是说去啃编译原理，我之前看过也不懂，做几个项目，或者看看视频，比如b站奇乐的有一期讲make还是cmake的我忘了，了解大概就行。<br />这个没什么技术难度，就是项目见的多少。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11 多线程</title>
    <link href="/2023/08/21/C++11%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/08/21/C++11%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://www.bilibili.com/video/BV1Ya411q7y4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">小彭老师</a></p><p>之前一直没有系统学过，最近心里也很乱，听一下小彭老师然后自己整理了一些。</p><span id="more"></span><h1 id="multithreading">Multithreading</h1><h2 id="time">Time</h2><h3 id="c11-标准库stdchrono">C++11 标准库：<code>std::chrono</code></h3><ul><li><p>利用 C++ 强类型的特点，明确 <strong>时间点</strong> 和<strong>时间段</strong>，区分不同的<strong>时间单位</strong>。</p></li><li><p>时间点：2023年8月22日 21点38分54秒</p></li><li><p>时间段：2分20秒</p></li><li><p>时间点类型：<code>chrono::steady_clock::time_pointer</code>等</p></li><li><p>时间段类型：<code>chrono::milliseconds</code>,<code>chrono::seconds</code>, <code>chrono::minutes</code> 等等。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> t0 = chrono::stready_clock::<span class="hljs-built_in">now</span>();<span class="hljs-comment">// 当前时间点  </span><br><span class="hljs-keyword">auto</span> t1 = t0 + chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">30</span>);<span class="hljs-comment">// 当前时间30s后  </span><br><span class="hljs-keyword">auto</span> dt = t1 - t0;<span class="hljs-comment">// 两个时间点的差，时间段  </span><br><span class="hljs-type">int64_t</span> sec = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::seconds&gt;(dt).<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 获取时间差的秒数  </span><br><span class="hljs-type">double</span> ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="hljs-type">double</span>, std::million&gt;&gt;(dt).<span class="hljs-built_in">count</span>();  <br></code></pre></td></tr></table></figure></p><p>std::chrono::duration&lt;T, R&gt; , 用 T 类型表示，单位为R，单位不写默认为秒。<br />std::chrono::second 是 std::chrono::duration<int_64> 的类型别名</p></li></ul><h4 id="跨平台-sleepstdthis_threadsleep_for">跨平台sleep：<code>std::this_thread::sleep_for</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">480</span>));<br></code></pre></td></tr></table></figure><ul><li>milliseconds 毫秒<br /></li><li>microseconds 微秒<br /></li><li>seconds</li></ul><h4id="stdthis_threadsleep_until"><code>std::this_thread::sleep_until</code></h4><p>睡到某个时间点<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> t = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">400</span>);<br>std::this_thread::<span class="hljs-built_in">sleep_until</span>(t);<br></code></pre></td></tr></table></figure></p><h2 id="thread">Thread</h2><ul><li><strong>进程</strong>：我们的一个程序就是一个进程<br /></li><li><strong>线程</strong>：线程是进程中的实体，是系统调度、分配的最小单位。<br />进程本身不能获取 CPU 时间，而线程可以。<br /></li><li>每个线程共享内存空间，开销较小。<br /></li><li>每个进程拥有独立的内存空间，因此开销更大。</li></ul><h4 id="为什么需要多线程">为什么需要多线程</h4><p>可以实现无阻塞的多任务程序。<br />做到程序的异步实现。</p><ul><li>比如：下载器，下载一个大文件的同时还需要和用户进行交互。<br />这个时候下载文件 和 用户交互就是一个进程的两个任务。<br />如果不使用线程，纯串行，在下载时用户就无法操作了，只能等待下载完毕。<br /></li><li>不用多进程是因为，进程的地址独立，进程间沟通困难，消耗资源更多。</li></ul><h3 id="c-多线程stdthread">C++ 多线程：<code>std::thread</code></h3><ul><li><code>std::thread</code> 构造函数的参数可以是任意的 lambda表达式。<br /></li><li>当线程启动，就会指向 lambda 里的内容。</li></ul><h4 id="错误找不到符号-pthread_thread">错误：找不到符号<code>pthread_thread</code></h4><p>这是因为 <code>std::thread</code> 是基于<code>pthread</code>的，<br />所以在 CMakeLists.txt 里链接 Threads::Threads 即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-keyword">project</span>(threadDemo LANGUAGES CXX)<br><br><span class="hljs-keyword">add_executable</span>(threadDemo main.cpp)<br><br><span class="hljs-keyword">find_package</span>(Threads REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(threadDemo PUBLIC Threads::Threads)<br></code></pre></td></tr></table></figure><p>就是这两行：<br /><code>find_package(Threads REQUIRED)</code><br /><code>target_link_libraries(threadDemo PUBLIC Threads::Threads)</code></p><h3 id="主线程等待子线程">主线程等待子线程</h3><p>在我们退出主线程时，可能子线程还未执行完毕。<br />可以使用 std::thread 类的 join() 来等待某一个进程的结束。<br />我们可以使用 joinable() 判断 thread 对象是否还对线程有管理权限。</p><h3 id="stdthread-的解构函数会销毁线程">std::thread的解构函数会销毁线程</h3><ul><li>作为 C++ 类同样遵循 RAII 思想，线程实际也是一种资源。<br />thread自定义了解构函数，删除了拷贝构造函数、拷贝赋值函数，但提供了移动构造函数、移动复制函数。</li></ul><h3id="析构函数不再销毁线程t1.detach">析构函数不再销毁线程：t1.detach()</h3><p>调用成员函数 detach() 可以将线程和 std::thread 对象分离。<br />意味着 线程 的生命周期不再由当前 std::thread对象管理，而在线程退出以后自动销毁自己。<br />不过这也还是会在进程结束后，自动退出，因为进程结束会调用 terminal销毁全部线程。</p><h3id="析构函数不再销毁线程自己构建全局线程池">析构函数不再销毁线程：自己构建全局线程池</h3><p>如果不想，detach 后线程还未执行完毕就销毁。<br />可以自己建一个全局的线程池，创建线程就 push 进去，在程序结束前 逐个 join即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::thread&gt; poll;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        download(<span class="hljs-string">&quot;hello.zip&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    pool.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(t1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;th : pool) th.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="改进一下">改进一下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br>    std::vector&lt;std::thread&gt; m_pool;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(std::thread thr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_pool.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(thr));<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">ThreadPool</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t : m_pool) t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;;<br><br>ThreadPool tpool;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        download();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    tpool.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(t1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c20-引入-stdjthread符合-raii-思想解构时自动-join">C++20 引入<code>std::jthread</code>：符合 RAII 思想，解构时自动 join()</h3><ul><li>C++ 20 的 <code>std::jthread</code> 和 <code>std::thread</code>的不同在于，其解构函数会自动调用 join()函数，让线程等待，直到完全执行。</li></ul><h2 id="碎碎念">碎碎念</h2><p>python 没有线程，其实是 并发而非并行。<br />blender 也用了 怕python 而且 ui层由OpenGL渲染出来，所以很多都是单线程会出现等待不能操作的结果。</p><p>OpenGL 和 DX12相比就是，DX12是支持多线程的可以做到真正的并发，计算性能会提升很多。</p><h2 id="异步">异步</h2><h3 id="stdasync"><code>std::async</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">download</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// do something a long time</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">interact</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string name;<br>    std::cin &gt;&gt; name;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hi, &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; fret = std::<span class="hljs-built_in">async</span>([&amp;]&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">download</span>();<br>    &#125;);<br>    <span class="hljs-built_in">interact</span>();<br>    <span class="hljs-type">int</span> ret = fret.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result is:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>std::async</code> 接受一个带有返回值的 lambda，自身返回一个<code>std::future</code> 对象。<br />这个 future 是什么意思呢？在 <code>std::future&lt;int&gt; fret=..</code>这里 fret 的返回值是 <code>int</code>，意思就是这个 int现在还没有，但是我保证以后一定会有。<br /></li><li>这 <code>async</code> 里的 lambda并非立即执行，而是在后台会挂起一个线程默默执行。<br /></li><li>最后调用 future 的 <strong>get()</strong> 方法，如果此时 download还没完成，会<strong>等待</strong> download 完成，并获取 返回值。</li></ul><h4 id="等待-wait">等待 wait</h4><ul><li>除了 get()，future 还有 <strong>wait()</strong>，可以等待执行结束但是不会返回其值。</li></ul><h4 id="等待一段时间wait_for">等待一段时间：wait_for()</h4><ul><li>线程未结束，wait() 会无限等待。<br /></li><li>而 wait_for() 则可以指定一个最长的等待时间，用 chrono里的类表示单位。他会返回一个 std::future_status 表示等待是否完成。<br /></li><li>如果超过时间还未完成，就会放弃等待，返回<code>future_status::timeout</code><br /></li><li>如果线程在指定时间内执行完毕，等待就成功了，返回<code>future_status::ready</code><br /></li><li>同理还有 <code>wait_until()</code> 其参数是一个时间点。</li></ul><h4id="另一种用法stdlaunchdeferred-做-stdasync-的参数">另一种用法：<code>std::launch::deferred</code>做 <code>std::async</code> 的参数</h4><ul><li><code>std::async</code> 的第一个参数可设为<code>std:;launch::deferred</code>，这时不会创建线程，只会把 lambda函数体内的运算<strong>推迟</strong>到 future 的 get() 被调用后。<br /></li><li>这种写法，lambda的执行仍在主线程中，只是函数式编程上的异步，而不涉及到多线程。(可以用这个实现惰性求值(lazyevaluation) )</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;<span class="hljs-type">int</span>&gt; fret = std::<span class="hljs-built_in">async</span>(std::launch::deferred, [&amp;]&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">909</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="stdasync-的底层实现stdpromise"><code>std::async</code>的底层实现：<code>std::promise</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; pret;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> ret = download();</span></span><br><span class="hljs-params"><span class="hljs-function">        pret.set_value(ret);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std:::funture&lt;<span class="hljs-type">int</span>&gt; fret = pret.<span class="hljs-built_in">get_future</span>();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果不想 <code>std::async</code>帮你自动创建线程，想要手动创建线程，可以直接用<code>std::promise</code><br /></li><li>然后线程返回时，用 <code>set_value()</code> 设置返回值。<br />在主线程中，用 <code>get_future()</code> 获取其<code>std::future</code>对象，进一步 <code>get()</code>可以等待并获取线程返回值。</li></ul><h3 id="stdfuture-小贴士">std::future 小贴士</h3><ul><li>为了符合 RAII 思想，删除了拷贝构造函数和拷贝赋值函数。<br />如果需要浅拷贝，实现共享同一个 future 对象，可以使用<code>std：：shared_future</code>。<br /></li><li>如果不需要返回值，<code>std::async</code> 里的 lambda 返回类型可以为void，但这时的 future 对象也要为<code>std::future&lt;void&gt;</code><br /></li><li>同理有 <code>std::promise&lt;void&gt;</code>，但其 set_value()不接受参数，仅仅作为同步作用，没有实际的值。</li></ul><h2 id="互斥量">互斥量</h2><h3 id="多线程打架实例">多线程打架实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            arr.push_back(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            arr.push_back(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>两个线程向同一个数组里推数据导致崩溃。<br /></li><li>vector 并非 多线程安全 (MT-safe) 的容器。<br />多个线程同时访问同一个 vector 对象会出现 <strong>数据竞争 (data-race)</strong>现象。</li></ul><h3 id="stdmutex-上锁防止多个线程进入某一段代码"><code>std::mutex</code>：上锁，防止多个线程进入某一段代码</h3><ul><li>调用 <code>std::mutex</code> 的 <code>lock()</code> 时，会检测<code>mutex</code> 是否已经<strong>上锁</strong>。<br /></li><li>如果没有<strong>锁定</strong>，则对 <code>mutex</code>进行上锁<br /></li><li>如果已经<strong>锁定</strong>，则陷入等待，直到 <code>mutex</code>被另一线程<strong>解锁</strong>后，才再次<strong>上锁</strong>。<br /></li><li>调用 <code>unlock()</code> 则会解锁操作<br /></li><li>这样可以保证 lock 和 unlock之间的代码段，同一时间只有一个线程在执行，避免数据竞争。</li></ul><h3 id="stdlock_guard-符合-raii-思想的锁"><code>std::lock_guard</code>:符合 RAII 思想的锁</h3><ul><li>根据 RAII思想，锁视为一种资源，上锁视为锁的获取，解锁视为锁的释放。<br /></li><li><code>std::lock_guard</code> 就是这样的一个工具类，其构造函数会<code>mtx.lock()</code>，解构函数会<code>mtx.unlock()</code>。从而退出函数作用域时能够自动解锁，避免程序员忘记解锁。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::lock_guard grd(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        arr.push_back(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::lock_guard grd(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        arr.push_back(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是也因为 <code>lock_guard</code>太符合 RAII思想，导致其很死板，我们想提前 unlock 只能让他超出其作用范围。<br />为了更灵活的应用锁，就有了 <code>unique_lock</code></p><h3id="stdunique_lock-符合-raii-思想但自由度更高"><code>std::unique_lock</code>:符合 RAII 思想，但自由度更高</h3><ul><li><code>std::lock_guard</code> 严格在解构时unlock()，但我们有时希望提前 unlock。这时就可以使用<code>std::unique_lock</code>，他额外存储了一个 flag表示释放已经被释放。他会在解构时检测这个 flag，如果没有释放，则调用unlock，否则不调用。<br /></li><li>然后可以直接调用 unique_lock 的 unlock函数来提前解锁，但即使忘记也没关系，在超出作用域时其会自动检测一边是否需要解锁。</li></ul><h4id="stdunique_lock-用-stddefer_lock-作为参数"><code>std::unique_lock</code>:用 <code>std::defer_lock</code> 作为参数</h4><ul><li><code>std::unique_lock</code> 的构造函数还可以有一个额外参数<code>std::defer_lock</code><br /></li><li>指定此参数后，<code>std::unique_lock</code>不会在构造函数中<code>mtx.lock()</code>了，需要后续手动 <code>grd.lock()</code>才能上锁。<br /></li><li>好处是，即使忘记了 <code>grd.unlock()</code> 也能够自动调用<code>mtx.unlock()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::unique_lock&lt;std::mutex&gt; grd(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">            arr.push_back(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::unique_lock&lt;std::mutex&gt;grd(mtx, std::defer_lock);</span></span><br><span class="hljs-params"><span class="hljs-function">            grd.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            arr.push_back(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// grd.unlock();</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多个对象每个对象使用一个-mutex-即可">多个对象？每个对象使用一个mutex 即可</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr1;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr2;<br>    <br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                std::lock_guard grd(mtx1);</span></span><br><span class="hljs-params"><span class="hljs-function">            arr1.push_back(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            </span></span><br><span class="hljs-params"><span class="hljs-function">            &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                std::lock_guard grd(mtx2);</span></span><br><span class="hljs-params"><span class="hljs-function">                arr2.push_back(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                std::lock_guard grd(mtx1);</span></span><br><span class="hljs-params"><span class="hljs-function">            arr1.push_back(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            </span></span><br><span class="hljs-params"><span class="hljs-function">            &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                std::lock_guard grd(mtx2);</span></span><br><span class="hljs-params"><span class="hljs-function">                arr2.push_back(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="如果上锁失败却不想等待try_lock">如果上锁失败，却不想等待：<code>try_lock()</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    <span class="hljs-keyword">if</span>(mtx1.<span class="hljs-built_in">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(mtx1.<span class="hljs-built_in">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>lock()</code> 如果发现 <code>mutex</code>已经上锁的话，会等待他直到他解锁。<br /></li><li>如果使用 <code>try_lock()</code> ，其上锁失败不会阻塞，而是直接返回false，上锁成功会返回 true。</li></ul><h3 id="try_lock_for"><code>try_lock_for</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    <span class="hljs-keyword">if</span>(mtx1.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(mtx1.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>try_lock()</code> 的基础上，但是会等待一段时间。<br /></li><li>类似的还有 <code>try_lock_until()</code></li></ul><h3id="stdunique_lock-用-stdtry_to_lock-做参数"><code>std::unique_lock</code>:用 <code>std::try_to_lock</code> 做参数</h3><ul><li><p>和无参数相比，它会调用 <code>mtx.try_lock()</code> 而非<code>mtx.lock()</code>.<br /><code>grd.owns_lock()</code> 判断是否上锁成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    std::mutex mtx;  <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;  </span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::try_to_lock);  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">if</span>(grd.owns_lock())  </span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;  </span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;Successed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">else</span>  </span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;  </span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;Failed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class="hljs-params"><span class="hljs-function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">1000</span>));  </span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;  </span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">jion</span>();  <br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li></ul><h3id="stdunique_lock-stdadopt_lock-做参数"><code>std::unique_lock</code>:<code>std::adopt_lock</code> 做参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;t1 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class="hljs-number">1000</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        mtx.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::adopt_lock);</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;t2 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class="hljs-number">1000</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>t1.<span class="hljs-built_in">jion</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用就是当我们的 mutex 已经上锁，但是我们又想使用 unique_lock /lock_guard 这种符合 RAII思想的封装，以实现其可以自我解构，我们就在构造时使用std::adopt_lock，就默认这个 mutex 已经上锁了。</li></ul><h3id="stdunique_lock-和-stdmutex-有相同的接口"><code>std::unique_lock</code>和 <code>std::mutex</code> 有相同的接口</h3><ul><li><p><code>std::unique_lock</code> 拥有 <code>std::mutex</code>的所有成员函数：<code>lock()</code>, <code>unlock()</code>,<code>try_lock()</code>, <code>try_lock_for()</code> 等等。<br />只是 unique_lock 会自动调用 unlock 罢了<br /></p></li><li><p>而 <code>std::lock_guard</code> 无非是调用其构造参数中 名为lock() 的成员函数罢了，所有我们甚至可以用 <code>std::unique_lock</code>做 <code>std::lock_guard</code> 的构造函数参数</p></li><li><p>更进一步，只要我们能有 满足 mutex 类对于成员函数的类，就可以做为<code>std::lock_guard</code> 构造函数的参数。<br />这种只要具有某些指定名字的成员函数，就可以判断一个类是否满足某些功能的思想，被成为concept(概念)，相比 虚函数 和 动态多态的接口抽象，concept能够使实现更加解耦，并且不会有性能损失。</p></li></ul><h2 id="死锁">死锁</h2><h3 id="同时锁住多个-mutex">同时锁住多个 mutex</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    std:<span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std:<span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">jion</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>因为线程是同步进行的，所以其指令不一定是同步的<br /></li><li>可能就会：<ul><li>t1锁住了mtx1<br /></li><li>t2锁住了mtx2<br /></li><li>t1需要锁mtx2，但是t2锁住了mtx2<br /></li><li>t2需要锁mtx1，但是t1锁住了mtx1<br /></li><li>t1，t2都陷入无尽的等待</li></ul></li></ul><h4 id="解决1永远不要同时持有两个锁">解决1：永远不要同时持有两个锁</h4><ul><li>简单粗暴的就是<u>不让一个线程同时持有两个锁</u>，分别上锁，来避免死锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">jion</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4id="解决方案2确保双方上锁顺序一致">解决方案2：确保双方上锁顺序一致</h4><ul><li>前面死锁是因为两个线程上锁的顺序不同，<u>保证双方上锁的顺序一致，即可避免死锁</u></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">jion</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决方案3使用-stdlock-同时对多个-mutex-上锁">解决方案3：使用<code>std::lock</code> 同时对多个 mutex 上锁</h4><ul><li><code>std::lock</code> 接受任意个 mutex 作为参数，且保证<u>无论任意线程中调用的顺序是否相同，都不会产生死锁问题</u></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">std::lock(mtx1, mtx2);</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::lock(mtx2, mtx1);</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx2.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            mtx1.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="stdlock-的-raii-版本-stdscoped_lock"><code>std::lock</code> 的RAII 版本 : <code>std::scoped_lock</code></h4><ul><li>和 <code>std::lock_guard</code> /<code>std::unique_lock</code>相对应，<code>std::lock</code> 也有 RAII的版本 <code>std::scoped_lock</code>, 只不过其可以同时对多个 mutex上锁。</li></ul><h3 id="同一个线程重复调用-lock-也会造成死锁">同一个线程重复调用 lock()也会造成死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>mtx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//...</span><br>    mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>mtx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-built_in">other</span>();<br>    mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里 <code>func</code> lock了mtx，而lock之后调用 other，other 需要mtx，陷入等待<br />这就是 同一线程多次对同一个 mutex 进行 lock 导致死锁。</li></ul><h4 id="解决一other-不-lock">解决一：other 不 lock</h4><p>这种情况一定要说明 other 非线程安全的，在调用前务必保证其 mutex已经上锁。</p><h4 id="解决二改用-stdrecursive_mutex">解决二：改用<code>std::recursive_mutex</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::recursive_mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>mtx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//...</span><br>    mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>mtx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-built_in">other</span>();<br>    mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如果 <code>other</code> 不让改，可以用<code>std::recursive_mutex</code><br />会判断是不是同一个线程 <code>lock()</code> 了多次同一个锁<br />如果是则让计数器加1，在之后 <code>unlock()</code>时会让计数器减1，减到0时才真正解锁。但是相比普通的<code>std::mutex</code> 会有一定的性能损失。</p></li><li><p>也有 <code>std::recursive_timed_mutex</code>，如果我们需要<code>try_lock_for()</code></p></li></ul><h2 id="数据结构">数据结构</h2><h3 id="案例多线程使用-stdvector">案例：多线程使用<code>std::vector</code></h3><p>之前提到 <code>vector</code>是线程不安全的，会出现数据竞争(data-race)</p><h3 id="封装线程安全的-vector">封装线程安全的 <code>vector</code></h3><p>加入我们这样做：<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    std::mutex m_mutex;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        m_arr.<span class="hljs-built_in">push_back</span>(val);<br>        m_mtr.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">//</span><br>        <span class="hljs-type">size_t</span> ret = m_arr.<span class="hljs-built_in">size</span>();<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><ul><li>我们用用一个类进行简单封装，使访问都受到 <code>mutex</code>的保护<br /></li><li>但是会出错哦，因为 <code>size()</code> 是 <code>const</code>函数，而 <code>mutex::lock()</code> 并非 <code>const</code> 函数。但是<code>size()</code>为了兼容之前的代码，必须是 const 的。</li></ul><h4 id="逻辑上-const-而部分成员非-const-mutable">逻辑上<code>const</code> 而部分成员非 <code>const</code>:<code>mutable</code></h4><ul><li>我们必须为了 <code>mutex</code> 放弃声明 <code>size()</code> 为<code>const</code> 吗？<br />不必这样，<code>size()</code> 在逻辑上仍然应该是 <code>const</code>的。<br />所以，为了能让 <code>this</code> 为 <code>const</code> 时仅仅对<code>m_mtx</code> 做特殊处理，可以声明 <code>mutable</code>关键字修饰他，从而所有成员只有他不是 <code>const</code> 的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    <span class="hljs-keyword">mutable</span> std::mutex m_mutex;<span class="hljs-comment">//</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        m_arr.<span class="hljs-built_in">push_back</span>(val);<br>        m_mtr.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-type">size_t</span> ret = m_arr.<span class="hljs-built_in">size</span>();<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="为什么需要读写锁">为什么需要读写锁</h3><p>实际上我们<strong>读的时候可以共享</strong>，但是写的时候不能共享，<strong>写必须独占</strong>，因为写一半被读取可能会读到错误的数据。</p><p>所以就有了读写锁，读写情况有三种：</p><ul><li>n 个人读，没有写入<br /></li><li>1 个人写入，没有读取<br /></li><li>没有读取，也没有写入</li></ul><h3 id="shared_mutex-读写锁"><code>shared_mutex</code> —— 读写锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    <span class="hljs-keyword">mutable</span> std::shared_mutex m_mutex;<span class="hljs-comment">//</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        m_arr.<span class="hljs-built_in">push_back</span>(val);<br>        m_mtr.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_mtx.<span class="hljs-built_in">lock_shared</span>();<br>        <span class="hljs-type">size_t</span> ret = m_arr.<span class="hljs-built_in">size</span>();<br>        m_mtx.<span class="hljs-built_in">unlock_shared</span>();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在上锁时，指定需求是 <strong>读</strong> 或者<strong>写</strong>，负责调度的读写锁会帮助我们 判断是否需要等待。<br /></li><li><code>push_back</code> 是写，所以使用 <code>lock</code> 和<code>unlock</code><br /></li><li><code>size</code> 是读，使用 <code>lock_shared</code> 和<code>unlock_shared</code></li></ul><h3id="stdshared_lock-符合-raii-思想的-lock_shared"><code>std::shared_lock</code>: 符合 RAII 思想的 <code>lock_shared()</code></h3><ul><li>我们用 <code>std::unique_lock</code> 封装 <code>lock()</code> 和<code>unlock()</code><br />对应的，<code>std::shared_lock</code> 封装了 <code>lock_shared()</code>和 <code>unlock_shared()</code><br /></li><li><code>shared_lock</code> 也支持 <code>defer_lock</code>做参数，<code>owns_lock()</code> 判断等等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    <span class="hljs-keyword">mutable</span> std::shared_mutex m_mutex;<span class="hljs-comment">//</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_lock&lt;std::shared_mutex&gt;<span class="hljs-built_in">grd</span>(m_mtx);<span class="hljs-comment">// 注意这里是 unique_lock</span><br>        m_arr.<span class="hljs-built_in">push_back</span>(val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::shared_lock <span class="hljs-title">grd</span><span class="hljs-params">(m_mtx)</span></span>;<span class="hljs-comment">// 注意这里是 shared_lock</span><br>        <span class="hljs-type">size_t</span> ret = m_arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="只需一次性上锁且符合-raii-思想访问者模式">只需一次性上锁，且符合RAII 思想：访问者模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    std::mutex m_mtx;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Accessor</span><br>    &#123;<br>    MTVector &amp;m_that;<br>        std::unique_lock&lt;std::mutex&gt; m_guard;<br>        <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Accessor</span>(MTVector &amp;that)<br>            : <span class="hljs-built_in">m_that</span>(that), <span class="hljs-built_in">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> m_that.m_arr.<span class="hljs-built_in">push_back</span>(val);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> m_that.m_arr.<span class="hljs-built_in">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-function">Accessor <span class="hljs-title">access</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;*<span class="hljs-keyword">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Accessor access() 将 <code>MTVector</code> 的 <code>this</code>指针作为 Access 构造函数的参数<br /></li><li>因为多次上锁解锁是存在性能消耗的</li></ul><p>如果使用 shared_mutex<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MTVector</span><br>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_arr;<br>    std::shared_mutex m_mtx;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Accessor</span><br>    &#123;<br>    MTVector &amp;m_that;<br>        std::unique_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Accessor</span>(MTVector &amp;that)<br>            : <span class="hljs-built_in">m_that</span>(that), <span class="hljs-built_in">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> m_that.m_arr.<span class="hljs-built_in">push_back</span>(val);<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstAccessor</span><br>    &#123;<br>    MTVector &amp;m_that;<br>        std::shared_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Accessor</span>(MTVector &amp;that)<br>            : <span class="hljs-built_in">m_that</span>(that), <span class="hljs-built_in">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> m_that.m_arr.<span class="hljs-built_in">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-function">Accessor <span class="hljs-title">access</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;*<span class="hljs-keyword">this</span>&#125;;<br>    &#125;<br>    <br>    <span class="hljs-function">ConstAccessor <span class="hljs-title">const_access</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;*<span class="hljs-keyword">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="条件变量">条件变量</h2><p>之前的互斥量更多的是防止数据竞争<br />而条件变量就类似他的名字，更多的是一个条件，只有条件发生了，这个线程才会继续执行。</p><h3 id="条件变量等待被唤醒">条件变量：等待被唤醒</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::condition_variable cv;<br>    std:;mutex mtx;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt;lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck);</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">millionseconds</span>(<span class="hljs-number">400</span>));<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Notifying ...&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>cv.wait(lck)</code> 将会让当前线程陷入等待。<br /></li><li>在其他线程中调用 <code>cv.notify_one()</code>则会唤醒那个陷入等待的线程。<br /></li><li><code>std::condition_variable</code> 必须和<code>std:unique_lock&lt;std::mutex&gt;</code> 一起使用</li></ul><h3 id="条件变量等待某一变量成真">条件变量：等待某一变量成真</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck, [&amp;] &#123; <span class="hljs-keyword">return</span> ready&#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">        lck.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Notifying not ready!&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    <br>        <br>    ready = <span class="hljs-literal">true</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Notifying ready&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>cv.wait(lck, expr)</code> 中 <code>expr</code> 是一个 lambda表达式。<br />只有返回值为 true 时才会被唤醒，否则继续等待。</li></ul><h3 id="条件变量多个等待者">条件变量：多个等待者</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck);</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T1 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck);</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T2 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck);</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T3 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">millionseconds</span>(<span class="hljs-number">400</span>));<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class="hljs-built_in">notify_one</span>();<span class="hljs-comment">// awake t1 only</span><br>    <br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">millionseconds</span>(<span class="hljs-number">400</span>));<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class="hljs-built_in">notify_all</span>();<span class="hljs-comment">// awake t2 and t3</span><br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    t3.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>cv.notify_one()</code> 只会唤醒其中一个等待的线程，而<code>cv.notify_all()</code> 会唤醒全部。<br /></li><li>这就是为什么 <code>wait()</code> 需要有个 <code>unique_lock</code>作为参数，因为要保证多个线程同时唤醒时只有一个可以被启动。如果不需要这个锁，在<code>wait()</code> 返回后调用 <code>lck.unlock()</code> 即可。<br /></li><li><code>wait()</code> 的过程中会暂时 <code>unlock()</code>这个锁。</li></ul><h3 id="实例实现生产者-消费者模式">实例：实现生产者-消费者模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; foods;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">return</span> foods.size() != <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> food = foods.back();</span></span><br><span class="hljs-params"><span class="hljs-function">        foods.pop_back();</span></span><br><span class="hljs-params"><span class="hljs-function">        lck.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T1 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">return</span> foods.size() != <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;);</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">auto</span> food = foods.back();</span></span><br><span class="hljs-params"><span class="hljs-function">        foods.pop_back();</span></span><br><span class="hljs-params"><span class="hljs-function">        lck.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        </span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;T2 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    foods.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    foods.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">422</span>);<br>    cv.<span class="hljs-built_in">notify_one</span>();<br>    <br>    foods.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">66</span>);<br>    foods.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">92</span>);<br>    cv.<span class="hljs-built_in">notify_all</span>();<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stdcondition_variable-tips"><code>std::condition_variable</code>tips</h3><ol type="1"><li><code>std::condition_variable</code> 仅支持<code>std::unique_lock&lt;std::mutex&gt;</code>作为参数，如果需要其他类型的 mutex，使用<code>std::condition_variable_any</code><br /></li><li>其还有 <code>wait_for()</code> 和 <code>wait_until()</code> 分别接受chrono 的时间段和时间点</li></ol><h2 id="原子操作">原子操作</h2><h3id="经典案例多个线程修改同一个计数器">经典案例：多个线程修改同一个计数器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            counter += <span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            counter += <span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里即便是简单的 +1 操作也会冲突，因为对于 CPU而言会是多个指令，执行时会发生冲突。</p><p>如果我们的操作不是原子的，就会造成数据冲入或者写入/读取错误。</p><h4 id="暴力解决mutex-上锁">暴力解决：mutex 上锁</h4><ul><li>能解决，但是这样操作系统来进行线程调度，会进入<strong>内核态</strong>再回到用户态，这样切换，有很大的开销。<br /></li><li>归根结底就是 mutex 太昂贵了</li></ul><h4 id="建议使用-atomic有专门的硬件指令加持">建议使用atomic：有专门的硬件指令加持</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::atomic&lt;<span class="hljs-type">int</span>&gt; counter = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            counter += <span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            counter += <span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>atomic 对 += 等操作会转换为专门的指令<br /></li><li>CPU识别到对应的指令会锁住内存总线，放弃乱序执行的优化，强制同步之前的内存操作，保证操作的原子性。<br /></li><li>注意，对 += 和 ++ 原子，但是分开写 c = c + 1 就不可以了</li></ul><h3 id="fetch_add和-等价">fetch_add：和 += 等价</h3><ul><li><code>fetch_add</code> : +=<br /></li><li><code>store</code> : =<br /></li><li><code>load</code> 读取 <code>int</code> 值</li></ul><h3 id="fetch_add-能够返回旧值">fetch_add 能够返回旧值</h3><ul><li>先 fetch 一个旧值，然后再 add<br /></li><li>这个特点使其可以<strong>并行地往一个列表追加数据</strong></li></ul><h3 id="exchange读取的同时写入">exchange：读取的同时写入</h3><p>先取出来，然后再写入</p><h3 id="compare_exchange_strong">compare_exchange_strong</h3><p>读取，比较是否相等，相等则写入</p><p><code>counter.compare_exchange_strong(cmp,val)</code> counter 和 cmp比，相等就写入val值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11之 lambda 和 function</title>
    <link href="/2023/05/01/C++11%E4%B9%8Bfunction%E5%92%8Clambda/"/>
    <url>/2023/05/01/C++11%E4%B9%8Bfunction%E5%92%8Clambda/</url>
    
    <content type="html"><![CDATA[<p>C++11 的lambda 表达式和 function是新引入的功能，他们的好处在于可以<strong>简化代码、使之更灵活</strong>而且在并发编程中一个lambda 表达式或 function对象作为线程的执行体会更安全，避免为一个线程单独写一个函数。<br /><span id="more"></span></p><h1 id="lambda-和-function">Lambda 和 Function</h1><h2 id="lambda-和-function-的好处">Lambda 和 Function 的好处</h2><ol type="1"><li>Lambda表达式能够简化代码，使代码更加简洁。Lambda表达式相当于一个匿名函数，可以在需要的地方直接定义使用，不必再为了实现某个功能而额外定义一个函数。<br /></li><li>Lambda表达式和Function都能够实现函数对象的传递，即将函数作为参数传递给其他函数。这种方式可以让代码更加灵活，更加符合面向对象编程的思想。<br /></li><li>Function是一个通用的函数封装器，可以将任何可调用的对象（比如函数指针、成员函数指针、Lambda表达式等）转换为一个统一的函数类型。Function可以让代码更加通用，更不易出错。<br /></li><li>Lambda表达式和Function都能够简化并发编程的代码。在并发编程中，有时需要定义一个Lambda表达式或Function对象作为一个线程的执行体，这样可以避免为线程另外写一个函数。</li></ol><p>总结：Lambda表达式和Function的好处包括代码简洁、函数传递灵活、通用性强、并发编程简单等。</p><h2 id="实例代码">实例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> cur) -&gt; <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> nei : g[cur])<br>    &#123;<br>        res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">dfs</span>(nei));<br>    &#125;<br>    <span class="hljs-keyword">return</span> information[cur]+res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="function">function</h2><p>function 是 std::function类型，可以用来存储任意可调用对象，包括函数指针、Lambda 表达式等等。</p><p>其使用方法为<br /><code>function&lt;int(char)&gt;</code> , int 为声明的返回值类型，而 char为声明的参数类型，如果有多个参数即多个声明，如<code>function&lt;void(int,char)&gt;</code>。</p><p>function 和函数指针有些类似，但是代码更灵活可以和 lambda表达式相结合使用，而没有指针带来的问题，但是因为使用了模板所以会有一定的实例化开销。<br />我们也可以用 auto 去指定 lambda 表达式的匿名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> funcPtr = &amp;functionName;<br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123; <span class="hljs-keyword">return</span> x+y;&#125;;<br><span class="hljs-built_in">int</span> (*function) (<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) = lambda;<span class="hljs-comment">// 将 Lambda 表达式赋值给函数指针</span><br></code></pre></td></tr></table></figure><p>int (*funcPtr)(int, int) 是一个函数指针，它可以指向一个返回类型为int，参数列表为 (int, int) 的函数。而 lambda表达式则相当于一个匿名函数，用于表示一个可调用对象，可以被赋值给一个函数指针。</p><h2 id="lambda">Lambda</h2><p>可以用在 sort 函数中自定义排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)<br>     &#123;<br>         <span class="hljs-keyword">if</span>(a &lt; b)<br>         &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     &#125;);<br></code></pre></td></tr></table></figure><p>其中“[&amp;]"表示的是捕获方式，Lambda 表达式有三种捕获方式：</p><ol type="1"><li>”[&amp;]“，用引用去捕获所有外部变量，表示该 Lambda表达式使用一个引用以捕获所有局部变量。这意味着Lambda函数内的局部变量实际上是对外部作用域中的同名变量的别名。在Lambda函数中，对于捕获的变量的修改将直接影响外部作用域中的原始变量。<br /></li><li>"[=]"：以复制方式捕获所有外部变量。Lambda表达式使用复制构造函数以复制传递给它们的所有数据，并在 Lambda函数体中使用该复制的变量副本。当然，对于复制的对象进行修改，不会影响到原始参数。<br /></li><li>"[cur]"：以复制方式仅捕获外部变量cur。这种方式只捕获指定的变量，每个指定的变量都使用复制构造函数以复制传递给它们的数据。</li></ol><h3 id="捕获变量例">捕获变量例</h3><p>这里的捕获变量不是说 lambda表达式定义的函数参数，而是对函数外部变量的使用，比如<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> func = [=]() <span class="hljs-keyword">mutable</span><br>&#123;<br>    a += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;a<br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<span class="hljs-comment">// 2</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></p><p>这里就是对 int a，lambda表达式用那种方式使用，而非()内的参数。<br />还有一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> func = [=](<span class="hljs-type">int</span>&amp; a) <span class="hljs-keyword">mutable</span><br>&#123;<br>    a += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>(b) &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>这里的(int&amp; a)对a有更高优先级，就是先匹配函数参数，外部定义的 inta，lambda函数是无法使用的。</p><ol type="1"><li><p>[&amp;], 所有参数全为引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;  <br><span class="hljs-keyword">auto</span> func=[&amp;]()  <br>&#123;  <br>    a+=<span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> a;  <br>&#125;  <br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>()&lt;&lt;std::endl;<span class="hljs-comment">// 2  </span><br></code></pre></td></tr></table></figure></li><li><p>[=], 所有变量都复制捕获</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">auto</span> func=[=]() <span class="hljs-keyword">mutable</span>  <br>&#123;  <br>    a+=<span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> a;  <br>&#125;;  <br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt;std::endl;<span class="hljs-comment">// 2  </span><br>std::cout &lt;&lt; a &lt;&lt;std::endl;<span class="hljs-comment">// 1  </span><br></code></pre></td></tr></table></figure></li><li><p>[cur], 指定某个参数的捕获方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num1 = <span class="hljs-number">1</span>, num2 = <span class="hljs-number">2</span>;  <br><span class="hljs-keyword">auto</span> func = [num1, &amp;num2]() <span class="hljs-keyword">mutable</span>&#123;  <br>num1 += <span class="hljs-number">1</span>;  <br>num2 += <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">return</span> num1 + num2;  <br>&#125;;  <br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 2+3=5  </span><br>std::cout &lt;&lt; num1 &lt;&lt; num2 &lt;&lt; std::endl; <span class="hljs-comment">// 1,3  </span><br></code></pre></td></tr></table></figure></li></ol><p>4.[], 如果在 Lambda 表达式中使用了<code>[]</code>，而没有写任何符号，表示不捕获任何外部变量。这种情况下，<strong>Lambda表达式只能访问自己内部定义的变量和函数，不能访问任何外部的变量和函数。</strong><br />对于之前的a，b参数覆盖问题就应该声明成[]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">auto</span> func = [](<span class="hljs-type">int</span>&amp; a)<br>&#123;<br>    a += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>(b) &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="mutable">mutable</h3><p><code>mutable</code> 是 C++ 中的一个关键字，用于修饰类的成员变量或者Lambda 表达式中捕获的变量，表示这些变量是可变的，即使在 const或者引用等限制的情况下也可以被修改。</p><p>在 Lambda 表达式中，如果想要修改按值捕获的外部变量，需要将其声明为<code>mutable</code>，否则会编译错误。例如：<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> func = [a]() <span class="hljs-keyword">mutable</span> &#123;<br>    a += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 11</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure></p><h3 id="指定返回值类型">指定返回值类型</h3><p>lambda 表达式可以指定返回值类型，只需要<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> cur) -&gt; <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>这里的<code>-&gt;</code>就指定了返回值 int 类型。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些环境配置教程</title>
    <link href="/2023/04/16/%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E6%95%99%E7%A8%8B/"/>
    <url>/2023/04/16/%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>自己配置环境时候经常遇到各种各样问题，所以记录一下比较好的配置环境的教程吧，日后也许有用。</p><span id="more"></span><h1 id="gmp">GMP</h1><h2 id="在-windows下为-c-配置-gmp">在 Windows下，为 C++ 配置 GMP</h2><p><ahref="https://blog.csdn.net/a675115471/article/details/104425406">配置GMP，在windows下，VisualStudio 2019</a><br /><ahref="https://github.com/microsoft/vcpkg/discussions/22418">如何在CMake中使用GMP:一个没解决的问题</a><br /><ahref="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004135300-How-to-use-GMP-with-Cmake-on-CLion-">Howto use GMP with Cmake on CLion?</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简单学习球谐函数</title>
    <link href="/2023/04/11/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0/"/>
    <url>/2023/04/11/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式学习</title>
    <link href="/2023/04/10/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/04/10/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>对常见设计模式的学习，从C++角度学习的，但是部分资料没找到好C++版本，所以可能会有不正确的地方。<br /><span id="more"></span></p><h1 id="常见设计模式"><ahref="https://zhuanlan.zhihu.com/p/231526884">常见设计模式</a></h1><h2 id="工厂模式">工厂模式</h2><h3 id="简单工厂">简单工厂</h3><h4 id="含义">含义</h4><ul><li><strong>简单工厂模式</strong>又叫<strong>静态方法模式</strong>，因为<strong>工厂类</strong>定义了一个<strong>静态方法</strong>。<br /></li><li>简单工厂的工厂类是负责生产一个对象的类。</li></ul><h4 id="解决的问题">解决的问题</h4><p>“类实例化的操作”和“使用对象的操作”分开，可以做到不知道具体参数就可以实例化出所需要的“产品类”。</p><h4 id="模式原理">模式原理</h4><h5 id="模式组成">模式组成</h5><ul><li>抽象产品：产品的父类；是一个描述产品的公共接口<br /></li><li>具体产品：抽象产品的子类、工厂创建的目标类；描述生产的具体产品。<br /></li><li>工厂：被外界调用；根据传入不同参数创建不同产品。</li></ul><h4 id="代码实例">代码实例</h4><p>一个小摊位可以产出“烤冷面”、“手抓饼”、“煎饼果子”等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 抽象的食物  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span> &#123;  <br><span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A Food&quot;</span>; &#125;  <br>&#125;;<br>  <br><span class="hljs-comment">// 具体食物类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KaoLengMian</span> :<span class="hljs-keyword">public</span> Food &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;烤冷面&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShouZhuaBing</span> :<span class="hljs-keyword">public</span> Food &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;手抓饼&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JianBingGuoZi</span> :<span class="hljs-keyword">public</span> Food &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;煎饼果子&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class="hljs-comment">// 创建工厂  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LiuJiu</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">static</span> Food* <span class="hljs-title">CookFood</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* foodName)</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(foodName,<span class="hljs-string">&quot;烤冷面&quot;</span>))  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">KaoLengMian</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(foodName,<span class="hljs-string">&quot;手抓饼&quot;</span>))  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ShouZhuaBing</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(foodName, <span class="hljs-string">&quot;煎饼果子&quot;</span>))  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">JianBingGuoZi</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">else</span>  <br>        &#123;  <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;没有这种商品&quot;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Food</span>();  <br>    &#125;  <br>&#125;;<br><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    LiuJiu myCar=<span class="hljs-built_in">LiuJiu</span>();  <br>    std::string f;  <br>    std::cin &gt;&gt; f;  <br>    Food* myfood;  <br>    myfood = myCar.<span class="hljs-built_in">CookFood</span>(f.<span class="hljs-built_in">c_str</span>());  <br>    myfood-&gt;<span class="hljs-built_in">Cook</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="优缺点">优缺点</h4><ul><li>优点<ul><li><u>把创建产品实例的操作</u> 和 <u>使用实例的工作分开</u>，类似于消费者不需要知道怎么做煎饼果子就能吃到，不关心产品如何制造，只关心如何使用，实现了解耦。<br /></li><li>把初始化产品的工作全集中在工厂内进行，方便维护，更符合面向对象的原则，而不是面向过程。<br /></li></ul></li><li>缺点<ul><li>所有实例创建都在工厂内，工厂不能工作后，整个系统都会被影响。<br /></li><li>违背开闭原则，添加新产品，不得不修改工厂类的逻辑，会造成工厂类的逻辑复杂。<br /></li><li>使用了静态方法，静态方法无法被继承、重写，工厂无法基于继承形成等级结构。</li></ul></li></ul><h4 id="适用场景">适用场景</h4><p>产品少；只知道传入参数，对构造逻辑不关心。</p><h3 id="工厂方法">工厂方法</h3><h4 id="简介">简介</h4><p>通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。解决普通工厂一旦生产新产品就要修改工厂类的方法逻辑，造成工厂逻辑混乱复杂的问题。</p><h4 id="模式组成-1">模式组成</h4><ul><li>抽象产品<br /></li><li>具体产品<br /></li><li>抽象工厂，具体工厂的父类，描述具体工厂的接口<br /></li><li>具体工厂，被外界调用，实现工厂方法创建产品实例。</li></ul><h4 id="直接上代码">直接上代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 抽象的食物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span> &#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A Food&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Food <span class="hljs-title">FactoryMeth</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Can`t find Factory&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体食物类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KaoLengMian</span> :<span class="hljs-keyword">public</span> Food &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;烤冷面&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShouZhuaBing</span> :<span class="hljs-keyword">public</span> Food &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;手抓饼&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JianBingGuoZi</span> :<span class="hljs-keyword">public</span> Food &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cook</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;煎饼果子&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KLMFactory</span> : <span class="hljs-keyword">public</span> Factory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Food* <span class="hljs-title">FactoryMeth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">KaoLengMian</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SZBFactory</span> : <span class="hljs-keyword">public</span> Factory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Food* <span class="hljs-title">FactoryMeth</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ShouZhuaBing</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JBGZFactory</span> : <span class="hljs-keyword">public</span> Factory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Food* <span class="hljs-title">FactoryMeth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">JianBingGuoZi</span>();<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    KLMFactory klmCar = <span class="hljs-built_in">KLMFactory</span>();<br>    SZBFactory szbCar = <span class="hljs-built_in">SZBFactory</span>();<br>    JBGZFactory jbgzCar = <span class="hljs-built_in">JBGZFactory</span>();<br>    KaoLengMian* klm = (KaoLengMian*)klmCar.<span class="hljs-built_in">FactoryMeth</span>();<br>    klm-&gt;<span class="hljs-built_in">Cook</span>();<br>    std::cout &lt;&lt; klm-&gt;a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优缺点-1">优缺点</h4><ul><li>优点<ul><li>更符合开闭原则<br />新增产品时只需要新增相应的工厂即可。<br />无需像简单工厂那样修改工厂逻辑。<br /></li><li>更符合单一职责原则<br />每个工厂只负责一种产品<br /></li><li>不用静态方法，可以进行继承，可以实现多态。<br /></li></ul></li><li>缺点<ul><li>新增产品，还要新增工厂，系统内类的个数成对增加，一定程度上增加了系统的复杂度，编译运行时会带来一定的开销。<br /></li><li>抽象类多不方便理解代码<br /></li><li>对于使用这种工厂方法的类而言，若要更换别的商品，需要修改工厂类的实例。<br /></li><li>一个工厂只能生产一种产品。</li></ul></li></ul><h4 id="适用场景-1">适用场景</h4><p>不需要知道产品类名，只需知道工厂；</p><h3 id="抽象工厂模式">抽象工厂模式</h3><h4 id="简介-1">简介</h4><p>抽象工厂模式，即Abstract FactoryPattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。<br />允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。<br />解决了每个工厂只能创建一类产品的问题。</p><h4 id="模式组成-2">模式组成</h4><ul><li>抽象产品族(AbstractProduct)，抽象产品的父类，描述抽象产品的公共接口<br /></li><li>抽象产品(Product)<br /></li><li>具体产品(Concrete Product)<br /></li><li>抽象工厂(Creator)<br /></li><li>具体工厂(Concrete Creator)</li></ul><p>抽象产品族：蜥蜴战士，魔法师；抽象产品：火属性蜥蜴战士、冰属性蜥蜴战士、电属性蜥蜴战士；火魔法师、冰魔法师、电魔法师；具体产品：中等难度的冰属性蜥蜴战士。<br />不同类型的怪物构成一个产品族，同一种但属性不同的怪物构成一个抽象产品，一个生产出来的怪物是具体产品。</p><h4 id="代码">代码</h4><p>火冰，工厂都能制造1，2两种怪物，怪物有火1，火2，冰1，冰2.<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 抽象产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZaiE</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;GaLong&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonsterFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZaiE; &#125;;<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZaiE; &#125;;<br>&#125;;<br><br><span class="hljs-comment">// 抽象产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonsterOne</span>:<span class="hljs-keyword">public</span> ZaiE&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;M1&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonsterTwo</span>:<span class="hljs-keyword">public</span> ZaiE &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;M2&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FireMonsterOne</span>:<span class="hljs-keyword">public</span> MonsterOne &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Fire M1&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IceMonsterOne</span> :<span class="hljs-keyword">public</span> MonsterOne&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Ice M1&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FireMonsterTwo</span> :<span class="hljs-keyword">public</span> MonsterTwo &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Fire M2&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IceMonsterTwo</span> :<span class="hljs-keyword">public</span> MonsterTwo &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Ice M2&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FireFactory</span> :<span class="hljs-keyword">public</span> MonsterFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">FireMonsterOne</span>();<br>    &#125;<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">FireMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IceFactory</span> :<span class="hljs-keyword">public</span> MonsterFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IceMonsterOne</span>();<br>    &#125;<br>    <span class="hljs-function">ZaiE* <span class="hljs-title">Monster2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IceMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    FireFactory ff = <span class="hljs-built_in">FireFactory</span>();<br>    IceFactory icef = <span class="hljs-built_in">IceFactory</span>();<br>    FireMonsterOne* fm1 = (FireMonsterOne*)ff.<span class="hljs-built_in">Monster1</span>();<br>    IceMonsterTwo* icem2 = (IceMonsterTwo*)icef.<span class="hljs-built_in">Monster2</span>();<br>    fm1-&gt;<span class="hljs-built_in">attack</span>();<br>    icem2-&gt;<span class="hljs-built_in">attack</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="优缺点-2">优缺点</h4><ul><li>优点<ul><li>具体产品生产，交给具体工厂，降低耦合。<br /></li><li>新增产品，增加产品类，修改工厂类即可<br /></li></ul></li><li>缺点<ul><li>容易增添抽象产品种类(比如增加暗属性怪物)，但是增加新的产品族比较难(比如加入新的怪)，因为抽象工厂定义内定义了能生产的所有对象，新增产品族需要修改所有的工厂，而增加新的抽象产品，只需建新的工厂。</li></ul></li></ul><h2 id="单例模式"><ahref="https://blog.csdn.net/unonoi/article/details/121138176">单例模式</a></h2><p>单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。<br />特点就是全局唯一，就像世界上只有一个一个一个！啊啊啊！</p><h3 id="为什么需要单例模式">为什么需要单例模式</h3><p>单例模式是为了保证程序的线程安全。<br />#### 什么是线程安全？</p><p>线程安全是指在拥有共享数据的多条线程并行执行的过程中，线程安全的代码会通过同步机制保证各个线程可以正常且正确的执行，不会出现数据污染的情况。<br />#### 如何保证线程安全</p><p>1、使用锁，给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。<br />2、让线程也拥有资源，不去共享进程中的资源。<br />如：使用 threadlocal 可以为每个线程维护一个私有的本地变量。</p><h3 id="单例模式分类">单例模式分类</h3><p>分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，二者<strong>区别在于创建实例的时间不同。</strong></p><ul><li>懒汉式(比较懒，用到时候才创建)<br />系统运行中，实例不存在，只有用到才会去创建并使用实例。我们需要考虑线程安全的问题，所以后面有普通懒汉式(<em>线程不安全</em>)和加锁的懒汉式(<em>线程安全</em>)。<br /></li><li>饿汉式(饿的不行了，一开始就创建)<br />系统一运行就初始化创建实例，直接调用即可。这种方式本身就是线程安全的，可以安心使用。</li></ul><h3 id="单例类的特点">单例类的特点</h3><ul><li>构造函数和析构函数均为私有成员，防止外部构造和析构。<br /></li><li>拷贝构造函数和赋值构造函数是私有类型，禁止外部拷贝和赋值。<br /></li><li>类内有一个获取实例的静态方法，供全局访问。</li></ul><h3 id="单例模式实现">单例模式实现</h3><h4 id="普通懒汉模式">普通懒汉模式</h4><p>大佬没写，我也不写(</p><h4 id="加锁的懒汉模式">加锁的懒汉模式</h4><h5 id="方法1.返回普通指针">方法1.返回普通指针</h5><p>头文件<br />这里需要学习<ahref="https://cn.bing.com/search?q=std%3A%3Amutex&amp;PC=U316&amp;FORM=CHROMN"><code>std::mutex</code>互斥量，先贴一个bing搜的，以后补充学习</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleInstance* <span class="hljs-title">GetInstacne</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 获取单实例对象</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">()</span></span>;           <span class="hljs-comment">// 释放单实例，在进程退出时调用。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintInstance</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 打印单实例的实际地址</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有的构造、析构寒素</span><br>    <span class="hljs-built_in">SingleInstance</span>();<br>    ~<span class="hljs-built_in">SingleInstance</span>();<br><br>    <span class="hljs-comment">// 私有的拷贝、赋值构造函数</span><br>    <span class="hljs-built_in">SingleInstance</span>(<span class="hljs-type">const</span> SingleInstance&amp; single);<br>    <span class="hljs-type">const</span> SingleInstance&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SingleInstance&amp; single);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 唯一单实例对象的指针</span><br>    <span class="hljs-type">static</span> SingleInstance* m_SingleInstance;<br>    <span class="hljs-type">static</span> std::mutex m_Mutex;              <span class="hljs-comment">// 锁</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>源文件<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化静态成员变量</span><br>SingleInstance* SingleInstance::m_SingleInstance = <span class="hljs-literal">nullptr</span>;<br>std::mutex SingleInstance::m_Mutex;<br><br><span class="hljs-comment">// 不能返回指针的引用！会存在在外部被修改的风险</span><br><span class="hljs-function">SingleInstance* <span class="hljs-title">SingleInstance::GetInstacne</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 使用两个 if 进行双检锁；好处是，只有判断指针为空时才加锁</span><br>    <span class="hljs-comment">// 避免每次调用 GetInstance 的方法都进行加锁，锁存在一定的开销</span><br>    <span class="hljs-keyword">if</span> (m_SingleInstance == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_Mutex)</span></span>;  <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">if</span> (m_SingleInstance == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m_SingleInstance = <span class="hljs-built_in">new</span>(std::nothrow)<span class="hljs-built_in">SingleInstance</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> m_SingleInstance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleInstance::deleteInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_Mutex)</span></span>; <span class="hljs-comment">// 加锁</span><br>    <span class="hljs-keyword">if</span> (m_SingleInstance)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_SingleInstance;<br>        m_SingleInstance = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleInstance::PrintInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;该实例的内存地址为：&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::<span class="hljs-built_in">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;单例模式构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::~<span class="hljs-built_in">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;单例模式析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="方法2.返回智能指针">方法2.返回智能指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125; <span class="hljs-comment">// print function name</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">static</span> std::mutex singletonMutex;<br><br><span class="hljs-function">std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">Singleton::getSingleton</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(singletonMutex)</span></span>;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> temp = std::<span class="hljs-built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>());<br>            singleton = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h5id="静态局部变量的懒汉单例c11线程安全">静态局部变量的懒汉单例(C++11线程安全)</h5><p>头文件<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 获取单实例对象</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Single <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 防止外部构造</span><br>    <span class="hljs-built_in">Single</span>();<br><br>    <span class="hljs-comment">// 禁止外部析构</span><br>    ~<span class="hljs-built_in">Single</span>();<br><br>    <span class="hljs-comment">// j禁止外部拷贝</span><br>    <span class="hljs-built_in">Single</span>(<span class="hljs-type">const</span> Single&amp; single);<br><br>    <span class="hljs-comment">// 禁止外部赋值</span><br>    <span class="hljs-type">const</span> Single&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Single&amp; single);<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>源文件<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Single <span class="hljs-title">Single::GetInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*L</span><br><span class="hljs-comment">    利用局部静态变量的特性实现</span><br><span class="hljs-comment">    静态局部变量只能在当前函数内有效，其他函数无法访问</span><br><span class="hljs-comment">    静态局部变量只有在第一次被调用的时候进行初始化，存在静态存储区，直到程序结束</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">static</span> Single single;<br>    <span class="hljs-keyword">return</span> single;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Single::Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;My Single Instance Address is:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::<span class="hljs-built_in">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::~<span class="hljs-built_in">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>但是这种方法其实还是有问题的，在多线程情况下，同时调用<code>GetInstance</code>方法会产生竞争，发生线程安全问题。<br />解决办法：在程序的单线程启动阶段就调用 <code>GetInstance</code> 方法</p><h4 id="饿汉式单例">饿汉式单例</h4><p>头文件<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 饿汉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Get Instance</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 释放单例，当进程退出时调用</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteInstance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//打印实例地址</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;This Instance Address is:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>();<br>    ~<span class="hljs-built_in">Singleton</span>();<br><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; single);<br>    <span class="hljs-type">const</span> Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp; single);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 唯一单实例对象指针</span><br>    <span class="hljs-type">static</span> Singleton* g_pSingleton;<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>源文件<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 代码一运行就初始化创建实例，本身即线程安全</span><br>Singleton* Singleton::g_pSingleton = <span class="hljs-built_in">new</span> (std::nothrow)<span class="hljs-built_in">Singleton</span>();<br><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> g_pSingleton;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Singleton::deleteInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (g_pSingleton)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> g_pSingleton;<br>        g_pSingleton = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><br>Singleton::<span class="hljs-built_in">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;gzhs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Singleton::~<span class="hljs-built_in">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;xghs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="使用-c11-stdcall_once-实现单例c11线程安全">使用 C++11<code>std::call_once</code> 实现单例(C++11线程安全)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostrea&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;SingleInstance Address is:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">static</span> std::once_flag singletonFlag;<br><br><span class="hljs-function">std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">Singleton::getSingleton</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">call_once</span>(singletonFlag, [&amp;] &#123;<br>        singleton = std::<span class="hljs-built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>());<br>        &#125;);<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="装饰模式">装饰模式</h2><h3 id="简述">简述</h3><p>装饰模式：装饰模式是<em>动态地将“责任”添加</em>到具体对象上而<strong>不影响这个对象所对应的类或者基类的方法</strong>。当需要拓展功能时，提供了一种比传统继承方式更为灵活的选择。<br />就如同名字一样，加上华丽的装饰，但是不改变本质。</p><h4 id="应用场景">应用场景</h4><ol type="1"><li>需要<strong>动态地为对象添加功能</strong>，且这些功能可以<strong>动态的撤销</strong>。<br /></li><li>当使用继承不利于系统维护/拓展，或者不允许直接使用继承的方式对系统进行拓展时。<br /></li><li>对一个原始类同时生成了多个对象，在不影响其它对象的前提下，以动态、透明的方式为单个对象添加新的职能，而不修改原始类；因为如果对原始类进行频繁的修改，会使其变得非常复杂和庞大。</li></ol><h3 id="经典例子">经典例子</h3><p>设食堂出售三种主食：米饭、馒头、面条；并售三种肉食：鸡蛋、火腿、牛肉；在必选主食前提下，可在三样肉食中随意搭配，最后计算价格。</p><p>这就是一个经典的装饰模式，肉食用以修饰注释，而肉食的选择顺序和组合不影响主食，比如先算鸡蛋后算牛肉，和先算牛肉后算鸡蛋，顺序并不影响。</p><h3 id="uml类图并不">UML类图？并不！</h3><ul><li>Food<ul><li>FoodRice<br /></li><li>FoodNoodle<br /></li><li>FoodManTou<br /></li><li>Decorator<ul><li>Egg<br /></li><li>Beef<br /></li><li>Ham</li></ul></li></ul></li></ul><h3 id="代码-1">代码</h3><p>1.定义<strong>抽象基类</strong>，Food，声明公共接口ImyInterface()，在子类中经由该接口为具体对象添加职责。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Food</span>()&#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Food</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 纯虚函数，为后续修饰操作提供统一接口</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> </span>&#123; mPrice = price; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> mPrice; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mPrice;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.从基类Food，派生出3个在售的主食类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// rice</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodRice</span>:<span class="hljs-keyword">public</span> Food<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FoodRice</span>()<br>    &#123;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-number">2.5</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FoodRice</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Rice&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Noodle</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodNoodle</span> :<span class="hljs-keyword">public</span> Food<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FoodNoodle</span>() &#123;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-number">6.0</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FoodNoodle</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterfece</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Noodle&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// mantou</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodMantou</span> :<span class="hljs-keyword">public</span> Food &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FoodMantou</span>() &#123;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FoodMantou</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Mantou&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3.定义抽象装饰类 <code>Decorator</code>，继承自 Food类，并在内部维护一个 Food类型的指针，将各种装饰对象和被装饰对象组织关联起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> :<span class="hljs-keyword">public</span> Food<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Decorator</span>(Food* food)<br>    &#123;<br>        mFood = food;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Decorator</span>()&#123;&#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mFood-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>    &#125;<br><br>    <span class="hljs-function">Food* <span class="hljs-title">getFood</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;mFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFood</span><span class="hljs-params">(Food* food)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mFood = food;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Food* mFood = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>4.定义具体的装饰类(Eggs, Beef, Ham)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EggDecorator</span> :<span class="hljs-keyword">public</span> Decorator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EggDecorator</span>(Food* food) :<span class="hljs-built_in">Decorator</span>(food)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFood</span>(food);<br>        decoratorPrice = <span class="hljs-number">0.5</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">EggDecorator</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>        <span class="hljs-built_in">doDecorator</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDecorator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Add Eggs&quot;</span>;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeefDecorator</span> :<span class="hljs-keyword">public</span> Decorator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BeefDecorator</span>(Food* food) :<span class="hljs-built_in">Decorator</span>(food)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFood</span>(food);<br>        decoratorPrice = <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">BeefDecorator</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>        <span class="hljs-built_in">doDecorator</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDecorator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Add Beef&quot;</span>;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HamDecorator</span> :<span class="hljs-keyword">public</span> Decorator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HamDecorator</span>(Food* food) :<span class="hljs-built_in">Decorator</span>(food)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFood</span>(food);<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HamDecorator</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ImyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>        <span class="hljs-built_in">doDecorator</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDecorator</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Add Ham&quot;</span>;<br>        <span class="hljs-built_in">setPrice</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getFood</span>()-&gt;<span class="hljs-built_in">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>客户端调用<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Noodle + Egg</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Food Plane One:&quot;</span>;<br>    Food* plane1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FoodNoodle</span>(); <br>    Food* planeD = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EggDecorator</span>(plane1);<br>    planeD-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;It is &quot;</span> &lt;&lt; planeD-&gt;<span class="hljs-built_in">getPrice</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// Rice + Egg + Beef + Ham</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Food Plane Two is&quot;</span>;<br>    Food* rice = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FoodRice</span>();<br>    Food* riceP = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EggDecorator</span>(rice);<br>    Food* ricePB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BeefDecorator</span>(riceP);<br>    Food* ricePH = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HamDecorator</span>(ricePB);<br><br>    <span class="hljs-comment">// 这里我们调用 ricePH</span><br>    <span class="hljs-comment">// ricePH-&gt;Imyinterface:(this-&gt;food)RicePB-&gt;ImyInterface RicePH的Interface调用RicePB的Interface</span><br>    <span class="hljs-comment">// ricePB-&gt;ImyInterface:(this-&gt;food)RiceP-&gt;ImyInterface RicePB的Interface调用RiceP的Interface</span><br>    <span class="hljs-comment">// riceP-&gt;ImyInterface:(this-&gt;food)rice-&gt;ImyInterfacc 调用Rice了，然后Egg price + rice price，一级一级返回相加price</span><br>    ricePH-&gt;<span class="hljs-built_in">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;It is &quot;</span> &lt;&lt; ricePH-&gt;<span class="hljs-built_in">getPrice</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></p><p>通过抽象基类指针Food一个一个Decorator加到主食上，最后调用<code>ImyInterface</code> 做包装操作。</p><h4 id="装饰模式优点">装饰模式优点</h4><ol type="1"><li>可以对已存在对象进行修饰包装，在被修饰对象前面或后面添加新的行为，而无需修改原始类，符合开闭原则。<strong>原始类不变，但是原始类的对象有新的行为。</strong><br /></li><li>在不确定后续功能的时候，可以先定义一个简单的类，使用设计模式来封装，后续利用装饰类来逐步添加新的功能，最终组合出复杂功能。<br /></li><li>装饰类的添加和删除非常方便，在客户端代码中就能轻松实现，因此非常适合用来实现可拔插操作频繁的插件。<br />上述的例子只展示添加其实删除很简单，只需要用前面的对象指针即可，比如riceBH想去掉H，直接用riceBF就行了。</li></ol><h2 id="策略模式">策略模式</h2><blockquote><p>策略模式就像三国演义中的模式，为了帮助主公取得胜利，有多种计策，虽然这些计策各不相同，但可以相互替换，目的都是为了取胜</p></blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。</p><h3 id="适用场景-2">适用场景</h3><p>一个系统需要动态的在几种算法之间切换，使用者不必关心实现的细节，全部封装到策略类内即可。</p><h3 id="策略模式的优缺点">策略模式的优缺点</h3><ul><li>优点<ol type="1"><li>算法(策略)之间可以自由切换<br /></li><li>避免使用多重判断<br /></li><li>拓展性好<br /></li><li>对开闭原则完美支持，用户无需修改原有系统即可选择算法，没有难看的 ifelse<br /></li></ol></li><li>缺点<ol type="1"><li>策略类会增多<br /></li><li>所有策略类都需要对外暴露<br /></li><li>调用时必须知道有哪些策略类型，才能自行决定当前场景改用何种策略。</li></ol></li></ul><h3 id="uml类图">UML类图</h3><p><img src="StrategyUML.png"></p><p>Context 依赖 Strategy，内有 Strategy 指针，维护对 Strategy的对象引用</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">secretStrategy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FireStrategy</span> : <span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">secretStrategy</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;夷陵之火&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaterStrategy</span> :<span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">secretStrategy</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;水淹七军&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoisonStrategy</span> :<span class="hljs-keyword">public</span> Strategy<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">secretStrategy</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;文和乱舞&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    Strategy* pStrategy;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Context</span>(Strategy* _pStrategy) :<span class="hljs-built_in">pStrategy</span>(_pStrategy)<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IContextInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        pStrategy-&gt;<span class="hljs-built_in">secretStrategy</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Strategy* fireStra = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FireStrategy</span>();<br>    Strategy* waterStra = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WaterStrategy</span>();<br>    Strategy* poisonStra = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PoisonStrategy</span>();<br><br>    <span class="hljs-comment">// 先火攻，在水淹，后文和乱武</span><br>    Context* master = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(fireStra);<br>    master-&gt;<span class="hljs-built_in">IContextInterface</span>();<br>    master = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(waterStra);<br>    master-&gt;<span class="hljs-built_in">IContextInterface</span>();<br>    master = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(poisonStra);<br>    master-&gt;<span class="hljs-built_in">IContextInterface</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理模式">代理模式</h2><blockquote><p>三国时期天子暗弱，曹公掌权，面见天子不容易，但是可以访问曹公达到访问天子的目的，曹公就是天子的代理，对天子实施了保护(禁锢)。</p></blockquote><p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。</p><h3 id="类型">类型</h3><ol type="1"><li>远程代理（RemoteProxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它<em>使得客户端程序可以访问在远程主机上的对象</em>，远程主机可能具有更好的计算性能与处理速度，可以<em>快速响应并处理客户端的请求</em>。<br /></li><li>虚拟代理（VirtualProxy）：对于一些<strong>占用系统资源较多或者加载时间较长的对象</strong>，可以<em>先创建一个消耗相对较小的对象来表示</em>，真实对象只在<em>需要时才会被真正创建</em>，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。<br /></li><li>保护代理（ProtectProxy）：给不同的用户提供不同的对象访问权限。(曹操挟天子以令诸侯和这个有点类似)<br /></li><li>缓冲代理（CacheProxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。<br /></li><li>智能引用代理（Smart ReferenceProxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。</li></ol><h3 id="应用场景-1">应用场景</h3><ol type="1"><li>客户端需要访问远程主机，可以使用远程代理。<br /></li><li>需要用一个消耗资源较少的对象表示资源消耗大的对象，以降低性能开销。<br /></li><li>要控制不同对象的访问权限级别<br /></li><li>为频繁访问的某个操作结果提供临时存储空间，供多客户端共享访问，无需每个客户端重新计算<br /></li><li>需要为一个对象的访问(引用)提供一些额外操作</li></ol><h3 id="代理模式优缺点">代理模式优缺点</h3><h4 id="有点">有点</h4><ul><li>代理模式可以在客户端和用户直接起到中介、保护作用<br /></li><li>代理对象可以扩展目标对象的功能<br /></li><li>代理模式能将客户端和目标对象分离，降低了耦合度，增加了可拓展性。</li></ul><h4 id="缺点">缺点</h4><ul><li>会造成系统设计的类增加<br /></li><li>在客户端和目标对象增加代理对象，会造成处理速度变慢<br /></li><li>增加了系统复杂度</li></ul><h3 id="uml类图-1">UML类图</h3><p><img src="Proxy.jpg"></p><ul><li>Proxy<ol type="1"><li>保存一个引用使得代理，</li></ol></li></ul><h2 id="观察者模式">观察者模式</h2><p><ahref="https://cloud.tencent.com/developer/article/1963312?areaSource=&amp;traceId=">Carson带你学设计模式</a><br /><a href="https://zhuanlan.zhihu.com/p/231526884">常见设计模式</a><br /><ahref="https://www.cnblogs.com/ring1992/p/9592428.html">C++设计模式解读合集</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的CMake学习</title>
    <link href="/2023/03/10/CMake%20Note/"/>
    <url>/2023/03/10/CMake%20Note/</url>
    
    <content type="html"><![CDATA[<p>对 CMake粗浅的学习，之前看一个up的讲的一般，后来看了小彭老师，的确不错，因为官方文档看起来有点吃力，所以就……<br />学习过程中把知识点做了一点笔记方便后续复习</p><span id="more"></span><h1 id="cmake">CMake</h1><p>本文档为学习笔记，该部分内容来源<ahref="https://www.bilibili.com/video/BV1vR4y1u77h/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">b站Up刘贝斯的CMake教学</a>。</p><h2 id="what-is-cmake">What is CMake?</h2><p>CMake 是一种高级编译配置工具。</p><p>当多人使用一种或不同种语言、编译器开发一个项目时，最终需要输出一个<strong>可执行文件</strong>或者<strong>共享库</strong>(dll,so等等)，此时——CMake就可以帮助到我们，不必用G++或GCC逐个编译我们所写过的代码。<br />所有操作都是通过编译CMakeLists.txt完成的。<br />使用CMake来处理大型的C/C++/Java等项目。</p><h2 id="cmake-安装">CMake 安装</h2><ul><li>Linux大多都有安装。<br /></li><li>Windows, 下载网站(https://cmake.org/download/)</li></ul><h2 id="cmake-hello-world">CMake: Hello World</h2><p>1.首先写一个C/C++的hello world</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.编写<code>CmakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span> (HELLOW)<br><br><span class="hljs-keyword">SET</span>(SRC_LIST main.cpp)<br><br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is BINARY dir &quot;</span> <span class="hljs-variable">$&#123;HELLO_BINAR_DIR&#125;</span>)<br><br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is SOURCE dir &quot;</span> <span class="hljs-variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-keyword">ADD_EXECUTABLE</span>&#123;hello $(SRC_LIST)&#125;<br></code></pre></td></tr></table></figure><p>3.使用CMake，生成<code>makefile</code>文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake .  <br></code></pre></td></tr></table></figure><h3 id="cmake-hello-world语法介绍">CMake: Hello World语法介绍</h3><h4 id="project关键字-简书cmake命令之project"><code>PROJECT</code>关键字—— <ahref="https://www.jianshu.com/p/cdd6e56c2422">简书CMake命令之project</a></h4><p>可以用来<strong>指定工程的名字和支持的语言</strong>，默认支持所有语言。<br />PROJECT (HELLO) 指定了工程的名字——HELLO，并且支持所有语言。</p><h1 id="cmake教程"><ahref="https://www.bilibili.com/video/BV16P4y1g7MH"><strong>CMake教程</strong></a></h1><h2 id="第一章-添加源文件">第一章 添加源文件</h2><ul><li>第一种，添加名为 <em>main</em> 的 <em>executable</em> ，源文件为<em>main.cpp</em> 。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure><ul><li>第二种，先创建 <strong>目标( executable)</strong>，稍后再添加源文件。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC main.cpp)<br></code></pre></td></tr></table></figure><h3 id="若有多个源文件呢">若有多个源文件呢？</h3><p>逐个添加即可</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC main.cpp other.cpp)<br></code></pre></td></tr></table></figure><p>或者使用<strong>变量</strong>来存储</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">set</span>(sources main.cpp other.cpp)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><p>建议把头文件也加上，这样在VS中可以出现在 "Header Flies" 一栏</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">set</span>(sources main.cpp other.cpp other.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><p>我们还可以使用 <strong>GLOB</strong>自动查找当前目录下指定拓展名的文件，实现批量添加源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources *.cpp *.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><p>但是使用 <strong>GLOB</strong>需要注意，如果我们增添新的源文件时，CMake可能不会更新，所以要启用<strong>CONFIGURE_DEPENDS</strong> 选项，当添加新文件时，<strong>在Build 时进行检测</strong>，自动更新变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="源码在子文件夹中">源码在子文件夹中？</h3><h4 id="例子">例子：</h4><ul><li>mylib<ul><li>other.cpp<br /></li><li>other.h<br /></li></ul></li><li>CMakeLists.txt<br /></li><li>main.cpp</li></ul><p>将<strong>路径名、后缀名全部</strong>写出来</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><p>然鹅，dark不必，我们可以使用 <strong>aux_source_directory</strong> ,自动搜集需要的文件后缀名<br />本例中<code>aux_source_directory(. sources)</code>和<code>aux_source_directory(mylib sources)</code>表示<strong>当前目录</strong>和 <strong>mylib 目录</strong>全部加入项目中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">aux_source_directory</span>(. sources)<br><span class="hljs-keyword">aux_source_directory</span>(mylib sources)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><p>更进一步：<strong>GLOB_RECURES</strong>能够自动包含所有子文件夹下的文件<br />但是注意，<strong>GLOB_RECURES</strong> 会把 <strong>build目录</strong>下的临时 .cpp 文件( 这些临时文件是 CMake 为了测试编译器)也加进来。<br />解决办法：一种，可以把源码统一放到 src 目录下。二种，要求使用者不要把build 放到和源码同一个目录里。这两种之间前者好一点。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB_RECURES sources CONFIGURE_DEPENDS *.cpp *.h)<br>target_source(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="第二章-项目配置变量build_type">第二章项目配置变量——BUILD_TYPE</h2><h3id="cmake_build_type-构建的类型调试模式-or-发布模式">CMAKE_BUILD_TYPE构建的类型，调试模式 or 发布模式</h3><ul><li>CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，用于控制构建类型，他的值可以是：<ul><li>Debug 调试模式，完全不进行优化，生成调试信息，方便调试程序<br /></li><li>Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢<br /></li><li>MinsizeRel 最小体积发布，生成的文件比 Release更小，不完全优化，减少二进制体积。<br /></li><li>RelWithDebInfo 带调试信息发布，生成的文件比 Release更大，因为带有调试的符号信息。<br /></li></ul></li><li>默认情况下，CMAKE_BUILD_TYPE 为空字符，这时相当于 Debug。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake_minimun_required(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellowcmake LANGUAGES CXX)<br><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure><p>各种构建模式在编译器选项上的区别</p><ul><li>在 Release模式下，追求的是程序最佳的性能表现，在此情况下编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后不与源代码一致，此模式下一般会丢失大量的调试信息。</li></ul><p>在编译器上各种构建类型的体现：</p><ul><li>Debug : '-O0 -g'<br /></li><li>Release : '-O3 -DNDEBUG'<br /></li><li>MinSizeRel : '-Os -DNDEBUG'<br /></li><li>RelWithDebInfo : '-O2 -g -DNDEBUG'</li></ul><p>此外，定义 NDEBUG 宏会使 assert 被去除掉。</p><p>因为默认情况下是 Debug 导致生成程序的效率很低。<br />小技巧：设定一个变量的默认值</p><p>如何让 CMAKE_BUILD_TYPE 在用户没有指定的情况时为Release，指定的时候保持用户的指定的值不变？<br />即 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。<br />因此可以通过<code>if( NOT CMAKE_BUILD_TYPE )</code>判断是否为空，空则自动设置为Release 模式。<br />大多数 CMakeLists.txt开头都会有这样三行，目的是让默认的构建类型为发布模式 (高度优化)而不是默认的调试模式 (不会优化) 。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>( <span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE )<br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="project">Project</h3><p>project : 初始化项目信息，并把当前 CMakeLists.txt所在位置作为根目录</p><p>这里初始化名为 hellocmake 的项目；为什么一定需要项目名？<br />因为对于 MSVC，他会在 build 里生成 hellocmake.sln 作为 IDE眼中的项目。<br />CMAKE_CURRENT_SOURCE_DIR 表示<strong>当前源码目录</strong>的位置，例如~/hellocmake<br />CMAKE_CURRENT_BINARY_DIR 表示<strong>当前输出目录</strong>的位置，例如~/hellocmake/build</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cmake_minumum_required(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellocmake)<br><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_SOURCE_DIR: $&#123;PROECJR_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure><h4id="和子模块的关系project_x_dir-和-cmake_current_x_dir">和子模块的关系：PROJECT_X_DIR和 CMAKE_CURRENT_x_DIR</h4><p>PROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt所在的源码目录。<br />CMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。<br />CMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。<br />利用 PROJECT_SOURCE_DIR 可以实现从子模块直接获取项目最外层的路径。<br /><strong>不建议使用 CMAKE_SOURCE_DIR ,那样会让你的项目无法被人作为子模块使用。</strong></p><blockquote><p>mylib got PORJECT_SOURCE_DIR: /home/bate/Codes/course/11/template</p><p>mylib got CMAKE_CURRENT_SOURCE_DIR:/home/bate/Codes/course/11/template/mylib</p></blockquote><h4 id="其他相关变量">其他相关变量</h4><ul><li>PROJECT_SOURCE_DIR : 当前项目源码路径( 存放 main.cpp 的地方)<br /></li><li>PROJECT_BINARY_DIR : 当前项目输出路径 ( 存放 main.exe 的地方 )<br /></li><li>CMAKE_SOURCE_DIR : 根项目源码路径 ( 存放 main.cpp 的地方 )<br /></li><li>CMAKE_BINARY_DIR : 根项目输出路径 ( 存放 main.cpp 的地方 )<br /></li><li>PROJECT_IS_TOP_LEVEL : BOOL 类型，表示当前项目是否是 ( 最顶层的 )根项目<br /></li><li>PROJECT_NAME : 当前项目名<br /></li><li>CMAKE_PROJECT_NAME : 根项目的项目名<br /></li><li>详见 : <ahref="https://cmake.org/cmake/help/latest/command/project.html">CMake之Project</a></li></ul><h4id="子模块也可使用-project-命令将当前目录作为一个独立的子项目">子模块也可使用project 命令，将当前目录作为一个独立的子项目</h4><p>这样 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。<br />这时候 CMake会认为这个子模块是一个独立的项目，会额外做一些初始化。<br />他的构建目录 PROJECR_BINARY_DIR 也会变成 build/<源码相对路径><br />这样在 MSVC 上也会看见 build/mylib.vcxproj 的生成</p><blockquote><p>PORJECT_NAME : hellowcmake</p><p>PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template</p><p>PROJECT_BINARY_DIR : /home/bate/Codes/course/11/template/build</p><p>CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template</p><p>CMAKE_CURRENT_BINARY_DIR :/home/bate/Codes/course/11/template/build</p><p>mylib got PROJECT_NAME : mylib</p><p>mylib got CMAKE_SOURCE_DIR : /home/bate/Codes/course/11/template</p><p>mylib got CMAKE_BINARY_DIR :/home/bate/Codes/course/11/template/build</p><p>mylib got PROJECT_SOURCE_DIR :/home/bate/Codes/course/11/template/mylib</p><p>mylib got PROJECT_BINARY_DIR :/home/bate/Codes/course/11/build/mylib</p><p>mylib got CMAKE_CURRENT_SOURCE_DIR :/home/bate/Codes/course/11/template/mylib</p><p>mylib got CMAKE_CURRENT_BINARY_DIR :/home/bate/Codes/course/11/template/build/mylib</p></blockquote><h4 id="project-的初始化-languages-字段">project 的初始化 : LANGUAGES字段</h4><ul><li>project( 项目名 LANGUAGES 使用的语言列表...)指定了该项目使用了那种编程语言<br />目前支持的语言：<ul><li>C : C语言<br /></li><li>CXX : C++<br /></li><li>ASM : 汇编<br /></li><li>Fortran : 老年人的编程语言(雾)，IBM<br /></li><li>CUDA : 英伟达的黑科技 CUDA ( 需要 CMake 3.8 版本 )<br /></li><li>OBJC : 苹果的 Objective-C ( 需要 CMake 3.16 版本 )<br /></li><li>OBJCXX : 苹果的 Objective-C++ ( 需要 CMake 3.16 版本 )<br /></li><li>ISPC : 一种英特尔的自动 SIMD 编程语言 ( 需要 CMake 3.18 版本 )<br /></li></ul></li><li>如果不指定 LANGUAGES, 默认为 C 和 CXX。</li></ul><h5id="常见问题languages-中没有启用-c-语言但却用到了-c-语言">常见问题：LANGUAGES中没有启用 C 语言，但却用到了 C 语言</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellocmake LANGUAGES CXX)<br><br><span class="hljs-keyword">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from Cmake!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样不行滴哥们，会报错，因为你在 CMakeLists.txt 的设置中没有启用 C语言。<br />解决办法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSiON <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellocmake LANGUAGES C CXX)<br><br><span class="hljs-keyword">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure><p>这次启用了 C 和 C++ 就不会报错力。</p><h5id="也可以先设置-languages-none-之后调用-enable_languagecxx">也可以先设置LANGUAGES NONE, 之后调用 enable_language(CXX)</h5><p>这样可以把 enable_language 放到 if语句中，从而只有某些选项开启才启用某语言类似的操作。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellocmake LANGUAGES NONE)<br><span class="hljs-keyword">enable_language</span>(CXX)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure><h4 id="设置-c-标准cmake_cxx_standard-变量">设置 C++标准：CMAKE_CXX_STANDARD 变量</h4><ul><li>CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。<br />比如需要 C++17 即设为 17。<br /></li><li>CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 型，可以为 ON / OFF , 默认为OFF。<br />表示是否一定要支持指定的 C++ 标准，如果为 OFF 则CMake 检测到编译器不支持C++17 时不报错，而是将设置调整为 C++14 让开发人员使用；为 ON时，不支持会报错，具有更好的安全性。<br /></li><li>CMAKE_CXX_EXTENSIONS 是 BOOL 变量，默认为 ON。为 ON 表示启用 GCC特有的一些拓展功能；OFF 则关闭 GCC 的拓展功能，只使用标准的 C++。<br />要兼容其他编译器( 如 MSVC )的项目都会将其设为 OFF，以防使用了 GCC特有的特性。<br /></li><li>注意，最好在 project 命令前设置 CMAKE_CXX_STANDARD一系列变量，这样一来 CMAKE 可以在 project函数内对编译器进行一些检测，查看是否能支持对应版本C++的特性。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">project</span>(hellocmake LANGUAGES CXX)<br></code></pre></td></tr></table></figure><h5 id="常见误区-小彭老师我手动加--stdc17-行不得行">常见误区 :小彭老师，我手动加 -std=c++17 行不得行</h5><ul><li>不要直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17<br />使用 CMake 封装好的 CMAKE_CXX_STANDARD<br />前者为什么不好，GCC 用户一旦手动指定 -std=c++17, 就是使用了 GCC的特性，而 MSVC 的用户就无法使用了。<br />而且 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加了-std=c++11，之后你再手动添加 -std=c++17 选项就发生了冲突。<br />所以一定要使用 CMake 已经封装好的 CMAKE_CXX_STANDARD !</li></ul><h3 id="projec-的初始化version-字段">projec 的初始化：VERSION 字段</h3><ul><li>project(项目名 VERSION x.y.z) 可以将当前项目的版本号设定为x.y.z<br />之后可以使用 PROJECT_VERSION 获取当前项目的版本号<br /></li><li>PROJECT_VERSION_MAJOR 获取 x ( 主版本号 )<br />PROJECT_VERSION_MINOR 获取 y ( 次版本号 )<br />PROJECT_VERSION_PATCH 获取 z ( 补丁版本号 )</li></ul><h4id="项目名的另一个作用-会设置另外-_source_dir-等变量">项目名的另一个作用: 会设置另外 <项目名>_SOURCE_DIR 等变量</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(hellocmake VERSION <span class="hljs-number">2.7</span>.<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_VERSION: $&#123;PROJECT_VERSION&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;hellocmake_VERSION: $&#123;hellocmake_VERSION&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;hellocmake_SOURCE_DIR: $&#123;hellocmake_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;hellocmake_BINARY_DIR: $&#123;hellocmake_BINARY_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>PROJECT_NAME: hellocmake<br />PROJECT_VERSION: 2.7.1<br />PROJECT_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />PROJECT_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa<br />hellocmake_VERSION: 2.7.1<br />hellocmake_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />hellocmake_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa</p></blockquote><p>这个功能可以让我们在当前项目去查询别的项目的版本号比如在 hellocmake查询 helloworld 的版本号或者其他信息。</p><h4 id="小技巧-cmake-的-表达式可以嵌套">小技巧 : CMake 的 ${}表达式可以嵌套</h4><p>因为 ${PROJECT_NAME} 的值是 hellocmake<br />所以 <span class="math inline">\({\)</span>{PROJECT_NAME}_VERSION}相当于 ${hellocmake_VERSION} 即 2.7.1<br /><a href="https://blog.csdn.net/fuyajun01/article/details/8891749">CMake其他关键字</a></p><h4 id="一个标准的-cmakelists.txt-模板">一个标准的 CMakeLists.txt模板</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">project</span>(zeno LANGUAGES C CXX)<br><br><span class="hljs-keyword">if</span>(PROJECT_BINARY_DIR <span class="hljs-keyword">STREQUAL</span> PROJECT_SOURCE_DIR)<br><span class="hljs-keyword">message</span>(WARING <span class="hljs-string">&quot;The binary directory of CMake cannot be the same as source directory!&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(WIN32)<br><span class="hljs-keyword">add_definitions</span>(-DNOMINMAX -D_USE_MATH_DEFINES)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> MSVC)<br><span class="hljs-keyword">find_program</span>(CCACHE_PROGRAM ccache)<br><span class="hljs-keyword">if</span>(CCACHE_PROGRAM)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;</span>)<br><span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)<br><span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="第三章链接库文件">第三章：链接库文件</h2><h3 id="main.cpp-调用-mylib.cpp-里的-say_hello-函数">main.cpp 调用mylib.cpp 里的 say_hello 函数</h3><ul><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li><li><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mylib.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-built_in">say_hello</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure></li><li><p>mylib.cpp<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mylib.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, mylib!\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li></ul><h4 id="改进mylib-作为静态库">改进：mylib 作为静态库</h4><blockquote><p><ahref="https://www.jianshu.com/p/090e1c0310ab">《静态库和动态库》</a> ,<ahref="https://blog.csdn.net/weixin_39766005/article/details/122368414">《CMake| 编译静态库、动态库和对象库》</a><br />静态库会在<em>链接时</em>完整的复制到每一个可执行文件，被多次使用时就会造成多分冗余。<br />动态库在<em>链接时</em>不复制，程序运行时由系统动态加载到内存中，供程序调用，系统仅需加载一次，多个程序公用，节省内存。</p></blockquote><ul><li><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib STATIC mylib.cpp)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li></ul><h4 id="改进mylib-作为一个动态库">改进：mylib 作为一个动态库</h4><ul><li>CMakeLists.txt ( 动态库在Windows上有坑 )<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li></ul><h4 id="改进mylib-作为一个对象库">改进：mylib 作为一个对象库</h4><p>对象库类似于静态库，但不生成 .a 文件，只由 CMake记住该库生成了那些对象文件<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_libraty(mylib OBJECT mylib.cpp)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p><p>对象库是 CMake自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。<br />在自己的项目中，推荐全部使用对象库( OBJECT ) 替代静态库 ( STATIC )避免跨平台的麻烦。<br />对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。</p><h4id="静态库的麻烦gcc-编译器会自作聪明将自动剔除没有引用符号的对象">静态库的麻烦：GCC编译器会自作聪明，将自动剔除没有引用符号的对象</h4><ul><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib STATIC mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li><li><p>mylib.cpp<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-comment">// 静态初始化  </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> unused = <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;My initialized\n&quot;</span>);<span class="hljs-comment">// 会在主函数前被执行  </span><br></code></pre></td></tr></table></figure></p></li><li><p>main.cpp<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main function\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li><li><p>Output<br />&gt;main function</p></li></ul><p>这里就是 GCC 看到没有引用人 mylib ，就会删掉 mylib.o但是恰恰遇到了静待初始化，GCC 就做错了。</p><h4id="对象库就可以绕开编译器的不统一保证不会自动剔除没有用到的对象文件">对象库就可以绕开编译器的不统一：保证不会自动剔除没有用到的对象文件</h4><ul><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib OBJECT mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li><li><p>mylib.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> unused = <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Mylib Function\n&quot;</span>);  <br></code></pre></td></tr></table></figure></li><li><p>main.cpp<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main Function\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li><li><p>Output<br />&gt;Mylib Function<br />&gt;Main Function</p></li></ul><h4 id="add_library-无参数时是静态库还是动态库">add_library无参数时，是静态库还是动态库</h4><p>会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。<br />ON 则相当于 SHARED, OFF 则相当于 STATIC<br />如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。<br />因此，如果发现一个项目内的 add_library都是无参的，意味着我们可以使用：<br /><code>cmake -B build -DBUILD_SHARD_LIBS:BOOL=ON</code><br />来让他全部生成为动态库，这里涉及到<em>命令行传递变量的规则。</em></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_library</span>(mylib mylib.cpp)<br></code></pre></td></tr></table></figure><h4 id="小技巧设定一个变量的默认值">小技巧：设定一个变量的默认值</h4><p>要让 BUILD_SHARED_LIBS 默认为 ON，可以用之前类似的思路<br />如果该变量没有定义，则设为 ON，否则保持用户指定的值不变<br />这样用户没有指定 BUILD_SHARED_LIBS 时，会默认变成ON。<br />只有用户指定 BUILD_SHARED_LIBS 为 OFF 即<code>-DBUILD_SHARED_LIBS:BOOL:OFF</code><br />才会生成静态库，否则默认生成动态库。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DEFINED</span> BUILD_SHARED_LIBS)<br><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h4id="常见坑点动态库无法链接静态库">常见坑点：动态库无法链接静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure><p><code>target_link_libraries(mylib PUBLIC otherlib)</code>试图将静态库<code>otherlib</code>链接到<code>mylib</code>中，发生错误。<em>静态库<code>otherlib</code>误以为用户将其连接到一个可执行文件上</em>，但用户却连接到动态库上。动态库在内存中的地址会变化的，在编译时会指定一个<code>fPIC</code>选项，但是静态库没有<code>fPIC</code>选项，静态库的地址并不想变化，而动态库本身却想改变地址，二者会发生冲突。</p><h5 id="解决办法">解决办法：</h5><p>1、将<code>otherlib</code>变为对象库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(otherlib OBJECT otherlib.cpp)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br>target_link_libraties(main PUBLIC mylib)<br></code></pre></td></tr></table></figure><p>2、让静态库编译也生成位置无关的代码( PIC )，这样才能装在动态库中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure><p>但是这样处理会导致本来不需要为静态 PIC 的静态库也变成 PIC了，<strong>所以我们可以只针对一个库，只对他启用位置无关的代码( PIC)</strong><br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(otherlib STATIC otherib.cpp)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br>target_link_libraried(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p><p><strong>注意，add_library()是要指定头文件的，这里偷懒没加，指定头文件后其就会出现在IDE中。</strong></p><h2 id="第四章-对象的属性">第四章 : 对象的属性</h2><p>前面提到的 <code>POSITION_INDEPENDENT_CODE</code>就是一个属性。<br />### 除了 <code>POSITION_INDEPENDENT_CODE</code> 还有哪些属性呢？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="hljs-number">17</span>)<span class="hljs-comment"># 采用 C++17 标准编译( 默认为11 )</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<span class="hljs-comment"># 如果编译器不支持 C++17，则直接报错( 默认为 OFF )</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class="hljs-keyword">ON</span>)<span class="hljs-comment"># 在 Windows 系统中运行时不启动控制台窗口，只有 GUI 界面 (默认 OFF)</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span>)<span class="hljs-comment"># 告诉编译器不要自动剔除没有引用符号的链接库(默认 OFF)</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<span class="hljs-comment"># 设置动态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<span class="hljs-comment"># 设置静态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<span class="hljs-comment"># 设置可执行文件的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br></code></pre></td></tr></table></figure><p>这样一个一个 <code>set_property</code>好麻烦啊！要是有更简单的写法就好了，于是……</p><h3 id="另一个方法-set_target_properties-批量设置多个属性">另一个方法 :<code>set_target_properties</code> 批量设置多个属性</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">set_target_properties</span>(main PROPERTIES<br>CXX_STANDARD <span class="hljs-number">17</span><br>CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span><br>WIN32_EXECUTABLE <span class="hljs-keyword">ON</span><br>LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span><br>LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin<br>)<br></code></pre></td></tr></table></figure><h3id="另一种方法通过全局的变量让之后创建的所有对象都享有同样的属性">另一种方法：通过全局的变量，让之后创建的所有对象都享有同样的属性</h3><p>相当于改变了各属性的默认初始值，要注意<em>此时</em><code>set(CMAKE_xxx)</code> <em>必须在</em> <code>add_executable</code><em>之前才有效</em>。<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_WIN32_EXECUTABLE <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br>add_executbale(main main.cpp) <span class="hljs-comment"># 这里需要放在后面</span><br></code></pre></td></tr></table></figure></p><h3 id="百度常见的错误">百度常见的错误！！！</h3><p>对于 <code>CXX_STANDARD</code> 这种 CMake本身提供了变量进行配置设置的，不要自己去设置 -std=c++17 选项，会和 CMake自己设置好的产生冲突，导致出错！<br />请始终使用 <code>CXX_STANDARD</code> 或者全局变量<code>CMAKE_CXX_STANDARD</code> 来设置 -std=c++17 这个 flag，CMake会在配置阶段进行编译器检测是否支持 C++17。<br />CUDA 的 -arch=sm_75 也是同样的道理，请使用<code>CUDA_ARCHITECTURES</code> 属性。<br />再者说 -std=c++17 只是 GCC 编译器的选项，也不能进行跨平台适用于 MSVC编译器啊！！！</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="hljs-number">17</span>)<span class="hljs-comment"># 正确</span><br><span class="hljs-keyword">target_compile_options</span>(main PUBLIC <span class="hljs-string">&quot;-std=c++17&quot;</span>)<span class="hljs-comment"># 错误！！！！</span><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> main PROPERTY CUDA_ARCHITECTURES <span class="hljs-number">75</span>)<span class="hljs-comment"># 正确</span><br><span class="hljs-keyword">target_compile_options</span>(main PUBLIC <span class="hljs-string">&quot;-arch=sm_75&quot;</span>)<span class="hljs-comment"># 错误！！！</span><br></code></pre></td></tr></table></figure><h3 id="假如在-windows-使用动态链接库需要额外操作">假如在 Windows使用动态链接库，需要额外操作</h3><p><code>m/mylib.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-comment">// 需要手动加入这几句，在实现处加入dllexport</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><br>__declspec(dllexport)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>m/mylib.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">// 在声明处，加入import</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><br>__declspec(dllimport)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>根目录下的 <code>CMakeLists.txt</code><br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">add_subdirectory</span>(mylib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p><p>子目录<code>m</code>下的<code>CMakeLists.txt</code>,<code>m/CMakeLists.txt</code><br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br></code></pre></td></tr></table></figure></p><h4id="常见问题链接了自己的-dll但是运行时会找不到">常见问题：链接了自己的dll，但是运行时会找不到</h4><ul><li>这是因为 dll 和 exe 不在用一个目录，而愚蠢的 Windows只会在<strong>当前 exe 所在目录查找</strong>，<strong>然后查找<em>PATH环境变量</em></strong>，找不到就报错。而 dll 在其他目录，因此Windows 找不到。<ul><li><strong>解决办法1</strong>：把 dll 所在位置加到<em>PATH环境变量</em> 里，一劳永逸。<br /></li><li><strong>结局办法2</strong>：把这个 dll，以及这个 dll 依赖的其他所有dll，全部拷贝到和 exe 文件同一目录下。</li></ul></li></ul><h4id="手动拷贝-dll-好麻烦cmake-能不能救一下把-dll-自动生成在-exe-同一目录下">手动拷贝dll 好麻烦，CMake 能不能救一下！把 dll 自动生成在 exe 同一目录下</h4><ul><li>说到底还是因为 CMake 把定义在顶层模块里的 main 放在<code>build/main.exe</code><br />而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了<code>build/mylib/mylib.dll</code></li></ul><h5id="解决1设置-mylib-对象的-xx_output_deirectory-系列属性">解决1：设置mylib 对象的 xx_OUTPUT_DEIRECTORY 系列属性</h5><ul><li><p>所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到PROJECT_BINARY_DIR，也就是项目根目录( main 所在的位置 )，这样 main.exe在运行时就能找到 mylib.dll</p></li><li><p>为了侍奉 Windows，要设置全部的 6个属性！很烦！<br /><code>m/CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br></code></pre></td></tr></table></figure><p>这样就会输出到项目根目录 build 目录下</p></li></ul><h5 id="而在-linux-系统下就显得简便了">而在 Linux系统下就显得简便了</h5><ul><li>Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH里找链接库，所以即使不在同目录也能找到。<br />所以<strong>第三种解决办法</strong>，卸载 Windows 安装 Linux。<br /></li><li>需要手动修改或者查看一个 ELF 文件的 RPATH，可以用 chrpath 或者pathchelf 命令。</li></ul><h2 id="第五章连接第三方库">第五章：连接第三方库</h2><h3 id="例子需要使用-tbb-库">例子：需要使用 tbb 库</h3><ul><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC tbb)<span class="hljs-comment"># Linux 上直接链接 tbb 是可以的，但是 Windows 可能不行。  </span><br></code></pre></td></tr></table></figure></p></li><li><p>main.cpp<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/parallel_for.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>tbb::<span class="hljs-built_in">parallel_for</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,[&amp;](<span class="hljs-type">int</span> i)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %d!\n&quot;</span>, i);  <br>    &#125;);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li><li><p>OutPut<br />&gt;Hello, 0!<br />&gt;Hello, 1!<br />&gt;Hello, 2!<br />&gt;Hello, 3!</p></li></ul><h4 id="直接链接-tbb-的缺点">直接链接 tbb 的缺点</h4><p>Linux 可以直接链接，是因为其有默认的库目录 <code>usr/lib</code>，但是 Windows 没有一个固定的库安装位置。Linux 因为<code>usr/lib/</code>, Linux 可以找到<code>usr/lib/libtbb.so</code><br />如果这样直接指定 tbb，CMake 会让连接器在系统的库目录里查找 tbb，他会找到<code>usr/lib/libtbb.so</code>这个系统自带的，但是对于没有一个固定库安装位置的 Windows系统并不适用。<br />此外，他还要求 tbb 的头文件就在 <code>usr/include</code>这个系统默认的头文件目录，<br />这样才能 <code>#include &lt;tbb/parallel_for.h</code> 不报错，如果 tbb的头文件在其他地方<br />就需要再加一个 <code>target_include_directories</code>设置额外的头文件查找目录。</p><ul><li>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC tbb)  <br></code></pre></td></tr></table></figure></li></ul><h4 id="windows-可以直接写出全部的绝对路径十分的硬核">Windows可以直接写出全部的绝对路径，十分的硬核</h4><p>也可以直接写出全部的路径，这样就能让没有默认系统路径的 Windows系统找到安装在不知何处的tbb，不过这样就不能跨平台了，如果其他人安装在不同位置就会发生错误。<br /><strong>顺便一提，CMake 的路径分隔符始终是<code>/</code>。即使在 Windows上，也要把所有的 <code>\</code> 改成<code>/</code></strong>，这是为了跨平台考量。请放心，CMake 会自动在调用MSVC时转换成 <code>\</code> ，可以放心的用 <code>$&#123;x&#125;/bin</code>来实现和 Python 的 <ahref="https://blog.csdn.net/swan777/article/details/89040802"><code>os.path.join(x, 'bin')</code></a>一样的效果。</p><ul><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC C:/User/archibate/installed/tbb/tbb.dll)  <br></code></pre></td></tr></table></figure></p><blockquote><p>大多数操作系统都是 Unix-like，只有 Windows 搞特殊。<br /><code>cd /d C:\\Program\ Files\\(x86\)\\Micsoft\ Visual\ Studio\\2019\\</code><br />在路径中动不动就放一堆转移符、空格、特殊符号<br />高情商：Windows 是最适合练习 C 语言转移符使用水平的平台！</p></blockquote></li></ul><h4 id="终于find_package">终于！<code>find_package</code></h4><p>更通用的方式：find_package<br />更好的办法就是使用 CMake 的 <code>find_package</code> 命令。<br /><code>find_package(TBB REQUIRED)</code> 会查找<code>/usr/lib/cmake/TBB/TBBConfig.cmake</code>这个配置文件，根据里面的配置信息创建 <code>TBB::tbb</code> 这个伪对象(实际它指向真正的 tbb 库文件路径 <code>usr/lib/libtbb.so</code>)，之后通过 <code>target_link_libraries</code> 链接<code>TBB::tbb</code> 就可以正常工作。</p><ul><li>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_executbale(main main.cpp)<br><br><span class="hljs-keyword">find_package</span>(TBB REQUIRED)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<span class="hljs-comment"># TBB 包下的 tbb 库  </span><br></code></pre></td></tr></table></figure></li></ul><h5 id="tbbtbb-的秘密自带了一些-public-属性"><code>TBB::tbb</code>的秘密：自带了一些 PUBLIC 属性</h5><p><code>TBB::tbb</code> 是一个伪对象( imported )，他除了会指向<code>/usr/lib/libtbb.so</code>，TBBConfig.cmake 还会给 TBB::tbb添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。<br />比如，TBB 安装在 <code>/opt/tbb</code> 目录下，头文件在<code>/opt/tbb/include</code> 里，那么这时 TBBConfig.cmake 里就会有 :<code>target_include_directories(TBB::tbb PUBLIC /opt/tbb/include)</code><br />这样 main 在链接了 TBB::tbb 时也会被“传染”上<code>/opt/tbb/include</code> 这个目录，无需手动添加。<br />再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那么这个库也会自动连接到main 上，无需调用者手动添加。</p><blockquote><p>比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY这个宏为 PUBLIC 。从而实现直接 #include &lt;spdlog/spdlog.h&gt;时候时纯头文件，而 find_package(spdlog REQUIRED)时却变成预编译链接库的版本。( 其实不是 PUBLIC 而是INTERFACE，因为伪对象没有实体 )</p></blockquote><h5 id="和-find_packagetbb-config-required-有什么区别">和<code>find_package(TBB CONFIG REQUIRED)</code> 有什么区别</h5><p>其实更好的是通过<code>find_package(TBB CONFIG REQUIRED)</code>，添加一个 CONFIG选项。<br />这样他会优先查找 TBBConfig.cmake ( 系统自动的 ) 而不是 FindTBB.cmake (项目作者常把他塞在 cmake/ 目录里并添加到 CMAKE_MODULE_PATH)。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。</p><ul><li>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">find_package</span>(TBB CONFIG REQUIRED)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br></code></pre></td></tr></table></figure></li></ul><p>当然如果坚持要用 find_package(TBB REQUIRED) 也是可以的。<br />没有 CONFIG 选项：先找 FindTBB.cmake，再找TBBConfig.cmake，找不到就报错。<br />有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错。<br />此外有一些老年项目( 比如 OpenVDB ) 只提供 Find 而没有 Config文件，这时候只能用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG选项。</p><h4id="usrlibcmaketbbtbbconfig.cmake-长什么样">/usr/lib/cmake/TBB/TBBConfig.cmake长什么样？</h4><p>不论 TBBConfig.cmake 还是FindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写FindXXX.cmake 才能使用。</p><ul><li>TBBConfig.cmake<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Create imported target TBB::tbb  </span><br><span class="hljs-keyword">add_library</span>(TBB::tbb SHARED IMPORTED)<br><br><span class="hljs-keyword">set_target_properties</span>(TBB::tbb PROPERTIES  <br>INTERFACE_COMPILE_DEFINITIONS <span class="hljs-string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>INTERFACE_INCLUDE_DIRECTORIES <span class="hljs-string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class="hljs-comment"># Create imported target TBB::tbbmalloc  </span><br><span class="hljs-keyword">add_library</span>(TBB::tbbmalloc SHARED IMPORTED)<br><br>set_target_proerties(TBB::tbbmalloc PROPERTIES  <br>INTERFACE_COMPILE_DEFINITIONS <span class="hljs-string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>INTERFACE_INCLUDE_DIRECTORIES <span class="hljs-string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class="hljs-comment"># Create imported target TBB::tbbmalloc_proxy  </span><br><span class="hljs-keyword">add_library</span>(TBB::tbbmalloc_proxy SHARED IMPORTED)<br><br><span class="hljs-keyword">set_target_properties</span>(TBB::tbbmalloc_proxy PROPERTIES  <br>INTERFACE_COMPILE_DEFINITIONS <span class="hljs-string">&quot;\$&lt;\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>INTERFACE_INCLUDE_DIRECTORIES <span class="hljs-string">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)  <br></code></pre></td></tr></table></figure></li></ul><h4 id="find_packageqt5-required-出错">find_package(Qt5 REQUIRED)出错</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Qt5 REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure><ul><li><strong>ERROR</strong><br /><img src="/imgs/CMake Note/Qt5Error.png" alt="Qt5报错"><br />这里是说( 看最后一句 ) Qt5 包至少需要一个组件。<br />Qt5 有很多组件，但是直接 <code>find_package(Qt5 REQUIRED)</code>他不知道用户需要哪些组件。</li></ul><h5 id="原因qt5-具有多个组件你必须指定你需要哪些组件">原因：Qt5具有多个组件，你必须指定你需要哪些组件</h5><p>find_package 生成的伪对象 (imported target) 都按照 “包名::组件名”的格式命名。<br />可以在 find_package 中通过 <strong>COMPONENTS</strong>选项，后面跟随一个列表表示需要用的组件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(Qt5 COMPONENTS Widgets Gui REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)<br></code></pre></td></tr></table></figure><h5 id="常见错误windows-找不到-qt5">常见错误：Windows 找不到 Qt5</h5><p>因为 Windows 系统安装路径混乱没有固定的 /usr/lib之类的默认路径能供CMake搜索所以报错了。<br /><img src="/imgs/CMake Note/Qt5CannotFound.png" alt="Qt5找不到"></p><ul><li><p>假设 Qt5 安装在 C:.2，去找这个目录<br />C:.2_64<br /></p></li><li><p>会有一个 Qt5Config.cmake，现在有四种办法可以让CMake找到他</p><ul><li><p><strong>第一种</strong>：设置 CMAKE_MODULE_PATH变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径C:.2_64，当然这里也要把 <code>\</code> 换成 <code>/</code>，因为 CMake是倾向 Unix的构建，<em><del>这是派别和历史问题了</del></em>。这种方法相当于在 CMake搜索目录里加上这个路径，其他包在搜索遍历时也会遍历过这个路径，后面会有更好的办法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_MODULE_PATH&#125;</span> C:/Qt/Qt5.<span class="hljs-number">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class="hljs-keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li><li><p>**第二种(更好的办法)：设置<包名>_DIR 变量指向 <包名>Config.cmake所在位置**<br />设置 Qt5_DIR 这个变量为 C:.2_64 这样只有 Qt5 这个包会去这个目录里搜索Qt5Config.cmake 更有针对性。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(Qt5_Dir C:/Qt/Qt5.<span class="hljs-number">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class="hljs-keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li><li><p>第三种(推荐)，直接在命令行通过 <code>-DQt5_DIR="xxx"</code>指定，这样不用修改 CMakeLists.txt<br /><code>cmake -B build -DQt5_DIR="C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake"</code><br /></p></li><li><p>第四种，还可以设置环境变量 Qt5_DIR 也是可以的，就是对 Windows用户比较困难<br /><code>export Qt5_DIR="/opt/Qt5.14.2/lib/cmake"</code></p></li></ul></li></ul><h3id="不指定-required-找不到时不报错只会设置-tbb_found-为-false">不指定REQUIRED 找不到时不报错，只会设置 TBB_FOUND 为 FALSE</h3><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(TBB)  <br><span class="hljs-keyword">if</span>(TBB_FOUND)  <br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)  <br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)  <br><span class="hljs-keyword">else</span>()  <br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;TBB not found! using serial for&quot;</span>)  <br><span class="hljs-keyword">endif</span>()  <br></code></pre></td></tr></table></figure></p><p>前面很多例子都在 find_package() 加上 REQUIRED 选项。<br />如果我们不加 REQUIRED，在找不到对应 package 时不会报错。<br />这样的设计目的在于，当我们添加一些可选的依赖，如果没有也不会影响程序基本运行，我们找不到可选项，就可以向用户抛出一个警告。<br />找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 也会设置为 TBBConfig.cmake所在目录。<br />找不到会把 TBB_FOUND 设为 FASLE，TBB_DIR 也会为空。<br />这里我们在找到 TBB 的 if 里定义一个 WITH_TBB 宏，稍后在 .cpp里就可以根据这个判断。<br />如果找不到 TBB 可以 fallback 到保守的实现方式。<br /><code>-- TBB found at: /usr/lib64/cmake/TBB</code></p><h4 id="在-c-中判断-with_tbb-宏找不到-tbb-则退化到串行-for-循环">在 C++中判断 WITH_TBB 宏，找不到 TBB 则退化到串行 for 循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WITH_TBB</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/parallel_for.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WITH_TBB</span><br>tbb::<span class="hljs-built_in">parallel_for</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,[&amp;](<span class="hljs-type">int</span> i)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, %d!\n&quot;</span>,i);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WITH_TBB</span><br>    &#125;);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3id="也可以使用-target-判断是否存在-tbbtbb-这个伪对象实现-tbb_found-的效果">也可以使用TARGET 判断是否存在 TBB::tbb 这个伪对象，实现 TBB_FOUND 的效果</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(TBB)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">TARGET</span> TBB::tbb)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;TBB not found! using serial for&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>同时也可以在 if 进行复合语句判断<br /><code>NOT TARGET TBB::tbb AND TARGET Eigen3::eigen</code><br />表示找得到 TBB 但是找不到 Eigen3。</p><h2 id="第六章输出与变量">第六章：输出与变量</h2><h3 id="在运行-cmake--b-build-时打印字符串用于调试程序">在运行 cmake -Bbuild 时，打印字符串用于调试程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Hello world</p></blockquote><p>message 会把字符串打在命令行。</p><h4 id="messagestatus-...">message(STATUS "...")</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>-- Hello world</p></blockquote><p>不带 <code>STATUS</code> 选项，cmake认为：“哦，你的需求很紧急，你只想调试程序。”，被认为是调试信息。<br />带上 <code>STATUS</code> 表示是状态信息，告诉用户做了这件事。</p><h4 id="messagewaring-...-表示警告信息">message(WARING "...")表示警告信息</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;This is a warning sign&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>CMake Warning at CMakeLists.txt:2 (message):<br />This is a warning sign!</p></blockquote><h4id="messageauthor_warning-...-表示仅仅是给项目作者看的警告">message(AUTHOR_WARNING"...") 表示仅仅是给项目作者看的警告</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">message</span>(AUTHOR_WARNING <span class="hljs-string">&quot;Hollow Knight is the best!&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>-- Hello world<br />CMake Warning (dev) at CMakeLists.txt:2 (message):<br />Hollow Knight is the best!<br />This warning is for project developers. Use -Wno-dev suppress it.</p></blockquote><p><strong>AUTHOR_WARNING 可以通过 -Wno-dev 关闭</strong></p><p><code>cmake -B build -Wno-dev</code></p><h4id="messagefatal_error-...-表示是错误信息会终止-cmake-的运行">message(FATAL_ERROR"...") 表示是错误信息，会终止 CMake 的运行</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;This is an error message!&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>-- Hello world<br />CMake Error at CMakeLists.txt:2 (message):<br />This is an error message!</p></blockquote><p>因为程序被中断所以 Hello world 被打印，Error 有执行，但是 After Error没有执行，因为在 Error message 处被中断运行了。</p><h4id="messagesend_error-...-表示错误信息但之后的语句仍继续执行">message(SEND_ERROR"...") 表示错误信息，但之后的语句仍继续执行</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">message</span>(SEND_ERROR <span class="hljs-string">&quot;This is an error message!&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>-- Hello world<br />CMake Error at CMakeLists.txt:2 (message) :<br />This is an error message</p><p>After Error</p></blockquote><p>可以看到 After Error 正常运行。</p><h3 id="message-可以用于打印变量">message 可以用于打印变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar <span class="hljs-string">&quot;Hello world&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>myvar is: Hello world<br />-- Configuring done<br />-- Generating done</p></blockquote><h4 id="如果-set-没加引号会怎么样">如果 set 没加引号会怎么样？</h4><p><strong>会变成分号分隔的列表。</strong><br />这时候 set(myvar Hello world) 等价于 set(myvar "Hello;world")</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar Hello world)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>myvar is: Hello;world<br />-- Configuring done<br />-- Generating done</p></blockquote><h4 id="如果-message-没加引号会怎么样">如果 message没加引号会怎么样？</h4><p><strong>会把列表里的字符串当作他的关键字</strong><br />结论：除非实在实在需要列表，不然建议始终在你不确定的地方加上引号，例如：<br />set(source "main.cpp" "mylib.cpp" "C:/Program Files/a.cpp")<br />message("${source}")<br />这里的 <code>C:/Program Files/a.cpp</code>有空格所以最好使用引号，这也是为什么CMake用 <code>;</code> 做分割，因为<code></code> 可能出现在路径中，而 <code>;</code>不会出现在文件路径中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar FATAL_ERROR hello)<br><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;myvar&#125;</span>)<br><span class="hljs-comment"># 这样$&#123;myvar&#125; 会变成 FATAL_ERROR hello</span><br></code></pre></td></tr></table></figure><blockquote><p>CMake Error at CMakeLists.txt:2 (message) :<br />hello</p></blockquote><h2 id="第七章变量与缓存最大坑点">第七章：变量与缓存(最大坑点)</h2><h3 id="重复执行-cmake--b-build-会有什么区别">重复执行 cmake -B build会有什么区别</h3><p>假如多次执行后几次执行会比第一次执行输出少很多。<br />这是因为 CMake 第一遍需要检测编译器和 C++特性等比较耗时，检测完后会把结果存储的<strong>缓存</strong>中，这样第二遍运行cmake-B build 时就可以直接使用缓存的值，就不需要在检测一遍了。</p><h3 id="如何清理缓存删-build-大法">如何清理缓存？删 build 大法</h3><p>虽然 CMake缓存为了加快编译的出发点是好的，但是有问题。比如有时候外部的情况有所更新比如原来的编译器被卸载或者更改，这时候CMake 缓存内却还存储的是旧的值，就会导致一些问题。<br />最简单的解决办法就是删除 build 文件夹，然后重新运行 cmake -Bbuild。<br />缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以先试着删除build 重新构建看看。<br />删除了缓存就会重新跑一边检测，写新缓存。<br />所以有了经典的 CMake 笑话：</p><blockquote><p>99%的 cmake 错误都可以用删 build 解决<br />删 build 大法好<br />rm -rf build</p></blockquote><h3id="清除缓存其实只需删除-buildcmakecache.txt-就可以了">清除缓存，其实只需删除build/CMakeCache.txt 就可以了</h3><p>删除 build 虽然简单粗暴彻底，但是这会导致编译产生的中间结果 (.o文件)也都被删除了，重新编译需要花费很长时间。<br />如果只想清除缓存，不想从头重新编译，可以只删除 build/CMakeCache.txt这个文件。<br />它存储了缓存的变量，删除它就可以让 CMake强制重新检测一遍所有的库和编译器。<br />但是有些错误是中间文件的问题还是要删除 build<br />### find_package 就用到了缓存机制</p><p>变量缓存的意义在于能把 find_package找到的库文件位置等信息，存储起来。<br />这下下次 find_package 时就会利用上缓存的变量，直接返回。<br />避免重复执行 cmake -B 时速度变慢的问题。</p><p>但是会有这样一个问题，假如第一次 build，没有 TBB 库<br />然后我们安装 TBB 后，再次进行build<br />这时候 CMake 读了缓存发现：“哦，我之前找过 TBB，没找到，那不用找了没有TBB 库”<br />这时候 CMake 就不会去找了……<br />这时候就要 rm -rf build/CMakeCache.txt，删除缓存文件让 CMake强行重新配置。</p><h3 id="设置缓存变量">设置缓存变量</h3><p>语法是：<code>set(变量名 "变量值" CACHE 变量类型 "注释")</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar <span class="hljs-string">&quot;hello&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;this is the docstring.&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>缓存的 myvar 会出现在 build/CMakeCache.txt 里。</strong></p><h3id="常见问题我修改了-cmakelists.txt-里-set-的值却没有更新">常见问题：我修改了CMakeLists.txt 里 set 的值，却没有更新。</h3><p>为了更新缓存变量，经常有人偷懒直接修改 CMakeLists.txt里的值，这是没用的。<br />因为 set(...CACHE..)在缓存变量已经存在的时候，不会去更新缓存的值。<br />CMakeLists.txt 里 set 的值被认为是“默认值”，因此不会在第二次 set的时候更新。<br />比如上面我们设置过 myvar 的内容是 hello，然后 build，现在改成world，但是 CMakeCaChe.txt 内的 myvar 还会是 hello</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar <span class="hljs-string">&quot;world&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;This is the docstring!&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3id="缓存变量如何更新标准解法通过命令行--d参数">缓存变量如何更新？标准解法：通过命令行-D参数</h3><p>当然可以使用 ”删 build 大法“，但是有更好的。<br />更新缓存变量正确的方式，通过命令行参数：<code>cmake -B build -Dmyvar=world</code></p><h4 id="命令行--d-太硬核了有没有图形化的缓存编译器">命令行 -D太硬核了，有没有图形化的缓存编译器？</h4><ul><li>在 Linux 中，可以运行 ccmake -B build启动基于终端的可视化缓存编辑菜单。<br /></li><li>在 Windows 中，可以 cmake-gui -B build来启动图形界面编辑各个缓存选项。<br /></li><li>当然，可以直接用编辑器打开 build/CMakeCaChe.txt 修改后保存。<br />CMakeCaChe.txt用文本文件存储的目的就是可供用户手动编辑，或者被第三方软件打开并解析的。</li></ul><h3 id="也可以通过指定-force-来强制-set-更新缓存">也可以通过指定 FORCE来强制 set 更新缓存</h3><p>set 可以在后面加一个 FORCE选项，表示无论缓存存在与否，都强制更新缓存。<br />不过这样就会导致没办法用 -Dmyvar=othervalue 来更新缓存变量。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(myvar <span class="hljs-string">&quot;world&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;This is the docstring&quot;</span> FORCE)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;mtvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="缓存变量除了-string-还有哪些类型">缓存变量除了 STRING还有哪些类型？</h3><ul><li>STRING 字符串，比如："hello","world"<br /></li><li>FILEPATH文件路径，例如："C:/vcpkg/scripts/buildsystems/vcpkg.cmake"<br /></li><li>PATH 目录路径，例如："C:/Qt/Qt5.14.2/msvc2019_64/cmake/"<br /></li><li>BOOL 布尔值，只有两个取值：ON 或 OFF<br />注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF等价。</li></ul><h4 id="添加一个-bool-类型变量用于控制是否启用某些特性">添加一个 BOOL类型变量，用于控制是否启用某些特性</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">set</span>(WITH_TBB <span class="hljs-keyword">ON</span> CACHR BOOL <span class="hljs-string">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><br><span class="hljs-keyword">if</span>(WITH_TBB)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br><span class="hljs-keyword">find_package</span>(TBB REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>这里就是用 CACHE变量 控制是否启用 TBB。</p><h4 id="cmake-对-bool-类型缓存的-set-提供了简写option">CMake 对 BOOL类型缓存的 set 提供了简写：option</h4><p><code>option(变量名 "描述" 变量值)</code><br />等价于<br /><code>set(变量名 CACHE BOOL 变量值 "描述")</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">option</span>(WITH_TBB <span class="hljs-string">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><span class="hljs-keyword">if</span>(WITH_TBB)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br><span class="hljs-keyword">find_package</span>(TBB REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>option 的本质还是 set CACHE<br />所以还会有和 set CACHE 一样的问题：option 设置成了 OFF，但是还是ON。</p><h4id="常见问题在-cmakelists.txt-里修改了-option-为-off但是运行出来还是-on">常见问题：在CMakeLists.txt 里修改了 option 为 OFF，但是运行出来还是 ON</h4><p>因为 option 本质就是 set CACHE，<br />虽然修改了，但是 CMakeCaChe.txt 内还是 ON</p><h4 id="解决办法还是--d参数-来修改">解决办法还是 -D参数 来修改</h4><p>-D变量名:BOOL=ON/OFF<br /><code>cmake -B build -DWITH_TBB:BOOL=OFF</code></p><h4 id="或者改用-set-然后-force">或者改用 set 然后 Force</h4><h4id="绕靠缓存使用普通变量但仅当没有定义时设定为默认值">绕靠缓存：使用普通变量，但仅当没有定义时设定为默认值</h4><p>一般而言，CMake 自带的变量( 如 CMAKE_BUILD_TYPE )都这样设置。<br /><strong>这样项目的使用者还是可以用 -D来指示参数，</strong>只不过不会在ccmake 里被显示。(ccmake是查询缓存的)</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DEFINED</span> WITH_TBB)<br><span class="hljs-keyword">set</span>(WITH_TBB <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;WITH_TBB: $&#123;WITH_TBB&#125;&quot;</span>)<br><span class="hljs-keyword">if</span>(WITH_TBB)<br>target_compile_definition(main PUBLIC WITH_TBB)<br><span class="hljs-keyword">find_package</span>(TBB REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="第八章跨平台和编译器">第八章：跨平台和编译器</h2><h3 id="在cmake-中给-.cpp-定义一个宏">在CMake 中给 .cpp 定义一个宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MY_MACRO</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MY_MACRO defined! value: %d\n&quot;</span>, MY_MACRO);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MY_MACRO not defined!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_MACRO=<span class="hljs-number">233</span>)<span class="hljs-comment"># 相当于 gcc -DMY_MACRO=233</span><br></code></pre></td></tr></table></figure><blockquote><p>MY_MACRO defined! value: 233</p></blockquote><h3id="根据不同的操作系统把宏定义为不同的值">根据不同的操作系统，把宏定义为不同的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MY_NAME</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, MY_NAME);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I don`t know your name!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(CMAKE_SYSTEM_NAME <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Windows&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Bill Gates&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Linux&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Linus Torvalds&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_SYSTEM_NAME <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Darwin&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Steve Jobs&quot;</span>)<br><span class="hljs-keyword">elseif</span>()<br></code></pre></td></tr></table></figure><h3 id="cmake-提供了一些简写变量win32-apple-unix-android-ios等等">CMake提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等等</h3><p>虽然是 WIN32 但是对 32位和 64位Windows一样适用<br />APPLE 对所有苹果产品 MacOS/IOS 都为真<br />UNIX 对所有 Unix 类系统( FreeBSD, Linux, Android, MacOS, IOS )都为真</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(WIN32)<span class="hljs-comment"># WIN32 这些是 bool 类型</span><br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Bill Gates&quot;</span>)<br><span class="hljs-keyword">elseif</span>(UNIX <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> APPLE)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Linus Torvalds&quot;</span>)<br><span class="hljs-keyword">elseif</span>(APPLE)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Steve Jobs&quot;</span>)<br><span class="hljs-keyword">elseif</span>()<br></code></pre></td></tr></table></figure><h3 id="使用生成器表达式简化指令">使用生成器表达式，简化指令</h3><p>语法：<code>$&lt;$&lt;类型:值&gt;:为真时表达式&gt;</code><br />比如<code>$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME="Bill Gates"&gt;</code><br />在 Windows 平台上还会变成 MY_NAME="Bill Gates"<br />其他平台则为空字符。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC<br>$&lt;$&lt;PLATFROM_ID:Windows&gt;:MY_NAME=<span class="hljs-string">&quot;Bill Gates&quot;</span>&gt;<br>$&lt;$&lt;PLATFROM_ID:Linux&gt;:MY_NAME=<span class="hljs-string">&quot;Linus Torvalds&quot;</span>&gt;<br>$&lt;$&lt;PLATFROM_ID:Darwin&gt;:MY_NAME=<span class="hljs-string">&quot;Steve Jobs&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure><h3id="生成器表达式如需多个平台可以用逗号分隔">生成器表达式：如需多个平台可以用逗号分隔</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC<br>$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class="hljs-string">&quot;DOS-like&quot;</span>&gt;<br>$&lt;$&lt;PLATFROM_ID:Linux,Darwin,FreeBSD&gt;:MY_NAME=<span class="hljs-string">&quot;Unix-like&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure><p>相关参考：<ahref="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:PLATFROM_ID">CMake: PLATFROM_ID</a></p><h3 id="判断当前是哪一款-c-编译器">判断当前是哪一款 C++ 编译器</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;GNU&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;gcc&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;NVIDIA&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;nvcc&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Clang&quot;</span>)<br>target_compile_difinitions(mian PUBLIC MY_NAME=<span class="hljs-string">&quot;clang&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;MSVC&quot;</span>)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;msvc&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="也同样可以使用生成器表达式">也同样可以使用生成器表达式</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC<br>$&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:MY_NAME=<span class="hljs-string">&quot;Open-source&quot;</span>&gt;<br>$&lt;$&lt;CXX_COMPILER_ID:MSVC,NVIDIA&gt;:MY_NAME=<span class="hljs-string">&quot;Commercial&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure><h3id="生成器表达式可以做复杂的逻辑判断">生成器表达式可以做复杂的逻辑判断</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC<br>$&lt;$&lt;<span class="hljs-keyword">AND</span>:$&lt;CXX_COMPILER_ID:GNU,Clang&gt;,$&lt;PLATFROM_ID:Linux,FreeBSD&gt;&gt;:MY_NAME=<span class="hljs-string">&quot;Open-source&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure><h3 id="cmake-还提供了一些简写变量msvc-cmake_compiler_is_gnucc">CMake还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(MSVC)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;MSVC&quot;</span>)<br><span class="hljs-keyword">elseif</span>(CMAKE_COMPILER_IS_GNUCC)<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;GCC&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;Other compiler&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="cmake_cxx_compiler_id-直接作为字符串变量">CMAKE_CXX_COMPILER_ID直接作为字符串变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="hljs-string">&quot;The $&#123;CMAKE_CXX_COMPILER_ID&#125; Compiler&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="从命令行参数指定编译器">从命令行参数指定编译器</h3><p><code>cmake -B build -DCMAKE_CXX_COMPILER="/usr/bin/clang++"</code><br />当然这个得第一次就定义，如果第二次使用这个命令需要 删build清除缓存。</p><h3 id="也可以通过环境变量-cxx-指定">也可以通过环境变量 CXX 指定</h3><p><code>CXX='which clang' cmake -B build</code></p><h3 id="cmake_generator-也可以了解一下">CMAKE_GENERATOR也可以了解一下</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Generator:$&#123;CMAKE_GENERATOR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;C++ compiler: $&#123;CMAKE_CXX_COMPILER&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;C compiler: $&#123;CMAKE_C_COMPILER&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="第九章分支和判断">第九章：分支和判断</h2><h3 id="bool-类型的值">BOOL 类型的值</h3><ul><li>通常来讲只有 ON/OFF 两个取值<br />但是由于历史问题，TRUE/FALSE 和 YES/NO 也可以表示 BOOL 类型<br /></li><li>但是推荐只使用 ON/OFF 避免混淆</li></ul><h3 id="if-的特点不需要加-会自动尝试作为变量名求值">if 的特点：不需要加${}, 会自动尝试作为变量名求值</h3><p>由于历史问题，if 的括号中有着特殊的语法，如果是一个字符串，比如MYVAR，则他会先看是否有 ${MYVAR}这个变量，如果有则被替换为变量的值来进行接下来的比较，否则保持原来的字符串不变。<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR Hello)<br><span class="hljs-keyword">if</span>(MYVAR <span class="hljs-keyword">MATCHES</span> Hello)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is Hello&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is not hello&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></p><h3 id="如果加上-也没区别">如果加上 ${} 也没区别</h3><p><code>if($&#123;MYVAR&#125; MATCHES "Hello")</code> 会展开成<code>if(Hello MACHES "Hello")</code><br />因为没有 Hello 变量所以被视为字符串正常进行匹配。</p><h3 id="万一定义了-hello-变量那就寄了">万一定义了 Hello变量那就寄了</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR Hello)<br><span class="hljs-keyword">set</span>(Hello world)<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$&#123;MYVAR&#125;</span> <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is Hello!&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is not Hello!&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p><code>if($&#123;MYVAR&#125; MATCHES "Hello")</code> 变成<code>if(Hello MATCHES "Hello")</code><br />if 认为用户要使用 Hello 变量，然后就出错了。<br />这里不要自作聪明加 ${} 就好了。</p><h3id="解决用引号包裹防止被当作变量名">解决：用引号包裹，防止被当作变量名</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR Hello)<br><span class="hljs-keyword">set</span>(Hello world)<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;$&#123;MYVAR&#125;&quot;</span> <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is Hello!&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is not Hello!&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>但是你不觉得麻烦吗？直接变量名就好了。<br /><strong>另外：CMake 仅仅是指令( set,message 这些)不分大小写，但变量名什么的是分大小写的！</strong></p><h2 id="第十章变量和作用域">第十章：变量和作用域</h2><h3 id="变量的传递规则父传子">变量的传递规则：父传子</h3><ul><li><p>父模块内容会传递给子模块</p></li><li><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">ON</span>)  <br><span class="hljs-keyword">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></li><li><p>m/CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is $&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li><li><p>Output<br />&gt;MYVAR is ON</p></li></ul><h3 id="变量传递规则子不传父">变量传递规则：子不传父</h3><ul><li><p>如果父模块本来就定义同名变量，则离开子模块后仍保持父模块原来设置的值。</p></li><li><p>CMakeLists.txt<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">OFF</span>)  <br><span class="hljs-keyword">add_subdirectory</span>(mylib)  <br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li><li><p>m/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">ON</span>)  <br></code></pre></td></tr></table></figure></li><li><p>Output</p><blockquote><p>MYVAR:OFF</p></blockquote></li></ul><h3id="若子模块想向父模块传递变量该怎么办">若子模块想向父模块传递变量该怎么办？</h3><ul><li><p>可以使用 set 的 PARENT_SCOPE选项把一个变量传递到上一层作用域</p></li><li><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">OFF</span>)  <br><span class="hljs-keyword">add_subdirectory</span>(mylib)  <br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li><li><p>m/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">ON</span> PARENT_SCOPE)  <br></code></pre></td></tr></table></figure></li><li><p>Output</p><blockquote><p>MYVAR:ON</p></blockquote></li><li><p>如果父模块没有定义 MYVAR，也可以使用缓存变量向外传递( 不建议,这样很不安全)，但是因为缓存变量是全局的，这样不仅父模块可见，父模块的父模块也可见。</p><ul><li><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-keyword">add_subdirectory</span>(mylib)  <br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li><li><p>m/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-keyword">ON</span> CACHE BOOL <span class="hljs-string">&quot;&quot;</span> FORCE)  <br></code></pre></td></tr></table></figure></li><li><p>Output</p><blockquote><p>MYVAR:ON</p></blockquote></li></ul></li></ul><h3id="除了父模块还有哪些是带有独立作用域的">除了父模块还有哪些是带有独立作用域的</h3><ul><li>include 的 XXX.cmake <strong>没有</strong>独立作用域<br /></li><li>add_subdirectory 的 CMakeLists.txt 有独立作用域<br /></li><li>macro<strong>没有</strong>独立作用域，插入执行，变量会暴露出来<br /></li><li>function <strong>有</strong>独立作用域，变量不会暴露出来<br /></li><li>因此 PARENT_SCORE 也可以用于 function 的返回值</li></ul><h3 id="环境变量的访问方式envxx">环境变量的访问方式：$ENV{xx}</h3><ul><li><p>用 ${xx}访问的是局部变量，局部变量服从刚刚说的父子模块传递规则。</p></li><li><p>而还有一种特殊的方式可以访问系统的环境变量( enviroment variable ): $ENV{xx}</p></li><li><p>比如 $ENV{PATH} 获取的就是 PATH 这个环境变量的值<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)  <br><span class="hljs-keyword">project</span>(helloCMake)<br><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;PATH:$ENV&#123;PATH&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li></ul><h3 id="缓存变量的访问方式cachexx">缓存变量的访问方式：$CACHE{xx}</h3><ul><li><p>还可以用 $CACHE{xx} 访问缓存变量<br />缓存变量和环境变量都是全局的，没有作用域一说</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)  <br><span class="hljs-keyword">project</span>(helloCMake)<br><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;CMAKE_BUILD_TYPE:$CACHE&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li></ul><h3 id="xx-找不到局部变量时会自动去找缓存变量">${xx}找不到局部变量时，会自动去找缓存变量</h3><ul><li><p>当 ${xx} 在局部变量找不到时，回去查询名为 xx 缓存变量</p></li><li><p>所以这里虽然没有定义 CMAKE_BUILD_TYPE，但是 ${}在缓存变量中找到了<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)  <br>projecr(helloCMake)<br><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;CMAKE_BUILD_TYPE:$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></p></li></ul><h3 id="ifdefined-xx-判断变量是否存在">if(DEFINED XX)判断变量是否存在</h3><p>if(DEFINED MYVAR) 可以判断是否定义了 MYVAR变量，判断的是<strong>局部变量</strong>和<strong>缓存变量</strong><br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br>projecr(helloCMake)<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">DEFINED</span> MYVAR)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR not defined&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></p><p>需要注意的是即便变量是空字符串也是被认为存在的，因为 DEFINED判断的是<em>是否被定义</em>。</p><h3 id="ifxx-就可以判断是否存在且不为空">if(xx)就可以判断是否存在且不为空</h3><p>可以直接用 if(xx) 来判断空字符串，因为空字符串等于 OFF<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br>projecr(helloCMake)<br><br><span class="hljs-keyword">set</span>(MYVAR <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span>(MYVAR)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is:$&#123;MYVAR&#125;&quot;</span>)<br><span class="hljs-keyword">else</span>()<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is empty or not defined&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></p><h3 id="ifdefined-envxx-判断环境变量是否存在">if(DEFINED ENV{xx})判断环境变量是否存在</h3><ul><li><p>因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx}来表示环境变量<br />因为 set 的第一参数和 if 的参数都是不加 $ 的，<br />所以要设置 ${x} 就变成了 set(x ...);<br />设置 $ENV{x} 就变成了 set( ENV{x} ...)<br />同理还可以用 if(DEFINED CACHE{x} ) 判断是否存在 缓存变量x<br />但是 set( CACHE{x} ...) 不行，别搞错了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)  <br><span class="hljs-keyword">project</span>(helloCMake)<br><br><span class="hljs-keyword">set</span>(ENV&#123;MYVAR&#125; <span class="hljs-string">&quot;hello&quot;</span>)  <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">DEFINED</span> ENV&#123;MYVAR&#125;)  <br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR:$ENV&#123;MYVAR&#125;&quot;</span>)  <br><span class="hljs-keyword">else</span>()  <br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;MYVAR is not defined!&quot;</span>)  <br><span class="hljs-keyword">endif</span>()  <br></code></pre></td></tr></table></figure></li></ul><h3 id="第十一章小建议">第十一章：小建议</h3><h3 id="ccache编译加速缓存">CCache：编译加速缓存</h3><ul><li><p>用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -omain 即可<br />在 CMake 中，可这样来启用 ccache ( 就是给每个编译和链接命令前面加上ccache )</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)  <br><span class="hljs-keyword">project</span>(helloCMake)<br><br><span class="hljs-keyword">find_program</span>(CCACHE_PROGRAM ccache)  <br><span class="hljs-keyword">if</span>(CCACHE_PROGRAM)  <br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Found CCache:$&#123;CCACHE_PROGRAM&#125;&quot;</span>)  <br><span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)  <br><span class="hljs-keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class="hljs-variable">$&#123;CCACHE_PROGRAM&#125;</span>)  <br><span class="hljs-keyword">endif</span>()  <br></code></pre></td></tr></table></figure></li><li><p>CCache 官网：https://ccache.dev/ ( 不过好像不支持 MSVC )</p></li></ul><h3 id="添加一个-run-伪目标用于启动主程序-可执行文件">添加一个 run伪目标，用于启动主程序( 可执行文件 )</h3><ul><li><p>创建一个 run 伪目标，其执行 main 的可执行文件<br />这里用了生成器表达式 <code>$&lt;TARGET_FILE:main&gt;</code> 会自动让 run依赖 main<br />如果自动依赖失败，可以手动加上 add_dependencies(run main)也是可以的。</p></li><li><p>这样就可以在命令行运行 cmake --build build --target run 来启动main.exe 运行了。而不必根据不同的平台，手动写出 build/main 或者build.exe<br /><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">add_custom_target</span>(run <span class="hljs-keyword">COMMAND</span> $&lt;TARGET_FILR:main&gt;)  <br></code></pre></td></tr></table></figure></p></li></ul><h3 id="再加一个-configure-伪目标用于可视化地修改缓存变量">再加一个configure 伪目标，用于可视化地修改缓存变量</h3><ul><li><p>这样就可以 cmake --build build --target configure 来启动 ccmake修改缓存了<br />Linux 上相当于 ccmake -B build，Windows 则是 cmake-gui -B build</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_target</span>(run <span class="hljs-keyword">COMMAND</span> $&lt;TARGET_FILE:main&gt;)  <br><span class="hljs-keyword">if</span>(CMAKE_EDIT_COMMAND)  <br><span class="hljs-keyword">add_custom_target</span>(configure <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_EDIT_COMMAND&#125;</span> -B <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)  <br><span class="hljs-keyword">endif</span>()  <br></code></pre></td></tr></table></figure></li></ul><h2 id="文件目录组织规范"><ahref="https://www.bilibili.com/video/BV1V84y117YU">文件目录组织规范</a></h2><p>基于CMake的项目组织。</p><h3 id="推荐的目录组织">推荐的目录组织</h3><ul><li>project_name/include/project_name/module_name.h<br /></li><li>project_name/src/module_name.cpp</li></ul><p>将头文件放在include/project_name目录下是防止<strong>不同子项目</strong>或<strong>项目</strong>与<strong>系统头文件</strong>相冲突。</p><p><strong>在CMakeLists.txt中</strong>使用</p><p><code>target_include_directories(project_name PUBLIC include)</code></p><p>指定项目名project_name, PUBLIC导入include文件</p><p><strong>源文件中</strong></p><ul><li>#include<project_name/module_name><br /></li><li>project_name::func();</li></ul><p><strong>头文件中(project_name/include/project_name/module_name.h)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">namespace</span> project_name&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现文件(projecr_name/src/module_name.cpp)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;project_name/module.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> project_name&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例子-1">例子</h4><ul><li>biology<ul><li>CMakeLists.txt<br /></li><li>include<ul><li>biology<ul><li>Animal.h<br /></li></ul></li></ul></li><li>src<ul><li>Animal.cpp<br /></li></ul></li></ul></li><li>CMakeList.txt<br /></li><li>pybmain<ul><li>CMakeLists.txt<br /></li><li>include<ul><li>pybmain<ul><li>myutils.h<br /></li></ul></li></ul></li><li>src<ul><li>main.cpp</li></ul></li></ul></li></ul><p>有点抽象……</p><p><img src="D:\Book\C++\MyC++Note\CMake.png" alt="CMake" style="zoom:67%;" /></p><h3 id="划分子项目">划分子项目</h3><p>一个大型的项目不可能是仅仅一个项目，往往是要分成多个子项目。</p><p>通常分为库文件，可执行文件两个部分，<strong>库文件</strong>主要负责逻辑运算、数据处理诸如此类的<strong>代码逻辑</strong>；<strong>可执行文件</strong>主要是和<strong>用户的交互逻辑</strong>。</p><h3 id="根项目的-cmakelists.txt-配置">根项目的 CMakeLists.txt 配置</h3><ul><li>在根项目的 CMakeLists.txt中，设置了该项目默认的构建模式，设置了统一的 C++版本等各种选项。然后通过 <code>project</code> 命令初始化了根项目。<br /></li><li>随后通过 <code>add_subdirectory</code> 把子项目添加进来(顺序无关紧要 )，这会调用子项目的 CMakeLists.txt 。<br />比如调用 biology/CMakeLists.txt 和 pybmain/CMakeLists.txt</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.18</span>)<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">project</span>(CppCMakeDemo LANGUAGES CXX)<br><br><span class="hljs-keyword">add_subdirectory</span>(pybmain)<br><span class="hljs-keyword">add_subdirectory</span>(biology)<br></code></pre></td></tr></table></figure><h1 id="我遇到的实际问题">我遇到的实际问题</h1><h2id="将资源拷贝到build目录供可执行文件读取">将资源拷贝到Build目录，供可执行文件读取</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_command</span>(<br><span class="hljs-keyword">TARGET</span> main POST_BUILD<br><span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br><span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/obj<br><span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/obj<br>)<br></code></pre></td></tr></table></figure><p><ahref="https://cmake.org/cmake/help/latest/command/add_custom_command.html?highlight=add_custom_command">CMake官方：add_custom_command</a><br /><ahref="https://discourse.cmake.org/t/post-copy-files-to-currently-building-target-directory/6027">Postcopy files to currently building target directory.</a>在这个问题中：“Forexample, if I’m building demo1 I want the output dir to be demo1s binarydir, if I’m building demo2, demo2’s binary diretc.”有点意思但是我没想到解决思路用<code>$&#123;PROJECT_SOURCE_DIR&#125;</code>和<code>$&#123;PROJECT_BINARY_DIR&#125;</code>不行吗？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>春招寄语</title>
    <link href="/2023/03/04/SpringBoss/"/>
    <url>/2023/03/04/SpringBoss/</url>
    
    <content type="html"><![CDATA[<p>图形学全忘光了，技美笔试直接寄了。<br />把面试题整理一下吧……<br />对于<strong>多线程</strong>和<strong>图形API</strong>了解不够需要继续学习</p><span id="more"></span><h1 id="c-部分">C++ 部分</h1><h2 id="new-和-malloc-区别"><ahref="https://www.cnblogs.com/ywliao/articles/8116622.html">new 和malloc 区别</a></h2><h3 id="申请内存所在位置">1.申请内存所在位置</h3><ul><li><p>new 从 free store 动态分配内存空间，free store 能否是堆取决于 new的实现其可以是堆，还可以是静态存储区。</p></li><li><p>malloc 从堆上分配内存</p></li></ul><h3 id="返回类型安全性">2.返回类型安全性</h3><ul><li><p>new 分配内存成功时，返回对象类型的指针，符合类型安全。</p></li><li><p>malloc 返回 void* ，需要强制类型转换。</p></li></ul><h3 id="内存分配失败时返回值">3.内存分配失败时返回值</h3><ul><li>new 失败返回 bac_alloc 异常，不会返回 NULL；<br /></li><li>malloc 失败返回 NULL；</li></ul><h3 id="是否需要指定内存大小">4.是否需要指定内存大小</h3><ul><li><p>new 无需指定，编译器自己计算</p></li><li><p>malloc 需要自己显示指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">A *ptr = (A*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(A));  <br></code></pre></td></tr></table></figure></li></ul><h3 id="是否调用构造函数析构函数">5.是否调用构造函数/析构函数</h3><ul><li>new 会经过三步分配内存<ul><li>调用 operator new (数组是 operator new[])，分配足够大、原始、未命名的空间。<br /></li><li>编译器运行对应构造函数，传入初值。<br /></li><li>构造完成，返回一个指向该对象的指针。<br /></li></ul></li><li>在 delete 会<ul><li>调用析构函数<br /></li><li>编译器调用 operator delete / operator delete[]</li></ul></li></ul><h3 id="对数组处理">6.对数组处理</h3><ul><li><p>C++ 有 new[] 和 delete [] 处理数组</p></li><li><p>而 malloc不知道你存放什么，只会给一块原始的内存，所以需要我们自己指定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 分配10个int，作为数组  </span><br></code></pre></td></tr></table></figure></li></ul><h3 id="new-和-malloc-是否可以相互调用">7. new 和 malloc是否可以相互调用</h3><p>new delete可以基于 malloc 实现，但是 malloc 不能调用 new！！！</p><h3 id="是否可以重载">8.是否可以重载</h3><ul><li>operator new / operator delete 可以重载<br /></li><li>malloc / free 不能重载</li></ul><h3 id="能够直观地重新分配内存">9.能够直观地重新分配内存</h3><p>malloc 分配的内存如果不够了可以 realloc</p><p>但是 new 不行！</p><h3 id="客户处理内存分配不同">10.客户处理内存分配不同</h3><p>operator new 抛出异常前会调用一个用户指定的错误处理函数new-handler，指向一个错误处理函数。</p><p>malloc 异常用户只能看着他 NULL</p><h2 id="类和接口">类和接口</h2><p>如果把类比作一把枪，接口就是枪的配件，比如握把，枪托等等。我们对于类重点在于描述一个对象，而对于接口重点在于描述接口能提供的功能，所以接口内没有数据成员，只有成员函数。</p><h2 id="c-类">C++ 类</h2><ul><li><p>子类和父类有同名成员数据，是通过"::"区分<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> num;  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> num;  <br>&#125;  <br></code></pre></td></tr></table></figure></p><p>其实这两个<code>num</code>实际的名字是<code>A::num</code>和<code>B::num</code></p></li><li><p>类的成员函数调用<br />非虚函数，根据调用对象类型决定，虚函数根据实际类型决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun1</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;T&quot;</span> &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> num;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">A</span>() &#123; num = <span class="hljs-number">2</span>; std::cout &lt;&lt; <span class="hljs-string">&quot;A::A &quot;</span> &lt;&lt; num++&lt;&lt;std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun1</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::Fun1 &quot;</span> &lt;&lt; ++num&lt;&lt; std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">()</span></span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun3</span><span class="hljs-params">()</span></span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~A() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> :<span class="hljs-keyword">public</span> A  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> num;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">B</span>() &#123; num = <span class="hljs-number">100</span>; std::cout &lt;&lt; <span class="hljs-string">&quot;B::B &quot;</span> &lt;&lt; num++ &lt;&lt; std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun1</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::Fun1 &quot;</span> &lt;&lt; ++num &lt;&lt; std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun2</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun3</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~B() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    A* ptr = <span class="hljs-keyword">new</span> B;  <br>    ptr = <span class="hljs-built_in">dynamic_cast</span>&lt;A*&gt;(ptr);  <br>    ptr-&gt;<span class="hljs-built_in">Fun1</span>();  <br>    ptr-&gt;<span class="hljs-built_in">Fun2</span>();  <br>    ptr-&gt;<span class="hljs-built_in">Fun3</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">A::A <span class="hljs-number">2</span>  <br>B::B <span class="hljs-number">100</span>  <br>B::Fun1 <span class="hljs-number">102</span>  <br>A::Fun2 <span class="hljs-number">2</span>  <br>A::Fun3 <span class="hljs-number">2</span>  <br>~<span class="hljs-built_in">B</span>() <span class="hljs-number">101</span>  <br>~<span class="hljs-built_in">A</span>() <span class="hljs-number">0</span>  <br></code></pre></td></tr></table></figure><p><code>A* ptr = new B;</code><br /><code>ptr</code>类型为<code>A*</code>，但是实际指向对象类型其实为<code>B</code><br />那么其实在内存空间中有如下分配</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less">成员数据:  <br><span class="hljs-selector-tag">n_ptr</span>  <br><span class="hljs-selector-tag">A</span>::<span class="hljs-selector-tag">num</span>  <br><span class="hljs-selector-tag">B</span>::<span class="hljs-selector-tag">num</span>  <br>一张<span class="hljs-selector-tag">A</span>的虚函数表？  <br>一张<span class="hljs-selector-tag">B</span>的虚函数表  <br>函数映射：  <br>直接查找的  <br><span class="hljs-selector-tag">A</span>::<span class="hljs-selector-tag">Fun2</span>  <br><span class="hljs-selector-tag">A</span>::<span class="hljs-selector-tag">Fun3</span>  <br><span class="hljs-selector-tag">B</span>::<span class="hljs-selector-tag">Fun1</span>  <br><span class="hljs-selector-tag">B</span>::<span class="hljs-selector-tag">Fun2</span>  <br></code></pre></td></tr></table></figure></li></ul><h2 id="构造函数链和析构函数链">构造函数链和析构函数链</h2><h3 id="构造函数链">构造函数链</h3><p>一个类中有父类成员，成员变量。对于构造函数我们</p><ol type="1"><li>先调用父类，<br /></li><li>再调用成员变量的构造函数，<br /></li><li>最后调用子类构造函数在构造过程中</li></ol><p>子类是继承父类的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-type">int</span> b;    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里B有成员b，和从父类继承的a。<br />因为 a是父类成员，所以交由父类初始化，如果先调子类，子类成员有a，b，对a，b初始化，再调父类，a又初始化初始化两次。<br />对于成员变量，成员变量有自己的构造函数，是当前子类无需关心的，对于他们先交给他们自己初始化即可。</p><h2 id="析构函数链">析构函数链</h2><p>对于析构函数链，我们把子类可以看成一个套娃。<br />我们装套娃会从小到大(从父到子)</p><h2id="c的publicprotectedprivate和三种继承">C++的public、protected、private和三种继承</h2><p>public 表示大家谁都能来访问，包括类对象自己和外部。<br />protected,外部不能访问，但是自己和子类可以访问。<br />private，表示只能自己访问，自己的子类都不能访问。<br />public 继承，不改变父类成员的可见性。<br />protected 继承，父类成员除private外，全部变为protect<br />private 继承全部变为private&gt;假如把父类比喻一个门派，期内对象就是武功秘籍<br />&gt;public 就像比较普通的武功，比如太祖长拳，大家都可以来学。<br />&gt;protect就像门派内的高深强大的武功秘籍，比如降龙十八掌，只有你是下一任掌门才能学。<br />&gt;private就像掌门自己偷学了邪门歪道，比如岳不群学《辟邪剑谱》，只能自己知道，外人不能晓得。除了自己谁也不让看。<br />&gt;<br />&gt;public继承就像是普普通通比较开明的继承者，子承父业，原来掌门规定的哪些武功可以交给外人，哪些武功自己人学，都不变，但是掌门私底下学的歪门武功他也不知道是什么，对他而言不可见，想知道是什么得返回去用上一任掌门的去查。<br />&gt;protect继承就像垄断或者有点小心思的人继承，我不让所有人随便学了，现在你们想从我这学你得是我的关门弟子下一任掌门。<br />&gt;private继承就像断代了，诶，我谁也不教，全部变成private，只有我自己看，但是无论这三种哪一种都看不到父类的private。</p><h2 id="static关键字">static关键字</h2><p>static关键字表示静态元素，其在程序的生存周期中仅在<strong>静态存储区</strong>分配一次存储空间，直到程序的生存周期结束。<br />static常用于</p><ul><li>函数中的静态变量<br /></li><li>静态类对象<br /></li><li>类中的静态成员变量<br /></li><li>类中的静态方法</li></ul><h2id="static-和const分别怎么用类里面static和const可以同时修饰成员函数吗"><strong>static和const分别怎么用，类里面static和const可以同时修饰成员函数吗</strong></h2><ul><li><p><strong>static</strong></p><ul><li><p>static对于变量</p><ol type="1"><li><p>局部变量</p><p>在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。</p><p>内存中的位置：静态存储区</p><p>初始化：局部的静态变量只能被初始化一次</p><p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p><blockquote><p>当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p></blockquote></li><li><p>全局变量</p><p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p><p>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p><p>初始化：未经初始化的全局静态变量会被程序自动初始化为0</p><p>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)</p><blockquote><p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</p></blockquote></li></ol></li></ul></li><li><p>static对于函数</p><p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。（和全局变量一样限制了作用域而已）</p></li><li><p>static对于类</p><ol type="1"><li><p>成员变量</p><p>用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，<strong>包括派生类的对象</strong>。</p><p>因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化。</p></li><li><p>成员函数</p><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，<strong>不含this指针。</strong></p><p>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</p><p><strong>不可以同时用const和static修饰成员函数。</strong></p></li></ol></li><li><p><strong>const</strong></p><ol type="1"><li>限定变量为不可修改。<br /></li><li>限定成员函数不可以修改任何数据成员</li></ol></li><li><p>static和const可以同时修饰成员函数吗?</p><p>答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数constthis*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。<strong>static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态</strong>，与类型的静态变量没有关系。因此不能同时用它们。</p></li></ul><h2 id="拷贝构造函数">拷贝构造函数</h2><p><strong>只有这三种情况！！！！！</strong></p><h3 id="用一个对象初始化另一个对象">1.用一个对象初始化另一个对象。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;  <br>Point p3 = p1  <br></code></pre></td></tr></table></figure><p>这两种情况一样。</p><h3id="若一个函数的形参是一个-class-对象当-f-被调用时class-拷贝构造函数调用">2.若一个函数的形参是一个Class 对象，当 F 被调用时，Class 拷贝构造函数调用。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(Point a)</span></span>&#123;&#125;;<br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    Point a;  <br>    <span class="hljs-built_in">Func</span>(a);    <span class="hljs-comment">// 调用拷贝构造函数  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h3id="如果函数的返回值是-class-对象函数返回时调用-class-拷贝构造函数">3.如果函数的返回值是Class 对象，函数返回时，调用 Class 拷贝构造函数</h3><p>即返回值对象由拷贝构造函数初始化。</p><h2 id="模板函数">模板函数</h2><h3id="模板函数的声明实现为什么必须在一个文件内">模板函数的声明实现为什么必须在一个文件内</h3><p><ahref="https://blog.csdn.net/chigusakawada/article/details/78752668">CSDN: 模板函数的声明和定义为何不能分开放在两个文件中?</a></p><h2 id="c-11-特性">C++ 11 特性</h2><h3 id="左值右值">左值右值</h3><p><ahref="https://www.cnblogs.com/qicosmos/p/4283455.html">四行代码！看懂右值引用</a></p><h4 id="右值引用的特点">右值引用的特点：</h4><ol type="1"><li><p>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">GetA</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>();  <br>&#125;  <br>A&amp;&amp; a = <span class="hljs-built_in">GetA</span>();<span class="hljs-comment">// 这里只会调用一次拷贝构造函数，就是return A()，  </span><br><span class="hljs-comment">// 因为A&amp;&amp; 延长了 GetA的生命周期无需拷贝函数  </span><br></code></pre></td></tr></table></figure></p></li><li><p>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。</p></li><li><p>T&amp;&amp;t在发生自动类型推断的时候，它是未定的引用类型（universalreferences），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。<br />正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。</p></li><li></li></ol><p>移动语义的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">GetA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;<br><br><span class="hljs-built_in">A</span>(A&amp;&amp; a):<span class="hljs-built_in">m_ptr</span>(a.m_ptr)&#123;&#125;<br><br>A a = <span class="hljs-built_in">GetA</span>();<br></code></pre></td></tr></table></figure><p>利用右值引用作为参数，因为<code>GetA</code>返回值是右值，而<code>A&amp;&amp;</code>类型确定不发生自动推断即确定的右值，拷贝函数会匹配到<code>A(A&amp;&amp; a)</code>，这样就省去了重新<code>new m_ptr</code>。</p><h5 id="引用折叠">引用折叠</h5><ul><li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；<br /></li><li>所有的其他引用类型之间的叠加都将变成左值引用。</li></ul><h4 id="一个移动语义应用">一个移动语义应用</h4><p>实现移动构造和移动赋值<br />为什么在 移动构造中将 f.ptr 赋值为 nullptr<br />因为我们的移动构造函数参数是一个右值，在完成初始化的任务后就应该消失，所以把他所指内存交给新对象，并指向了nullptr，移动赋值也是同理。<br />移动赋值和移动复制通常联合使用，目的是优化对象的复制和赋值操作，提高程序的性能。<br />移动赋值会在这时调用<code>f1=Foo()</code>，f1是之前声明过的，Foo()返回右值，匹配到<code>=(Foo&amp;&amp;)</code>函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> *ptr;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(Foo&amp;&amp; f):<span class="hljs-built_in">ptr</span>(f.ptr),<span class="hljs-built_in">a</span>(f.a)<br>    &#123;<br>        f.ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    Foo&amp; <span class="hljs-keyword">operator</span> =(Foo&amp;&amp; f)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;f)<br>        &#123;<br>            <span class="hljs-keyword">this</span>-&gt;ptr = f.ptr;<br>            f.ptr = <span class="hljs-literal">nullptr</span>;<br>            a = f.a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h3 id="一些补充">一些补充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Foo</span>());<br></code></pre></td></tr></table></figure><p>首先，我们知道函数的返回值是右值，所以Foo() 这部分是个右值<br />当我们没有右值引用的移动构造函数时，我们会发生右值转换的过程——把右值转化为左值，调用复制构造函数。<br />若我们有参数为右值引用的移动构造函数，右值会直接匹配到这个函数，不会发生一次转换去匹配参数为左值的复制构造函数。<br />这里的知识点是右值可以转换为左值。</p><h3 id="智能指针">智能指针</h3><h3 id="类型推断">类型推断</h3><h3 id="lambda表达式">lambda表达式</h3><h3 id="类型转换">类型转换</h3><p><ahref="https://zhuanlan.zhihu.com/p/417640759">九阳神功！不会C++就看这个！</a>（1）const_cast:把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；</p><p>（2）static_cast:隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；</p><p>（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用<strong>dynamic_cast父类一定要有虚函数，否则编译不通过；</strong></p><p>（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）</p><h2 id="c-struct和class区别">C++ struct和class区别</h2><ul><li><p>在 <strong>C 语言</strong> 中，<strong>结构体</strong>只能存放一些 <strong>变量</strong> 的集合，并不能有<strong>函数</strong>，但 <strong>C++</strong> 中的结构体对 C语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++中的类很类似。C++ 中的 struct可以包含成员函数，也能继承，也可以实现多态。</p></li><li><p>但在 C++ 中，使用 class 时，类中的成员默认都是<strong>private</strong> 属性的，而使用 struct时，结构体中的成员默认都是 public 属性的。</p></li><li><p>class 继承默认是 private 继承，而 struct 继承默认是 public继承。</p></li><li><p>C++ 中的 class 可以使用模板，而 struct 不能使用模板。</p></li></ul><h2 id="c-vector">C++ vector</h2><p>vector.clear 不释放空间</p><ul><li>int size() const:返回向量中元素的个数<br /></li><li>int capacity() const:返回当前向量所能容纳的最大元素值<br /></li><li>int max_size() const:返回最大可允许的vector元素个数值</li></ul><h2 id="c智能指针和安全性">C++智能指针和安全性</h2><p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr),独占指针(unique_ptr)和弱指针(weak_ptr)：</p><p>（1）shared_ptr，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p><p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p><p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><ul><li>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？</li></ul><p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p><p>（2）具体实现：</p><p>1）构造函数：将指针指向该对象，引用计数置为1；</p><p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p><p>3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p><p>（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。<ahref="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1654442">shared_ptr是线程安全的吗？- 云+社区 - 腾讯云 (tencent.com)</a></p><ul><li>weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用rawptr来解决这个问题？</li></ul><p>答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。</p><h2 id="shared_ptr实现原理">Shared_ptr实现原理</h2><h3 id="智能指针如何实现">智能指针如何实现</h3><p>C++中的智能指针（smart pointers）是一种RAII（Resource Acquisition IsInitialization）技术的实现方式，它们可以自动管理内存资源，并确保在对象离开作用域时正确地释放这些资源。智能指针的主要目的是确保资源获取与对象初始化同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p><p>C++11中引入了三种智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。其中<code>std::unique_ptr</code>是用于独占式拥有一个对象，<code>std::shared_ptr</code>是用于共享拥有一个对象，而<code>std::weak_ptr</code>则是用于弱引用一个对象。</p><p>当我们需要使用RAII技术来管理动态分配的内存时，我们通常使用<code>std::unique_ptr</code>来管理指向单个对象的指针，并使用<code>std::shared_ptr</code>来管理指向共享资源的指针。如果我们需要在一个对象中存储多个指向共享资源的指针，则应使用<code>std::weak_ptr</code>来避免循环引用问题。</p><p>总之，智能指针是一种非常有用的C++编程工具，可以帮助我们更安全、更简单地管理内存资源，并且对于编写高质量的C++代码来说至关重要。更多关于智能指针的资料可以参考[<ahref="https://zhuanlan.zhihu.com/p/150555165">3</a>][<ahref="https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170">4</a>]。</p><h2id="为什么析构函数一定要被设置为虚函数">为什么析构函数一定要被设置为虚函数</h2><p><ahref="https://www.cnblogs.com/yuanch2019/p/11625460.html">为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</a></p><p>首先类的<strong>虚函数</strong>调用是靠<strong>虚函数指针</strong>调用的，而函数成员靠的是对象类型。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func1</span>();<br>    a.<span class="hljs-built_in">func2</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对于<code>func1</code>是通过<code>a.this</code>调用，而<code>func2</code>是通过虚函数指针<code>a._vfptr-&gt;func2()</code>调用。(大概是这个意思，但应该是别的形式)</p><blockquote><p>“Note：定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。”—— 《C++ Primer》 中文第五版 P230</p><p>“成员函数通过一个名为<strong>this</strong>的额外隐式参数来访问调用它的那个对象。”—— 《C++ Primer》 中文第五版 P231</p></blockquote><p><strong>成员函数本质上可以看做全局函数，不过第一个参数固定为this。</strong></p><h3 id="菱形继承">菱形继承</h3><p>https://blog.csdn.net/tounaobun/article/details/8443228</p><p>问题：A-&gt;B;A-&gt;C;B,C-&gt;D; B,C继承了A，D继承了A。<br />在调用D的成员函数时候就不知道是调用B的，还是C的，所以在继承中使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Animal&quot;</span>; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lion</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Wolf, <span class="hljs-keyword">public</span> Lion<br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>加上virtual保证子类只有一个父类的子对象，防止发生二义性。</p><h2 id="c-深拷贝浅拷贝">C++ 深拷贝浅拷贝</h2><p>（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成<strong>野指针（悬浮指针）</strong>；</p><p>（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><h2 id="c野指针">C++野指针</h2><p>指针指向了一块非法内存区域(悬空或者说未知区域)。</p><h2 id="c-虚函数">C++ 虚函数</h2><h3 id="哪些函数不能是虚函数"><ahref="https://www.cnblogs.com/NeilZhang/p/5427872.html">哪些函数不能是虚函数</a></h3><p>常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。</p><h2 id="c-内存模型">C++ 内存模型</h2><h3 id="c内存布局">C++内存布局</h3><h4 id="heap-堆">Heap 堆</h4><p>由new分配的内存块，其释放编译器不去管，由我们<strong>程序自己控制（一个new对应一个delete）</strong>。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</p><h4 id="stack-栈">Stack 栈</h4><p><strong>编译器</strong>在需要时<strong>分配</strong>，在不需要时自动清除。存放<strong>局部变量</strong>和<strong>函数参数</strong>。<br />存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</p><h4 id="全局静态存储区.bss和.data段">全局/静态存储区(.bss和.data段)</h4><p>全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中称为zeroinitialization，初始化的放在.data段中，称为constinitialization；在C++中二者不进行区分。<br />虚函数表就存在这里，因为是全局公用的一张表，通过虚函数指针查找。</p><h4 id="常量存储区.rodata段">常量存储区(.rodata段)</h4><p>存放常量，不允许修改，比如<code>const int a = 3</code></p><h4 id="代码区.text段">代码区(.text段)</h4><p>存放代码，比如我们的函数和类的成员函数。不许修改但是可以执行。</p><h3 id="c内存区域">C++内存区域</h3><p>根据生命周期不同，C++中可划分出三种不同的内存区域</p><p>1.自由存储区、动态区、静态区局部非静态变量的存储区域(栈)<br />2.动态区：new，malloc分配的内存<br />3.静态区：全局变量，静态变量，字符串常量存在位置</p><p>https://www.cnblogs.com/yunlambert/p/9876491.html<br /><ahref="https://blog.csdn.net/JUST__Tw/article/details/118551674">深入理解计算机系统（内存管理）----内存模型</a><br />空类(空 class)大小是1，为了标识对象<br /><ahref="https://blog.csdn.net/li975242487/article/details/121395693">不同类型占用的字节</a></p><h2 id="c运算符重载">C++运算符重载</h2><p>https://www.cnblogs.com/liuchenxu123/p/12538623.html</p><h2 id="派生类的构造函数顺序">派生类的构造函数顺序</h2><p>https://www.nowcoder.com/questionTerminal/6348a321452a4318a2da5f3757baf620?source=relative</p><h2 id="迭代器">迭代器</h2><p>https://blog.csdn.net/QIANGWEIYUAN/article/details/89184546</p><h2 id="红黑树">红黑树</h2><p>https://blog.csdn.net/u014454538/article/details/120120216</p><h2 id="小根堆大根堆">小根堆，大根堆</h2><h3 id="完全二叉堆">完全二叉堆</h3><p>堆又可称之为完全二叉堆。这是一个逻辑上基于完全二叉树、物理上一般基于线性数据结构（如数组、向量、链表等）的一种数据结构。</p><h4 id="完全二叉树">完全二叉树</h4><p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h3 id="小根堆">小根堆</h3><p>根小于节点</p><h3 id="大根堆">大根堆</h3><p>根大于节点</p><h2 id="对象池">对象池</h2><p>对象池内通常是对象实例的指针，因为对象池的原理是将对象放入池管理的某种内存连续的数据结构中，当不需要对象时，并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。由于对象储存在内存连续的数据结构中，所以能够有效地解决内存碎片的问题。因此，对象池中保存对象的指针比直接保存对象实例更为高效，能够避免频繁分配和销毁内存，从而提高了程序的性能。</p><h2 id="多线程">多线程</h2><p><ahref="https://zhuanlan.zhihu.com/p/430069448">进程间通信方式；线程间通信方式</a></p><h3 id="进程间通讯的方式">进程间通讯的方式？</h3><p>管道通信，消息队列，共享内存，socket，串口都可以实现。</p><h4 id="管道-pipe">管道( pipe )：</h4><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><h4 id="有名管道-namedpipe">有名管道 (namedpipe) ：</h4><p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><h4 id="信号量semophore">信号量(semophore ) ：</h4><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h4 id="消息队列-messagequeue">消息队列( messagequeue ) ：</h4><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h4 id="信号-sinal">信号 (sinal ) ：</h4><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><h4 id="共享内存shared-memory">共享内存(shared memory ) ：</h4><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><h4 id="套接字socket">套接字(socket ) ：</h4><p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p><h3 id="线程间通讯方式">线程间通讯方式。</h3><p><strong>锁机制：包括互斥锁、条件变量、读写锁</strong></p><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br /></li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br /></li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul><p><strong>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</strong></p><p><strong>信号机制(Signal)：类似进程间的信号处理</strong></p><h1 id="图形学部分">图形学部分</h1><h2 id="叉乘">叉乘</h2><p>两个向量的叉乘结果是一个垂直于这两个向量的向量，最后这个向量的长度等于以最初两个向量作为边的平行四边形的面积。</p><h2 id="光照模型">光照模型</h2><ul><li>emissive<br /></li><li>specular<br /></li><li>diffuse<br /></li><li>ambient</li></ul><h3 id="环境光">环境光</h3><p>通常用系统定值，场景物体通用</p><p><img src="/imgs/SpringBoss/C_ambient.png"></p><h3 id="自发光">自发光</h3><p>材质决定</p><p><img src="/imgs/SpringBoss/C_emissive.png"></p><h3 id="漫反射">漫反射</h3><p>根据 Lambert‘s law</p><p><img src="/imgs/SpringBoss/C_diffuse.png"></p><h3 id="高光反射">高光反射</h3><p>我们有很多变量：normal，eyeDir，lightDir，refDir</p><h4 id="已知-normallightdir-求-refdir">已知 normal，lightDir 求refDir</h4><p><img src="/imgs/SpringBoss/NormalLightEyeRef.png"></p><p><img src="/imgs/SpringBoss/RefEqu.png"></p><h5 id="phong-模型">Phong 模型</h5><p><img src="/imgs/SpringBoss/PhongSpecular.png"></p><h5 id="blinn-phong">Blinn-Phong</h5><p><img src="/imgs/SpringBoss/BlinnPhong.png"></p><h2 id="复习下线性代数">复习下线性代数</h2><h3 id="坐标系">坐标系</h3><p>坐标系分为<em>左手坐标系</em>和<em>右手坐标系</em></p><p><img src="/imgs/SpringBoss/LeftRight.png" style="zoom:60%;" ></p><p>二者在 z 轴方向上有所不同。<br />在 Unity中<strong>模型空间</strong>和<strong>世界空间</strong>为左手系，<strong>观察空间</strong>为右手系。</p><h3 id="矩阵">矩阵</h3><p>矩阵又分为行矩阵和列矩阵。<br /><strong><em><u>矩阵的左乘/右乘，表示该矩阵在乘号的左侧/右侧。</u></em></strong></p><h4 id="行矩阵">行矩阵</h4><p><img src="/imgs/SpringBoss/rowMatrix.png" ></p><p>表示 1xn 的矩阵，行矩阵<strong>左乘</strong>，变换矩阵乘在右侧-&gt;<code>1xn dot nxn = 1xn</code></p><h5 id="齐次式">齐次式</h5><ul><li><p>矢量/点</p><p><img src="/imgs/SpringBoss/rowMatrixHC.png"></p></li><li><p>变换矩阵</p><p><img src="/imgs/SpringBoss/rowMatrixHCT.png" > #### 列矩阵</p></li></ul><p><u><strong><em>Unity就是列矩阵！</em></strong></u></p><blockquote><p>问题1<br />shader中会看到法线的变换矩阵：<br />float3x3 transform = float3x3(v.tangent.xyz, binormal, v.normal);<br />即，<strong>float3x3类型的变量</strong>在创建时，如果传入3个float3类型的变量。整个矩阵是按行优先填充还是按列优先填充呢？<br />答：填入的是三个列，即unityshader是<strong>列优先</strong>（column-major）的。<br />问题2<br /><strong>matrix</strong>.m12是什么意思？<br />答：m12是第一行第二列，但是构造矩阵时是<strong>按列的</strong>。</p></blockquote><p><img src="/imgs/SpringBoss/columnMatrix.png" ></p><p>表示 nx1 的矩阵，列矩阵<strong>右乘</strong>，变换矩阵乘在其左侧<code>nxn dot nx1 = nx1</code></p><h5 id="齐次式-1">齐次式</h5><ul><li><p>矢量/点</p><p><img src="/imgs/SpringBoss/colMHC.png"></p></li><li><p>变换矩阵</p></li></ul><p><img src="/imgs/SpringBoss/colMHCT.png"></p><h2 id="矩阵的几何意义变换">矩阵的几何意义变换</h2><p>变换优先级为：缩放&gt;旋转&gt;位移</p><h3 id="缩放">缩放</h3><p><img src="/imgs/SpringBoss/scale.png"></p><h3 id="旋转">旋转</h3><p>在<strong>左手系</strong>中，绕轴<strong>旋转遵从左手手旋转准则</strong>：大拇指为轴向，四指为旋转方向。<br />在<strong>右手系</strong>中，绕轴<strong>旋转遵从右手旋转准则</strong>：大拇指为轴向，四指为旋转方向。</p><ul><li>绕 x 轴</li></ul><p><img src="/imgs/SpringBoss/rotationX.png"></p><ul><li>绕 y 轴</li></ul><p><img src="/imgs/SpringBoss/rotationY.png"></p><ul><li>绕 z 轴</li></ul><p><img src="/imgs/SpringBoss/rotationZ.png"></p><h4 id="欧拉角旋转顺序">欧拉角旋转顺序</h4><p>因为不同轴旋转相乘得到变换矩阵不同。</p><ul><li>外旋和内旋<br />假定一组旋转顺序 x-&gt;y-&gt;z 为内旋，则外旋为 z-&gt;x-&gt;y。<br />一组对应的外旋内旋结果是一样的。</li></ul><p><strong>Unity旋转顺序是ZXY</strong>。</p><h3 id="位移">位移</h3><p><img src="/imgs/SpringBoss/translate.png"></p><h3 id="变换顺序">变换顺序</h3><p><img src="/imgs/SpringBoss/transform.png"></p><h2 id="给定-4x4-矩阵求缩放旋转平移矩阵"><ahref="https://blog.csdn.net/qq_39300235/article/details/105790743">给定4x4 矩阵，求缩放，旋转、平移矩阵</a></h2><p>就以列矩阵为例解吧，因为大多都是列矩阵运算。<br /><strong>M=TRS</strong></p><p><img src="/imgs/SpringBoss/4x4Matrix.png"></p><h3 id="t矩阵">T矩阵</h3><p>列矩阵最右侧就是 translate 变换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">T[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=M[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]/M[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];  <br>T[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=M[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]/M[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];  <br>T[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=M[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]/M[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];  <br></code></pre></td></tr></table></figure><h3 id="r矩阵">R矩阵</h3><p>之后我们对 M矩阵剔除平移变换，得到只有缩放和旋转的矩阵<em>M</em>。<br />此时 <em>M</em>=RS；<br />我们只要算出旋转矩阵就行了，因为 R可以用<strong>旋转矩阵的逆矩阵</strong>计算得到：</p><p><img src="/imgs/SpringBoss/4x4Rn.png"></p><p>接下来要分解出 R 矩阵，我们利用 ”Polardecomposition(极分解)“，可以证明矩阵<em>M</em>的极分解为 <u>旋转R</u> 和<u>缩放S</u> 。该方法通过对 <em>M</em>的逆的转置进行连续平均来计算，直到<strong>收敛</strong>，此时<em><strong>M</strong>i <strong>= R</strong></em>。</p><p><img src="/imgs/SpringBoss/Polar.png"></p><p>当矩阵只有旋转变换时，旋转R 的转置和R的逆相等，达到收敛状态。<br />因为旋转矩阵为<strong>正交矩阵</strong>。Shoemake和Duff（1992）讨论了该级数收敛的证明，所得矩阵是最接近M的正交矩阵，这是理想的特性。为了计算该序列，我们迭代应用公式，直到连续项之间的差很小或执行了固定的迭代次数为止。实际上，该系列通常会很快收敛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">Float norm;  <br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <br>Matrix4x4 R = M;  <br><span class="hljs-keyword">do</span>  <br>&#123;  <br>    Matrix4x4 Rnext;  <br>    Matrix4x4 Rit = <span class="hljs-built_in">Inverse</span>(<span class="hljs-built_in">Transpose</span>(R));    <span class="hljs-comment">// 转置的逆  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)  <br>    &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j)  <br>        &#123;  <br>            Rnext.m[i][j] = <span class="hljs-number">0.5f</span> * (R.m[i][j]+Rit.m[i][j]);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// compute the sub between Mi and Mi+1  </span><br>    norm = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)  <br>    &#123;  <br>        Float n = <span class="hljs-built_in">abs</span>(R.m[i][<span class="hljs-number">0</span>] - Rnext.m[i][<span class="hljs-number">0</span>]) +  <br>            <span class="hljs-built_in">abs</span>(R.m[i][<span class="hljs-number">1</span>] - Rnext.m[i][<span class="hljs-number">1</span>]) +  <br>            <span class="hljs-built_in">abs</span>(R.m[i][<span class="hljs-number">2</span>] - Rnext.m[i][<span class="hljs-number">2</span>]);  <br>        norm = <span class="hljs-built_in">max</span>(norm,n);  <br>    &#125;  <br>    R = Rnext;  <br>&#125;<span class="hljs-keyword">while</span>(++count &lt; <span class="hljs-number">100</span> &amp;&amp; norm &gt; <span class="hljs-number">0.0001</span>) <span class="hljs-comment">// 当迭代次数过多，或者连续项差距足够小，退出循环。  </span><br></code></pre></td></tr></table></figure><h3 id="s矩阵">S矩阵</h3><p>得到 R 矩阵后 S矩阵就很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">S = Matrix4x4::<span class="hljs-built_in">Mul</span>(<span class="hljs-built_in">Inverse</span>(R),M);  <br></code></pre></td></tr></table></figure><h3 id="另外一种办法">另外一种办法</h3><p>我们可以对3x3矩阵的每个列向量求长度，这样就知道每个坐标轴分量上的缩放，最终得到缩放矩阵，然后再根据缩放矩阵求旋转矩阵即可。</p><h2 id="mvp矩阵">MVP矩阵</h2><h3 id="model">Model</h3><p>把顶点坐标从局部空间变换到全局空间。</p><ul><li><p>行矩阵 <img src="/imgs/SpringBoss/ModelRow.png"></p></li><li><p>列矩阵 <img src="/imgs/SpringBoss/ModelCol.png"></p></li></ul><h3 id="view-matrix-推导">View-Matrix 推导</h3><p>在图形渲染中我们要把3D的场景渲染成一张2D的图片，而这张图片是从 Camera的视角出发，所以为了方便渲染我们做一个变换，把摄影机作为一个新的空间的原点，令摄影机观测方向为-z方向也就是我们常说的视图变换(Viewing Transform)。<br />我们对场景中的物体都进行这样一个变换就可以得到，观察空间下的物体的坐标信息，即以Camera 为原点，Camera 上方向为 y 轴，Camera 视线为 -z 轴，Camera 右侧为x轴的坐标空间下物体信息。<br /><strong>注意这里观察空间通常为右手系！而非和世界空间/模型空间所采用的左手系！</strong><br /><strong>接下来推导为列矩阵运算！</strong>这个变换主要分为两步一步是平移，一步是旋转。<br />设 Camera坐标为<img src="/imgs/SpringBoss/posE.png" style="zoom:50%;" ><br />则平移矩阵为<br /><img src="/imgs/SpringBoss/viewT.png" style="zoom:50%">现在我们把摄影机放到了原点位置，现在我们只需要把轴向调整即可。<br /><em>注意这里变换推导过程是先平移后旋转，和平时计算规定的 Transform 先scale 再 rotation最后 translate 的顺序不同。</em><br />我们假设 Camera up 方向矢量为 <em>t</em>，观察方向为 <em>g</em>，则其 x轴 <em>e</em> 为 <em>g</em>x<em>t</em>。<br /><img src="/imgs/SpringBoss/cameraETG.png" style="zoom:50%"><br />我们要让其轴向与 xyz轴对齐，因为现在只是把物体进行了移动，坐标信息的基础轴还是世界坐标系而非camera坐标系的三轴。<br />我们只需把<code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code> 其中<code>e = gxt</code>。<br />这样虽然可以进行计算，但是十分复杂。<br />我们观察到既然TEG是坐标轴，就意味着他们三者垂直，点积为零，可以构成正交矩阵。<br />那么 <code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code>的逆变换<code>y-&gt;t</code>,<code>-z -&gt;g</code>,<code>x-&gt;e</code>是很好计算的。<br />而我们知道了逆矩阵，就可以知道正交矩阵的原矩阵。<br />正交矩阵性质:<img src="/imgs/SpringBoss/orthM.png" style="zoom:80%"></p><p>所以 <img src="/imgs/SpringBoss/Rview.png" style="zoom:80%"></p><p>最后 <img src="/imgs/SpringBoss/Mview.png" style="zoom:80%"></p><h3 id="projection-matrix">Projection Matrix</h3><p>我们现在已经放好了物体，也以 Camera 的角度出发了，现在我们要从<strong>View space( 观察空间 )</strong> 到 <strong>Clip Space(裁剪空间/齐次裁剪空间 )</strong></p><h4id="我们这里先考虑把深度归到01的情况">我们这里先考虑把深度归到[0,1]的情况</h4><p>要把 <strong>View空间</strong>的点投影到<strong>屏幕</strong>上，利用相似三角形原理，<span class="math display">\[\begin{aligned}\frac{x_{screen}}{near}&amp;=\frac{x_{view}}{z_{view}}\\x_{screen}&amp;=\frac{x_{view}\cdot near}{z_{view}}\\y_{screen}&amp;=\frac{y_{view}\cdot near}{z_{view}}\\\end{aligned}\]</span> 但是实际上我们是先把 <em>X,Y</em> 坐标变换到[-1,1]后映射到Screen的，所以还得改成<br />将所有顶点映射到[-1,1]是为了方便 GPU 计算 <span class="math display">\[\begin{aligned}&amp;x_{screen}=\frac{x_{view}\cdot near}{z_{view}}&amp;\in[-wid,wid]\\&amp;y_{screen}=\frac{y_{view}\cdotnear}{z_{view}}&amp;\in[-height,height]\\&amp;x_{ndc}=\frac{x_{view}\cdot near}{z_{view}\cdot wid}&amp;\in[-1,1]\\&amp;y_{ndc}=\frac{y_{view}\cdot near}{z_{view}\cdot height}&amp;\in[-1,1]\\\end{aligned}\]</span> 所以我们现在知道如何对 x,y 坐标进行变换了，Project Matrix暂时可以写成这样， 因为 z,w 不受 x,y 影响 <span class="math display">\[\begin{bmatrix}\frac{near}{z_p\cdot wid}&amp;0&amp;0&amp;0\\0&amp;\frac{near}{z_p\cdot height}&amp;0&amp;0\\0&amp;0&amp;A&amp;B\\0&amp;0&amp;C&amp;D\\\end{bmatrix}\begin{bmatrix}x_p\\y_p\\z_p\\1\\\end{bmatrix}\]</span></p><p>而 z 值有些不一样，现在的问题是</p><ul><li>“我们的矩阵 <em>X,Y 坐标</em> 的变换矩阵和 <u>z值相关</u>”，<br />这肯定不是我们希望看到的，这不利于 GPU 计算，</li><li>而且为了实现深度测试我们还希望可以将深度值归化到[0,1]，</li></ul><p>对于<strong>第一个问题</strong>，既然 <em>X,Y 坐标</em> 都要除 ViewSpace 的 <em>Z</em> 坐标值，<br />那么我们不妨把这个除法操作在后面统一执行，也就是<strong>齐次除法</strong>，<br />所以我们需要在做这个除法操作时能得到 <em>Z</em>坐标值，而恰巧我们可以利用 <em>W 分量</em><br />我们可以先把 <em>Z</em> 坐标轴存在 W 分量，即 <spanclass="math display">\[\begin{bmatrix}\frac{near}{wid}&amp;0&amp;0&amp;0\\0&amp;\frac{near}{height}&amp;0&amp;0\\0&amp;0&amp;A&amp;B\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\]</span></p><p><u>因为View Space 是右手系的所以……z值不是正的</u></p><p><strong>第二个问题</strong>，而对于 <em>Z</em> 值 原本范围是 [-far,-near] -&gt; [?, ?] -&gt; [0,1] <span class="math display">\[[-far,-near]\rightarrow[?,?]\stackrel{/z}{\rightarrow}[0,1]\]</span> 所以我们对 -near 和 -far 两个边界条件列方程，因为是[0,1]在加上齐次除法所以near为0，far为far <spanclass="math display">\[\begin{aligned}    -A\cdot near+B=0\\    -A\cdot far+B=far\\    A=\frac{far}{near-far}\\    B=\frac{near\cdot far}{near-far}\end{aligned}\]</span></p><p>得到 <span class="math display">\[\begin{bmatrix}\frac{near}{wid}&amp;0&amp;0&amp;0\\0&amp;\frac{near}{height}&amp;0&amp;0\\0&amp;0&amp;\frac{far}{near-far}&amp;\frac{near\cdot far}{near-far}\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\]</span> 从裁剪空间到NDC需要一次齐次除法</p><h4 id="think-但可能不对">think 但可能不对</h4><p>齐次变换(仿射变换)的 W分量 对于一个点来说，可以表示变换的“距离",比如用矩阵平移 点(x,y,z) 距离(1,1,1)<br />如果把W=2，再W 归一得到的是(x/2+0.5, y/2+0.5, z/2+0.5),<br />如果有若干多个点，这样做，相当于一种投影，而投影点集前后，点集之间相对当前W 分量的点集关系不会改变，比如两个点之前相聚(a,b,c)， 除2后就是(a/2,b/2,c/2)<br />挺有意思但没啥用好像。</p><h2 id="tbn-矩阵">TBN 矩阵</h2><p><ahref="https://zhuanlan.zhihu.com/p/412555049">TBN矩阵不错的Blog</a></p><h2id="d平面三角形给出算法生成三角形内随机一点">2D平面三角形，给出算法，生成三角形内随机一点</h2><p>https://www.cnblogs.com/TenosDoIt/p/4025221.html</p><h2 id="前向渲染和延迟渲染">前向渲染和延迟渲染</h2><p>https://zhuanlan.zhihu.com/p/28489928</p><h2 id="lut-表">LUT 表</h2><p>https://www.jianshu.com/p/fdec2a5e889f</p><h2 id="描边效果">描边效果</h2><p>边缘检测</p><h2 id="为什么要有光线追踪">为什么要有光线追踪</h2><ol type="1"><li>传统光栅化做阴影效果不好，操作困难<br /></li><li>物体的模糊反射，比如毛玻璃一般的反射即 GlossyReflection，光线打到Glossy物体在反射<br /></li><li>间接光照(Indirect illumination)，光线在进入人眼前弹射不止一次</li></ol><p>这种光线弹射，对于光栅化来说想要实现比较麻烦，而且也不能保证物理上的正确性。光栅化本质上是一种快速的近似质量较低。<br />光线追踪是一种比较准确的办法质量很高，但是最大的问题就是很慢。</p><h2 id="包围盒bvh">包围盒BVH</h2><h3 id="如何划分bvh">如何划分BVH</h3><p>1.随机选取一个维度</p><p>2.选Bounding box中最长的轴进行进一步划分</p><p>3.选取中间的三角形处进行划分（以保证两边三角形数量接近）。</p><p>5.基于表面积的启发式评估划分方法（Surface AreaHeuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。</p><p>6.基于莫顿码（Morton code）的并行化BVH构建。</p><h4 id="参考学习记得学啊">参考学习！记得学啊！</h4><p><ahref="https://zhuanlan.zhihu.com/p/50720158">PBRT-E4.3-层次包围体(BVH)（一）- 玉米的文章 - 知乎</a><br /><ahref="https://zhuanlan.zhihu.com/p/54620381">PBRT-E4.3-层次包围体(BVH)（二）- 玉米的文章 - 知乎</a><br /><ahref="https://zhuanlan.zhihu.com/p/54694041">PBRT-E4.3-层次包围体(BVH)（三）- 玉米的文章 - 知乎</a><br /><ahref="https://www.cnblogs.com/silence394/p/17285231.html">【空间加速结构】——层次包围体BVH（BoundingVolume Hierachies） - silence394 - 博客园</a><br /><ahref="https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf">DynamicAABB Trees</a></p><h2 id="渲染管线">渲染管线</h2><p>一般就说说大概的流程IA-&gt;VS-&gt;Hull-&gt;TS-&gt;Domain-&gt;GS-&gt;OS-&gt;RS-&gt;PS-&gt;OM</p><h3 id="什么是曲面细分着色器">什么是曲面细分着色器</h3><p><ahref="https://www.cnblogs.com/chenglixue/p/17227713.html">大体介绍了一下曲面细分</a></p><h2 id="透明效果">透明效果</h2><h1 id="球谐函数">球谐函数</h1><h2 id="雾效">雾效</h2><h1 id="重要性采样">重要性采样</h1><h2 id="阴影">阴影</h2><p>LightMap</p><p>ShadowMapping</p><p>PCF</p><p>PCSS</p><p>VSSM</p><h3 id="csm如何做的">CSM如何做的？</h3><p>Cascaded ShadowMaps(CSM)方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。</p><h2 id="两个多边形如何判断相交">两个多边形如何判断相交</h2><p>https://blog.csdn.net/StevenKyleLee/article/details/88075814</p><h3 id="一点是否在多边形内">一点是否在多边形内</h3><p>https://blog.csdn.net/StevenKyleLee/article/details/88044589</p><p>一般用射线法这里说一下特殊情况：<br /><img src="/imgs/SpringBoss/RayPointSpe.png" style="zoom:100%;" ><br />这里的(b)因为中间那个顶点左右两条边都在该顶点的上侧，所以该顶点不识为于射线相交。<br />具体的判定过程应该可以根据多边形绕向找相邻点进行判断。</p><p><ahref="https://blog.csdn.net/WilliamSun0122/article/details/77994526">除射线法外的其他方法</a></p><h2 id="taatemporal-anti-aliasing">TAA(temporal anti-aliasing)</h2><p><a href="https://zhuanlan.zhihu.com/p/64993622">TAA in DX12</a><br /><a href="https://zhuanlan.zhihu.com/p/147567747">快速理解ToneMapping</a><br /><a href="http://www.ownself.org/blog/2011/tone-mapping.html">ToneMapping</a><br /><a href="https://www.cnblogs.com/crazii/p/7244300.html">TAA GHOSTING的相关问题</a><br />Tone Mapping是HDR算法的一部分，是用来将渲染出的场景亮度域映射到一个合理的亮度域空间。</p><blockquote><p>然后值得一提的是TAA在管线中的位置，虚幻的TAA是放在其它的后处理之前的，这么可以防止其它后处理出现的闪烁，但是因为高光很容易闪，我们又希望能在低动态范围处理，所以这里虚幻选择的是先tonemap，再算超采样，最后逆tonemap输出，去做其他的后处理。</p></blockquote><p>这里是说如果不做ToonMapping把HDR压倒LDR做TAA，因为HDR范围比LDR，然后TAA在混合在一起就会“亮的很花”，所以先ToonMapping到LDR做一下TAA在逆Toonmap输出，这样还得到了抗锯齿的输出，后处理做的更好了。这里的HDR和Toonmap我思考了很久，因为我没明白Toonmap，toonmap就是把hdr变成ldr，hdr虽然表示了更多的颜色，但是我们在屏幕空间显示还是0~1，所以要做映射，直接线性映射不行，因为人对暗部感知明显，而且自然界比LDR亮度大得多，所以我们做了很多调整。</p><h3 id="颜色ldr和hdr">颜色LDR和HDR</h3><p><a href="https://www.jianshu.com/p/fdec2a5e889f">LUT简述</a><br /><a href="https://zhuanlan.zhihu.com/p/80253409">HDR和ToneMapping</a></p><h3 id="几何走样和着色走样">几何走样和着色走样</h3><ul><li><strong>几何走样：</strong>几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在<strong>光栅化阶段</strong>。<br /></li><li><strong>着色走样：</strong>渲染方程的采样不足，因为<em>渲染方程也是连续函数</em>，对某些部分在<em>空间变化较快（高频部分）采样不足也会造成走样</em>，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在<strong>各种着色阶段</strong>。</li></ul><h2 id="z-fighting">Z-fighting</h2><h2 id="景深">景深</h2><p>所谓景深就是照片背景的虚化程度，规律是：光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰。<br /><ahref="http://www.ownself.org/blog/2010/jing-shen-depth-of-field.html">景深</a></p><h2 id="点到三角形距离">点到三角形距离</h2><p>https://zhuanlan.zhihu.com/p/148511581<br /><ahref="https://zhuanlan.zhihu.com/p/148511581">点到三角形面距离</a></p><h2 id="pbr">PBR</h2><p><ahref="https://blog.csdn.net/poem_qianmo/article/details/85239398">【基于物理的渲染（PBR）白皮书】（一）开篇：PBR核心知识体系总结与概览</a></p><h2 id="材质系统">材质系统</h2><p>材质系统了解、实现。</p><h1 id="计组部分">计组部分</h1><h3 id="大端和小端模式">大端和小端模式</h3><p>https://blog.csdn.net/wei_cheng18/article/details/79856207</p><ul><li><strong>大端</strong>（Big_endian）字数据的<strong>高字节</strong>存储在<strong>低地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>高地址</strong>中。<br /></li><li><strong>小端</strong>（Little_endian）字数据的<strong>高字节</strong>存储在<strong>高地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>低地址</strong>中。</li></ul><h3 id="cache-命中率">Cache 命中率</h3><h1 id="计网">计网</h1><h2 id="tcp">TCP</h2><h3 id="tcp三次握手"><ahref="https://blog.csdn.net/jun2016425/article/details/81506353">TCP三次握手</a></h3><ul><li>第一次握手：客户端向服务器发起链接请求<br /></li><li>第二次握手：服务器向客户端返回，发送答应客户端请求的确认信息。<br /></li><li>第三次握手：客户端向服务器，告诉服务器已经收到第二次握手的确认信息。</li></ul><h4id="tcp的三次握手过程为什么会采用三次握手若采用二次握手可以吗">TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h4><p>答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p><p>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</p><p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p><p>（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了</p><h3 id="四次挥手">四次挥手</h3><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，<strong>主动方：“我不会再给你数据了。”</strong><br /></li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1，<strong>被动方：“我知道了！”</strong><br /></li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，<strong>被动方：”我的数据也发送完了，不会再给你发数据了。“</strong><br /></li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，<strong>主动方：“行了，那我知道了，一切结束”</strong></li></ul><h1 id="编译原理">编译原理</h1><h2 id="逆波兰式"><ahref="https://blog.csdn.net/weixin_43919932/article/details/103327530">逆波兰式</a></h2><p>https://www.cnblogs.com/tangqs/archive/2012/05/18/2507708.html<br />如果是右单目运算符，直接入存储器栈；比如 阶乘！与百分号%</p><h1 id="os">OS</h1><h2 id="进程和线程">进程和线程</h2><p><ahref="https://blog.csdn.net/ThinkWon/article/details/102021274">进程和线程</a><br /><ahref="https://blog.csdn.net/qq_33182418/article/details/121135914">线程调度</a><br /><ahref="https://blog.csdn.net/qq_41784433/article/details/122194695">进程/作业调度</a></p><h3 id="多线程比单线程慢">多线程比单线程慢</h3><p>存在上下文切换和死锁问题。<br />https://www.cnblogs.com/xrq730/p/5186609.html</p><h2 id="linux-进程通讯">Linux 进程通讯</h2><p>https://blog.csdn.net/qq_44443986/article/details/115065540</p><h2 id="死锁和银行家算法">死锁和银行家算法</h2><p>https://blog.csdn.net/wyf2017/article/details/80068608</p><h2id="什么是内存碎片内存碎片是在虚拟内存还是物理内存">什么是内存碎片，内存碎片是在虚拟内存还是物理内存？</h2><p>采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。</p><h1 id="概率论">概率论</h1><h2 id="期望计算和带保底卡池期望计算">期望计算和带保底卡池期望计算</h2><h1 id="算法">算法</h1><h2 id="lru手撸">LRU手撸</h2><p>https://leetcode.cn/problems/lru-cache-lcci/</p><p>LRU算法还有进化版LFU算法</p><h2 id="双端队列">双端队列</h2><p>一个能用队列和栈实现的增删查改都是O(1)的数据结构，是什么<br />这个能用队列和栈实现的增删查改都是O(1)的数据结构是双端队列（deque）[<ahref="https://zh.wikipedia.org/wiki/队列#双端队列">1</a>]。双端队列不仅支持在队列的一端进行入队和出队操作，也支持在队列的另一端进行插入和删除操作。因此，在使用双端队列时，可以根据具体的需求选择在队列的哪一端进行操作，从而实现了增删查改都是O(1)的效率。</p><h3 id="双端队列定义">双端队列定义</h3><p>能在队列两端进行入队、出队操作。</p><h2 id="统计子树中城市之间最大距离">统计子树中城市之间最大距离</h2><p>https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/submissions/412418189/</p><h2 id="a算法">A*算法</h2><p>https://zhuanlan.zhihu.com/p/54510444</p><h2 id="岛屿问题">岛屿问题</h2><p>https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/</p><h2 id="top-k-问题">Top K 问题</h2><p>https://zhuanlan.zhihu.com/p/64627590</p><h1 id="c-和-unity">C# 和 Unity</h1><p><ahref="https://blog.csdn.net/qq_21407523/article/details/108814300">CSDN不错的面试总结-2022年Unity面试题分享| 全面总结 | 建议收藏</a><br /><ahref="https://zhuanlan.zhihu.com/p/554529423">知乎上五尘的Unity面试题</a></p><h2 id="协程">协程</h2><p><ahref="https://blog.csdn.net/w2009211777/article/details/125514898">总结：协程与线程</a></p><h2id="请简述gc垃圾回收产生的原因并描述如何避免">请简述GC（垃圾回收）产生的原因，并描述如何避免？</h2><p>GC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder</p><h2 id="c指针和c的引用">C++指针和C#的引用</h2><p><ahref="https://zhuanlan.zhihu.com/p/389422617">c++引用和c#引用类型的区别</a></p><h2 id="反射">反射</h2><p><ahref="https://www.cnblogs.com/wangshenhe/p/3256657.html">[整理]C#反射(Reflection)详解</a><br /><ahref="https://www.cnblogs.com/shahdza/p/12261831.html">【Unity|C#】基础篇(12)——反射（Reflection）（核心类：Type、Assembly）</a></p><ul><li><p>反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。</p></li><li><p>.NET的应用程序由几个部分：<strong>程序集（Assembly）、模块（Module）、类型（class）组成</strong>。</p></li></ul><h2 id="工厂模式">工厂模式</h2><p>https://wittykyrie.github.io/posts/Factor-Pattern/<br /><ahref="https://blog.csdn.net/cxy_zxl/article/details/116695023">简单工厂模式、工厂方法模式优缺点</a><br /><a href="https://zhuanlan.zhihu.com/p/83535678">C++深入浅出工厂模式（初识篇）</a></p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>https://blog.csdn.net/m0_46502538/article/details/120343296</p><h2 id="ugui-如何实现ui物体淡入淡出">UGUI 如何实现UI物体淡入淡出?</h2><ul><li>Text，Image这些组件都有继承Graphic类，这个类提供了CrossFadeAlpha()方法，可以做透明度渐变。<br /></li><li>但如果界面东西多了，要获取每个Graphic是挺麻烦了。其实还有一个很简便的方法，用起来跟NGUI差不多。就是CanvasGruop组件，把这个组件放到界面根节点上，对这个组件的alpha做改变就行了。看看官方文档的解释，</li></ul><h2 id="esc-框架">ESC 框架</h2><p>https://blog.codingnow.com/2017/06/overwatch_ecs.html</p><p>ECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object。但是是 C 的整合其实。</p><p>C 和 S 是这个框架的核心。System系统，也就是我上面提到的模块。每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。</p><p>每个可能单独使用的对象属性归纳为一个个 Component，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component。</p><h2 id="unity的委托是什么-event-关键字有什么用">unity的委托是什么? event关键字有什么用？</h2><p>委托是一个容器，可以放函数对象，并且可以触发委托面的每个函数调用。委托主要用户回调函数。如果在外部给委托变量加函数进来，那么委托要定义成public,这样做又有一个问题，public外部的人也可以触发这个委托，如果我希望设计成外部可以加回调，但是只能是模块内部触发委托，那么我可以加一个event来修饰，这样虽然是public,但是外部无法触发委托,只能类的内部触发。</p><h1 id="dx12">DX12</h1><p>DX12和</p><h1 id="vulkan">Vulkan</h1><p><ahref="https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-tutorial-index.html">vulkan教程</a></p><h2id="vulkan和dx12相比opengl好在哪里">Vulkan和DX12相比OpenGL好在哪里？</h2><h1 id="unity">Unity</h1><p><a href="https://zhuanlan.zhihu.com/p/585164814">unity 八股文实时更新</a></p><h2 id="unityupdate">UnityUpdate</h2><p><img src="/imgs/SpringBoss/unityUpdate.jpg"></p><h2 id="unity-ugui不规则区域点击问题">Unity UGUI不规则区域点击问题</h2><p>https://www.cnblogs.com/msxh/p/9283266.html</p><h2id="当一个细小的高速物体撞向另一个较大的物体时会出现什么情况如何避免">当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？</h2><p>碰撞检测失败，会直接穿透</p><p>避免方法：<br />（1）增大细小物体的碰撞体（不建议这样做）<br />（2）使用射线检测，检测他们之间的距离<br />（3）FixedUpdate频率修改，可以physics time减小（同样不建议）<br />（4）改变物体的速度（废话）<br />（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode=CollisionDetectionMode.Continuous;<br />或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）<br />（6）代码限制，加大计算量 提前计算好下一个位置</p><h2 id="canvas-有几种模式如何配置"><ahref="https://blog.csdn.net/weixin_42352178/article/details/109034679">Canvas有几种模式，如何配置？</a></h2><p>Canvas的三种渲染模式：</p><ul><li>ScreenSpace-Overlay（屏幕空间-覆盖模式）UI元素的位置坐标是屏幕空间的坐标，Overlay模式下画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。<br /></li><li>ScreenSpace-Camera（屏幕空间-摄影机模式）UI元素的位置坐标是屏幕空间的坐标，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br />此时，画布上的UI组件会随视角移动。<br /></li><li>WorldSpace即世界空间模式，此模式下UI元素的位置坐标是世界空间的坐标。画布作为场景中的一部分被固定显示在场景中，显示效果类似Plane组件。</li></ul><h2 id="unity-渲染队列">Unity 渲染队列</h2><table><thead><tr><th>Name</th><th>ID</th><th>Description</th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>会在任何其他队列前渲染，渲染需要绘制在背景上的物体</td></tr><tr><td>Geometry</td><td>2000</td><td>默认的渲染队列，大部分物体都使用这个队列，不透明物体一般使用这个队列</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要进行透明测试的物体</td></tr><tr><td>Transparent</td><td>3000</td><td>在 Geometry 和 AlphaTest后，<strong>从后向前</strong>地渲染，任何使用透明混合的物体都使用此队列</td></tr><tr><td>Overlay</td><td>4000</td><td>该队列用于实现叠加效果，任何需要最后渲染的物体都使用此队列。</td></tr></tbody></table><h2 id="游戏动画">游戏动画</h2><h3 id="关节动画">关节动画</h3><h3 id="单一网格动画">单一网格动画</h3><h3 id="骨骼动画">骨骼动画</h3><h2 id="unity中ugui如何打包成图集">unity中UGUI如何打包成图集?</h2><p><ahref="https://www.zhihu.com/question/472146051/answer/2011067756">unity中UGUI如何打包成图集?- 鲨鱼辣椒的回答 - 知乎</a></p><ul><li>开启UGUI的图集模式, Editor-&gt;Project Settings 下面有spritepacker的模式。<br /></li><li>为每个UI图片制定要打入的图集的tag名字。<br /></li><li>打包生成图集Window ------&gt;Sprite Packer,点击Pack即可打包生成图集。</li></ul><h2 id="build-in-rp和srp">Build-IN RP和SRP</h2><p><ahref="https://blog.csdn.net/weixin_41622043/article/details/107623694">UnitySRP URP HDRP 的区别</a></p><h2 id="srp">SRP</h2><p><a href="https://unity.com/cn/srp">Unity官方宣传</a></p><h3 id="srp-batcher">SRP Batcher</h3><p><ahref="https://blog.unity.com/cn/technology/srp-batcher-speed-up-your-rendering">SPRBatcher 官方简介</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>包围盒与物体碰撞(学习中)</title>
    <link href="/2023/02/27/%E5%8C%85%E5%9B%B4%E7%9B%92%E4%B8%8E%E7%89%A9%E4%BD%93%E7%A2%B0%E6%92%9E/"/>
    <url>/2023/02/27/%E5%8C%85%E5%9B%B4%E7%9B%92%E4%B8%8E%E7%89%A9%E4%BD%93%E7%A2%B0%E6%92%9E/</url>
    
    <content type="html"><![CDATA[<p>学海无涯，学！<br />从来没系统地了解过包围盒和碰撞问题<br />学习总结一下吧。</p><span id="more"></span><h1 id="包围盒与物体碰撞">包围盒与物体碰撞</h1><h2 id="什么是包围盒">什么是包围盒</h2><p>包围盒是一个简单的集合体，盒内包含着复杂的物体。为物体添加包围盒是为了<strong>进行快速的碰撞检测</strong>或者<strong>在<u>更为精确的碰撞检测前</u>进行过滤</strong>。包围盒一般有几种类型，如<strong>球体</strong>、<strong>轴对齐包围盒(AABB——Axis-AlignedBounding Box)</strong>、<strong>有向包围盒(OBB——Oriented BoundingBoxes)</strong>、<strong>8-DOP</strong>以及<strong>凸壳</strong>。<br />包围盒经常被用于<em>碰撞检测</em>，比如射击、点击、相撞等；每一个物体都有自己的包围盒，因为包围盒一般都是规则物体，因此用其来代替物体本身进行计算，比直接用物体本体计算更加高效简单。</p><p><img src="/imgs/包围盒与物体碰撞/AABB&OBB.jfif" alt="不同的包围盒"></p><p>目前最常见的为AABB和OBB两种包围盒，其中AABB因为简单的生成方式更加常见，但是<strong>AABB包围盒是与坐标轴平行对齐的，故而不会随着物体旋转</strong>。从上图可以看出AABB包围盒比OOBB包围盒多了很多空隙，<strong>对精确度有点要求的碰撞检测的效果不好</strong>。这时候就需要OBB包围盒，<strong>OBB包围盒始终沿着物体的主成分方向生成一个最小的矩形包围盒，可以随物体旋转，适用于较精确的碰撞检测</strong>。</p><h2 id="参考资料">参考资料</h2><p><ahref="https://blog.csdn.net/qing101hua/article/details/53100112">如何生成OBB(Oriented Bounding Box) 协方差矩阵</a><br /><ahref="https://blog.csdn.net/yorhomwang/article/details/54869018">碰撞检测之分离轴定理算法讲解_分离轴定理</a><br /><ahref="https://visualgmq.gitee.io/2019/08/10/OBB%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/">OBB包围盒的碰撞检测(SAT算法)</a><br /><ahref="https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169">CollisionDetection Using the Separating Axis Theorem</a><br /><ahref="https://blog.csdn.net/silangquan/article/details/50812425">碰撞检测之OBB-OBB检测</a><br /><ahref="https://blog.csdn.net/weixin_43022263/article/details/108550538">碰撞检测之AABB 包围盒 aabb包围盒</a><br /><ahref="https://blog.csdn.net/baidu_38621657/article/details/113788440">AABB包围盒和OBB包围盒区别_哈市雪花的博客-CSDN博客_aabbobb</a><br /><ahref="https://www.cnblogs.com/lyggqm/p/5386174.html">[算法][包围盒]球，AABB，OBB- 南水之源 - 博客园</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法学习总结</title>
    <link href="/2023/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>几天前发现自己排序算法忘光了，就从网上抄了一份，自己按照思路，C++简单敲了一遍，方便自己后续复习，下面标题放了抄袭对象。</p><span id="more"></span><h1 id="排序算法"><ahref="https://www.cnblogs.com/onepixel/articles/7674659.html">排序算法</a></h1><h2 id="排序算法分类">排序算法分类</h2><ul><li><p><strong>比较类排序</strong><br />通过比较数据大小来进行排序，决定相对次序，所以其时间复杂度无法突破<code>O(nlogn)</code>，<br />因此也称为<strong>非线性时间比较类排序</strong>。</p></li><li><p><strong>非比较类排序</strong><br />不通过比较来决定元素的相对次序，可以突破基于比较排序的时间下限，<br />因此也被称为<strong>线性时间非比较类排序</strong>。</p></li><li><p>比较排序</p><ul><li>交换排序<ul><li>冒泡排序<br /></li><li>快速排序<br /></li></ul></li><li>插入排序<ul><li>简单插入排序<br /></li><li>希尔排序<br /></li></ul></li><li>选择排序<ul><li>简单选择排序<br /></li><li>堆排序<br /></li></ul></li><li>归并排序<ul><li>二路归并排序<br /></li><li>多路归并排序</li></ul></li></ul></li><li><p>非比较排序</p><ul><li>计数排序<br /></li><li>桶排序<br /></li><li>基数排序</li></ul></li></ul><h2 id="算法复杂度">算法复杂度</h2><table><thead><tr><th>排序方法</th><th>时间复杂度(Average)</th><th>时间复杂度(Worst)</th><th>时间复杂度(Best)</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr><td>希尔排序</td><td><span class="math inline">\(O(n^{1.3})\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr><td>选择排序</td><td><span class="math inline">\(O({n}^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr><td>堆排序</td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr><td>冒泡排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr><td>快速排序</td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n \log_{2}{n})\)</span></td><td>不稳定</td></tr><tr><td>归并排序</td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n\log_{2}{n})\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td>稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计数排序</td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr><tr><td>桶排序</td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr><tr><td>基数排序</td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n*k)\)</span></td><td><span class="math inline">\(O(n*k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr></tbody></table><h2 id="暴力排序">0.暴力排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vecCout</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worstSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; num)<br>    &#123;<br>        <span class="hljs-comment">//cin &gt;&gt; c;</span><br>        nums.<span class="hljs-built_in">emplace_back</span>(num);<br>        <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">get</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">worstSort</span>(nums);<br>    <span class="hljs-built_in">vecCout</span>(nums);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序">1.冒泡排序</h2><p>重复地遍历要排序的元素，每次比较两个元素，如果顺序错误，二者进行交换。<br />重复的进行直到没有交换为止，即排序完成，因为 top/last元素会慢慢浮现到数组两端所以得名冒泡排序。</p><h3 id="算法描述">算法描述</h3><ul><li>比较相邻元素，不符合比较顺序则交换。<br /></li><li>对每一对相邻元素作一样的操作，从第一对到最后一对这样最大的元素就会在末尾<br /></li><li>针对所有的元素作上述操作，除了最后一个<br /></li><li>重复1-3步骤，直到排序完成</li></ul><h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[j], nums[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序">2.选择排序</h2><p>Selection Sort 是一种简单直观的排序算法。<br />他的工作原理是：现在序列中找到最小(大)元素，放在起始位置，再从未排序元素中寻找最小(大)元素，放在以排列元素的末尾。重复操作，指导排序完毕。</p><h3 id="算法描述-1">算法描述</h3><p>n 个元素可以经过 n-1 次选择排列完毕：</p><ul><li>初始状态，未排序区R[1……n]，有序区为空。<br /></li><li>第 i 次排序，当前有序区 R[1……i-1]，无序区[i……n]，这次从无序区选出最小的元素R[k]，将其与无序区第一个元素互换，使R[1……i]，[i+1……n]为新区<br /></li><li>第 n-1 次选择结束，数组有序了</li></ul><h3 id="代码实现-1">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> minIndex;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i)<br>    &#123;<br>minIndex = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &lt; nums[minIndex])<br>            &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[i],nums[minIndex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析"><strong>算法分析</strong></h3><p>表现最稳定的算法，无论什么数据都花费 <spanclass="math inline">\(O(n^2)\)</span>的时间复杂度，所以数据规模越小越好，好处是<strong>不占用额外空间</strong>。</p><h4 id="为什么不稳定">为什么不稳定</h4><p>例如：4a, 4b, 4c, 1<br />选择排序后会变成 1, 4b, 4c, 4a</p><h2 id="插入排序-insertion-sort">3.插入排序 ( Insertion Sort )</h2><p>构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="算法描述-2">算法描述</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序<br /></li><li>取出下一个元素，在已排序的元素中由后至前地扫描<br /></li><li>若该排序后元素大于取出的新元素，则将该排序元素移到下一位。<br /></li><li>重复步骤3，直到找到新元素大于或等于已排序的元素<br /></li><li>将新元素插入该位置<br /></li><li>重复2-5步骤</li></ul><h3 id="代码实现-2">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> preIndex, currentNum;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        preIndex = i - <span class="hljs-number">1</span>;<br>        currentNum = nums[i];<br>        <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[preIndex] &gt; currentNum)<br>        &#123;<span class="hljs-comment">// 当pre比选中对象大，将pre值赋给pre+1，</span><br>            <span class="hljs-comment">//这样循环下去，pre一个一个赋值到后一个，current就来到了正确的位置</span><br>            nums[preIndex+<span class="hljs-number">1</span>] = nums[preIndex];<br>            --preIndex;<br>        &#125;<br>        nums[preIndex+<span class="hljs-number">1</span>] = currentNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析-1">算法分析</h3><p>插入排序往往是在原地进行修改，所以在遍历过程中，需要不断把已排序的元素逐步向后挪位，为新元素提供插入位置。</p><h2 id="希尔排序shell-sort">4.希尔排序(Shell Sort)</h2><p>由 Shell 发明突破 $O(n^2) $的排序算法，在原本的插入排序进行改良，优先比较较远位置的元素，故而 shellsort 又叫<strong>缩小增量排序</strong>。</p><h3 id="算法描述-3">算法描述</h3><p>将整个数组分割为若干子序列，分别进行插入排序：</p><ul><li><p>选择一个增量序列，t1, t2, ..., tk, 其中 ti &gt; tj, tk = 1;<br /></p></li><li><p>按增量序列个数 k，对序列进行 k 次排序<br /></p></li><li><p>每次排序，根据对应的增量ti，将待排序序列分割成若干长度为 m的子序列，下标为i*ti的为一组，分别对各子序列进行插入排序。仅在增量因子为1 时，将整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li><li><p>分组增量为4，则下标[0,4,8]一组，[1,5,9]一组</p></li></ul><h3 id="代码实现-3">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-comment">// insertion sort</span><br>        <span class="hljs-comment">// 在n/gap组中，进行insertion sort</span><br><span class="hljs-comment">// insertion sort，就是从0,gap,gap*2...这样遍历，这些是一组数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = gap; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = nums[i];<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span>(j = i; j &gt;= gap &amp;&amp; nums[j-gap] &gt; tmp; j -= gap)<br>            &#123;<br>                nums[j] = nums[j - gap];<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析-2">算法分析</h3><p>Shell Sort 理解还是较为容易，要将 insertion sort怎么进行痛彻的理解就明白 shell sort 的工作原理了，算法的快慢重点在 gap的选择，可以预先指定也可以动态生成，但最后一个 gap 一定是1。</p><h2 id="归并排序merge-sort">5.归并排序(Merge Sort)</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法(Divide and Conquer)的经典应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并为一个有序表，则称为2-路归并。</p><h3 id="算法描述-4">算法描述</h3><ul><li>把长度为 n 的序列，二分两个子序列<br /></li><li>把子序列分别使用归并排序<br /></li><li>将排好的子序列合并成一个最终的排序序列</li></ul><h3 id="代码实现-4">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> <span class="hljs-type">const</span> left, <span class="hljs-type">int</span> <span class="hljs-type">const</span> mid, <span class="hljs-type">int</span> <span class="hljs-type">const</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> subNumsLeft = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> subNumsRight = right - mid;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; leftNums = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(subNumsLeft);<br>    vector&lt;<span class="hljs-type">int</span>&gt; rightNums = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(subNumsRight);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; subNumsLeft; ++i)<br>    &#123;<br>        leftNums[i] = nums[left + i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; subNumsRight; ++j)<br>    &#123;<br>        rightNums[j] = nums[mid + <span class="hljs-number">1</span> + j];<br>    &#125;<br><br>    <span class="hljs-type">int</span> leftPos = <span class="hljs-number">0</span>, rightPos = <span class="hljs-number">0</span>, numsPos = left;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt; subNumsLeft &amp;&amp; rightPos &lt; subNumsRight)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (leftNums[leftPos] &lt;= rightNums[rightPos])<br>        &#123;<br>            nums[numsPos] = leftNums[leftPos];<br>            ++leftPos;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            nums[numsPos] = rightNums[rightPos];<br>            ++rightPos;<br>        &#125;<br>        ++numsPos;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (leftPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = leftNums[leftPos];<br>        ++numsPos;<br>        ++leftPos;<br>    &#125;<br><br><br>    <span class="hljs-keyword">while</span> (rightPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = rightNums[rightPos];<br>        ++numsPos;<br>        ++rightPos;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> <span class="hljs-type">const</span> begin, <span class="hljs-type">int</span> <span class="hljs-type">const</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (begin &gt;= end)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = begin + (end - begin) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// Dont think it, just recursion.</span><br>    <span class="hljs-built_in">mergeSort</span>(nums, begin, mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-built_in">merge</span>(nums, begin, mid, end);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析-3">算法分析</h3><p>归并排序是一种稳定的排序方式，性能不受数据大小影响，时间都是 <spanclass="math inline">\(O(nlogn)\)</span> ，但是需要额外空间。</p><h2 id="快速排序">6.快速排序</h2><p>基本思想：再一次遍历中，将待排序数据分为两部分，其中一部分比选定关键字小，另一部分比关键字大，再对这两部分进行排序，直到序列有序。</p><h3 id="算法描述-5">算法描述</h3><p>使用分治法分为两部分</p><ul><li>从序列中选择一个元素作为基准( pivot )<br /></li><li>重新排列序列，所有比其小的放在左边，比其大的放在右边。在排列后，该基准就位于中间位置，这个称为分区操作。<br /></li><li>递归地把小于基准值元素的子数列和大于基准元素的子数列排序</li></ul><h3 id="代码实现-5">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[right];<br>    <span class="hljs-type">int</span> i = (left - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt;= right<span class="hljs-number">-1</span>; ++j)<br>    &#123;<br>        <span class="hljs-comment">// 如果小于pivot，i右移表示，pivot左侧的值又增加一个</span><br>        <span class="hljs-keyword">if</span>(nums[j] &lt; pivot)<br>        &#123;<br>            ++i;<br>            <span class="hljs-comment">// 将i的值和j交换，这步就是把小于基准的放在左侧</span><br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最终将基准值放在中间</span><br>    <span class="hljs-built_in">swap</span>(nums[i+<span class="hljs-number">1</span>],nums[right]);<br>    <span class="hljs-comment">// 返回基准值位置</span><br>    <span class="hljs-keyword">return</span> (i + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> pIndex = <span class="hljs-built_in">partition</span>(nums, left, right);<br>        <br>        <span class="hljs-built_in">quickSort</span>(nums, left, pIndex - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, pIndex, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序-heap-sort">7.堆排序( Heap Sort )</h2><p>Heap Sort是利用堆进行的排序算法，堆是一个类似二叉树的结构，并同时满足堆的性质：<strong>子节点键值或索引永远小于(大于)其父节点</strong>。</p><h3 id="算法描述-6">算法描述</h3><ul><li>将初始状态待排序序列 ( R1, R2, ..., Rn )构建成大根堆，此堆为初始的无序区<br /></li><li>将堆顶元素R[1]与最后一个元素R[n]互换，得到新的无序区( R1, R2, ...,Rn-1)和新的有序区(Rn)，且满足R[1], R[2], ..., R[n-1] &lt;= R[n]<br /></li><li>由于交换后新的堆顶可能会违反堆的性质，因此需要对当前无序堆进行调整，然后再次将R[1]与无序区最后一个元素互换，得到新无序区(R1, R2, ..., Rn-2 ), 新有序区( Rn-1, Rn )不断重复，直到有序区元素个数为n-1，排序完成。</li></ul><h3 id="代码实现-6">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> numSize, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> largest = i;<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (left &lt; numSize &amp;&amp; nums[left] &gt; nums[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (right &lt; numSize &amp;&amp; nums[right] &gt; nums[largest])<br>    &#123;<br>        largest = right;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (largest != i)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br><br>        <span class="hljs-built_in">heapify</span>(nums, numSize, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> numSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = numSize / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-built_in">heapify</span>(nums, numSize, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = numSize - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br>        <span class="hljs-built_in">heapify</span>(nums, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序-counting-sort">8.计数排序( Counting Sort )</h2><p>计数排序不是基于比较的排序算法，核心在于将输入的数据转化为键存储在额外开辟的数组空间中。作为线性时间复杂度的排序，<strong>计数排序要求输入数据必须是有确定范围的。</strong></p><h3 id="算法描述-7">算法描述</h3><ul><li>找出待排序数列中的<em>最大</em>和<em>最小</em>元素<br /></li><li>统计数组中每个值为 i 的元素出现的次数，存入额外数组的第 i 项。<br /></li><li>对所有的次数累加, 从头到尾，这样额外数组就表示元素的实际位置<br /></li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i)项，每放入一个元素将 C(i) 减去 1</li></ul><h3 id="代码实现-7">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> maxEle = nums[<span class="hljs-number">0</span>], minEle = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums)<br>    &#123;<br>        minEle = <span class="hljs-built_in">min</span>(minEle, num);<br>        maxEle = <span class="hljs-built_in">max</span>(maxEle, num);<br>    &#125;<br>    <span class="hljs-type">int</span> offset = maxEle - minEle + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(offset + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">// 计数，每个元素有多少个</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        ++count[nums[i] - minEle + <span class="hljs-number">1</span>];<br>    &#125;<br>   <br>    <span class="hljs-comment">// 计算每个元素的下标</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; offset; ++i)<br>    &#123;<br>        count[i + <span class="hljs-number">1</span>] += count[i];<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outPut</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        outPut[count[nums[i] - minEle+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>] = nums[i];<br>        count[nums[i] - minEle + <span class="hljs-number">1</span>]--;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1,100,22,55,22,11,33,11</span><br></code></pre></td></tr></table></figure><h3 id="算法分析-4">算法分析</h3><p>计数排序是一个稳定的排序算法，当输入元素是 n 个 0~k的整数时，时间复杂度是 <spanclass="math inline">\(O(n+k)\)</span>，空间复杂度也是 <spanclass="math inline">\(O(n+k)\)</span> ，其速度快于任何比较排序算法，当 k不是很大，且序列集中时，计数排序是一个很好的排序法。</p><h2 id="桶排序-bucket-sort">9.桶排序 ( Bucket Sort)</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，其性能高效与否就在于这个映射函数的选取。Bucket Sort工作原理：假设数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(可能使用别的排序方法或者递归地使用桶排序 )</p><h3 id="算法描述-8">算法描述</h3><ul><li>设置一个定量的数组作为空桶<br /></li><li>遍历输入数据放入对应桶中<br /></li><li>对每个不是空的桶进行排序<br /></li><li>从非空桶中把排好序的数据拼接起来</li></ul><h3 id="代码实现-8">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> bucketSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> minValue, maxValue;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>    &#123;<br>minValue = <span class="hljs-built_in">min</span>(minValue,num);<br>        maxValue = <span class="hljs-built_in">max</span>(maxValue,num);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class="hljs-number">1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">buckets</span>(bucketCount)<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> bucketIndex = (nums[i] - minValue) / bucketSize;<br>        bucket[bucketIndex].<span class="hljs-built_in">push_back</span>(nums[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-built_in">sort</span>(bucket[i].<span class="hljs-built_in">begin</span>(), bucket[i].<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket[i].<span class="hljs-built_in">size</span>(); ++j)<br>        &#123;<br>            nums[index++] = bucket[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析-5">算法分析</h3><p>桶排序最好情况下时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，其取决于各个桶之间数据进行排列的时间复杂度，因为其他部分的时间复杂度都为<span class="math inline">\(O(n)\)</span>。显然桶划分的越小时间复杂度越低，但是与之相对的，空间消耗就会上升。</p><h2 id="基数排序radix-sort">基数排序(Radix Sort)</h2><p>基数排序是按照低位先排序，后收集；在按照高位排序再收集；依次类推直到最高位也排序完毕。此外，有些属性是有优先级顺序的，按低优先级部分先排序，再按照高优先级排序，最后就是高优先级高的在前，高优先级相同者低优先级高的在前。在游戏开发中可能常常用这个排序？</p><h3 id="算法描述-9">算法描述</h3><ul><li>取得数组中的最大数，并取其位数。<br /></li><li>nums 为原始数组，从最低位开始取每个位组成 radix 数组；<br /></li><li>对 radix 数据进行计数排序 ( 计数排序适用于小范围 )</li></ul><h3 id="代码实现-9">代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxNum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> maxNum = INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>    &#123;<br>        maxNum = <span class="hljs-built_in">max</span>(num,maxNum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxNum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> exp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outPut</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> i, count[<span class="hljs-number">10</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        count[(nums[i]/exp) % <span class="hljs-number">10</span>]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>    &#123;<br>        count[i] += count[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>    &#123;<br>        outPut[count[(nums[i]/exp)%<span class="hljs-number">10</span>]<span class="hljs-number">-1</span>] = nums[i];<br>        count[(num[i]/exp)%<span class="hljs-number">10</span>]--;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> maxValue = <span class="hljs-built_in">getMaxNum</span>(nums);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> exp = <span class="hljs-number">1</span>; maxValue/exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>)<br>    &#123;<br>        <span class="hljs-built_in">countSort</span>(nums,n,exp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法分析-6">算法分析</h3><p>基数排序分别排序，分别收集，所以是稳定的，但是基数排序性能可能会比桶排序性能要差，每一次关键字的桶分配都需要<span class="math inline">\(O(n)\)</span> 时间复杂度，分配之后又需要<span class="math inline">\(O(n)\)</span> 时间排序。假设待排列序列可分出m 关键字，其时间复杂度为 <spanclass="math inline">\(O(m*2n)\)</span>，但是 m远小于n，所有还是线性时间级别。<br />其空间复杂度为 <span class="math inline">\(O(n+k)\)</span> ，k为桶的数量，一般来讲 n &gt;&gt; k，所有额外空间需要 n。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBR备忘笔记</title>
    <link href="/2022/06/17/PBR/"/>
    <url>/2022/06/17/PBR/</url>
    
    <content type="html"><![CDATA[<p>记录一些有关<code>PBR</code>的知识，以免自己忘记了。网页居然不支持LATEX。<br />回头再看自己这篇文章写的稀烂，入门学习PBR还是看<ahref="%5BLearnOpenGL%20-%20Theory%5D(https://learnopengl.com/PBR/Theory)">LearnOpenGL</a>吧</p><span id="more"></span><h1 id="几个问题">几个问题</h1><p>什么是<code>PBR</code>呢？<br />即<code>Physicallly-Based-Rendering</code>，中文可以叫做基于物理的渲染。是一种渲染技术。</p><p>为什么要有PBR呢？<br />随着游戏行业的发展玩家对于画面的要求也是越来越严格，对于真实性和细节有更进一步的要求。<br />而PBR能做到的就是表现十分<strong>写实的材质</strong>，而且还可以制造出<strong>风格化</strong>迥异的资源。</p><h1 id="pbr">PBR</h1><h2 id="初步了解">初步了解</h2><h3 id="什么叫基于物理">什么叫基于物理</h3><p>物理的渲染包含了三个条件：</p><ul><li><p>基于物理的材质</p></li><li><p>基于物理的灯光</p></li><li><p>基于物理适配的摄像机</p></li></ul><h3 id="基于物理的材质">基于物理的材质</h3><p>这种材质归根结底是对于现实世界的一种模拟。</p><h4 id="物理材质的三个条件">物理材质的三个条件</h4><ul><li><p>必须遵循能量守恒，比如传播过程的光能+光转换为其他形式的能量不会超过光发出是的能量。</p></li><li><p>基于微表面模型</p></li><li><p>基于物理的<code>BRDF</code></p></li></ul><h5 id="微平面理论">微平面理论</h5><p>为了模拟现实世界的物体表面，我们认为物体表面都是由很小、随机朝向的镜面平面(发生镜面反射的小平面)。<br />光滑表面的小镜面分布更加规则。<br />而粗糙表面的小镜面十分混沌。</p><h5 id="能量守恒">能量守恒</h5><p>高中物理(<br />对于粗糙平面更多的光被转换为其他能量，反射强度低。<br />光滑平面，由于折射、散射更少，镜面反射会更强。</p><h6 id="反射率方程">反射率方程</h6><p>我们在模拟过程中，往往用反射率方程描述能量守恒<br /><span class="math display">\[\begin{aligned}    L_0=Le+\\    \int_{\Omega}f_r\hspace{20px}\end{aligned}\]</span></p><div style="margin:left;width:100%"><img src="/imgs/PBR/math1.png" alt="math1"></div><p>而重点就在于反射比例，它规定了光在物体表面如何反射。</p><p><strong>BRDF 双向反射分布函数</strong></p><p>粗糙来讲BRDF就是描述光在物体表面如何反射。<br /><em>双向</em>：是说相机方向和光源方向调换后，他们的反射规律是一致的，即一束光打到表面分配到各个方向这个过程是可逆的，可以变成“分配出去的那些光”再汇聚成原来打进来的光，有点类似光路可逆。</p><p>当光打到物体表面，会发生散射和高光反射。散射是向各个角度射出强度相近的光，高光反射就是我们常常在物体表面看到光斑。</p><p>而与BRDF对应的还有BTDF，BTDF是双向透射分布函数，从名字就可以大概知道这个函数描述的是物体投射后在表面向各方向如何发射光线。</p><div style="margin:auto;width:30%"><img src="/imgs/PBR/BSDF.png" alt="BSDF示意"></div><p>BRDF+BTDF就是BSDF，双向散射分布函数，感性来讲有了BSDF我们就知道，当一束光打到一块玻璃砖上表面时，上表面光如何发射(BRDF)，下表面如何透射(BTDF)。</p><p>一般的BRDF：<spanclass="math inline">\(f_{r}(p,w_{i},w_{o})\)</span>或者<spanclass="math inline">\(f_{r}(w_{i},w_{r})\)</span><br />即通过入射光反向和反射光方向，计算得到反射比例。</p><p><strong>BRDF计算</strong></p><p>我们可以把BRDF分为两个部分进行计算，即<strong>漫反射</strong>和<strong>高光反射</strong>。</p><ul><li><p>漫反射：可以采用经典的Lambert模型，这只是一种经验模型<br />我们根据光与平面法线的夹角计算光强，夹角越大光强越小，可以参照太阳对于地球夏冬温度的影响。</p><div style="margin:left;width:100%"><img src="/imgs/PBR/math2.png" alt="math2"></div></li><li><p>高光反射：</p><ul><li><p>Phong模型，根据反射方向和视角方向衡量高光的强弱。</p></li><li><p>Blinn-Phong：根据半角向量和法线方向，半角向量即视角方向和入射方向的“角分线”，该向量越接近法线说明反射路径越接近“<code>入射反向</code>-&gt;<code>|法线</code>-&gt;<code>视角方向</code>”，反射就越强。<br />半角向量的引入极大的节约了计算过程，由于Phong模型需要计算反射反向所以比较于Blinn-Phong效率低。而Blinn-Phong已经有很好的效果了。</p></li></ul></li></ul><div style="margin:auto;width:100%"><img src="/imgs/PBR/phong.png" alt="PhongAndBlinnPhong"></div><ul><li><p>基于物理的高光：</p><div style="margin:left;width:100%"><img src="/imgs/PBR/math3.png" alt="math3"></div></li></ul><h6 id="法线分布函数ndf">法线分布函数(NDF)</h6><div style="margin:left;width:100%"><img src="/imgs/PBR/math4.png" alt="math4"></div><p><strong>与Blinn-Phong模型区别</strong>：二者虽然都是法线对于光的影响，但是Blinn-Phong终究是经验模型，NDF更贴切实际，尤其是在末端部分，GGX-NDF末端过度平滑更加具有真实感更贴近物理，而Blinn-Phong相比较为生硬。</p><h6 id="几何遮蔽">几何遮蔽</h6><p>我们先前讨论的微平面理论，把每个小平面单独计算互不干扰，但是在实际中面与面的遮挡关系是存在的，比如人的内眼角和鼻子交汇处(这里也常常运用AO贴图，这个例子不太恰当但是主要是说明这种遮挡现象)，真实物体的表面凹凸不平，微平面间势必存在相互遮挡的关系。</p><div style="margin:auto;width:80%"><img src="/imgs/PBR/jihe.png" alt="几何遮蔽"></div><p>左侧为几何遮蔽示意，右侧为几何阴影示意。<br />对于几何遮蔽我们通常运用统计学(概率论)的有关知识近似计算相互遮蔽，因为我们很难一个一个去算微平面间的遮挡。</p><div style="margin:auto;width:80%"><img src="/imgs/PBR/几何遮蔽.png" alt="几何遮蔽公式"></div><div style="margin:left;width:100%"><img src="/imgs/PBR/math5.png" alt="math5"></div><h6 id="菲涅尔方程">菲涅尔方程</h6><p>被反射的光线对比光线被折射部分所占的比率，描述了反射相对于折射的强度。比如我们垂直观察水面很容易看到水底，而我们远离水面水平观察时往往只能看到水面波光粼粼的样子这就是菲涅尔反射，ta描述了反射相对于折射的强度。<br />还有一个典型的物理例子就是在夏天时路远处的柏油会发生镜面反射。</p><div style="margin:left;width:100%"><img src="/imgs/PBR/math7.png" alt="math7"></div><h2 id="last">Last</h2><div style="margin:left;width:100%"><img src="/imgs/PBR/math6.png" alt="math6"></div><p>材质的效果关键就是FDG，但是BRDF不止于FDG，而PBR也不止于BRDF。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>透明和earlyZ</title>
    <link href="/2022/05/31/%E9%80%8F%E6%98%8E%E5%92%8CEarly%20Z%E3%80%81Pre%20Z/"/>
    <url>/2022/05/31/%E9%80%8F%E6%98%8E%E5%92%8CEarly%20Z%E3%80%81Pre%20Z/</url>
    
    <content type="html"><![CDATA[<p>白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。</p><span id="more"></span><h1 id="透明和early-zpre-z">透明和Early Z、Pre Z</h1><h2 id="early-z">Early Z</h2><p>提到EarlyZ就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。<br />具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。</p><p>深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试EarlyZ，来解决过度不必要的片元着色计算。</p><p><img src="/imgs/透明和Early Z、Pre Z/渲染流程.png" alt="来源百人计划"></p><p>Early Z将在片元着色器前一个阶段进行，进行EarlyZ会直接进行深度判断，不进行计算直接进行舍弃(<em>在EarlyZ不仅判断深度通常也会写入深度</em>)，这样就节省了不必要计算量，通常EarlyZ由硬件进行，并且Early Z还可以添加模板测试。</p><h3 id="early-z失效">Early Z失效</h3><ul><li><p>开启Alpha Test 或者手动丢弃片元等操作，如clip<br />因为EarlyZ也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alphatest中本应该仍对后续的片元进行透明度测试，所以由于EarlyZ我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )</p></li><li><p>手动修改GPU插值得到的深度值<br />和上述情况类似。</p></li><li><p>开启透明混合(Alpha Blend)<br />这里是针对关闭深度写入(<code>ZWrite Off</code>)的Alpha Blend</p></li><li><p>关闭深度测试(Depth Test)<br />就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。</p></li></ul><p><strong>如果从远向近渲染EarlyZ就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算</strong></p><h3 id="高效利用">高效利用</h3><p>可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。</p><h2 id="z-prepass">Z PrePass</h2><h3 id="使用两个pass">使用两个Pass：</h3><ul><li><p>在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。</p></li><li><p>在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。</p></li></ul><h4 id="问题">问题</h4><p>动态批处理问题：因为运用多个pass所以无法运用动态批处理。<br />所以会进一步带来Draw Call问题，运用了Z-Prepass会导致DrawCall增加，会造成一定的性能损失。</p><h3 id="提前分离prepass">提前分离PrePass</h3><p>仍然使用两个Pass，但是是两个Shader</p><ul><li><p>将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。</p></li><li><p>而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。</p></li></ul><p>Z-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以<strong>先渲染背面剔除正面，再渲染正面剔除背面</strong>，这样就可以正常混合。</p><h3 id="谨慎使用z-prepass">谨慎使用Z-Prepass</h3><p>是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。</p><h2 id="透明">透明</h2><h3 id="两种透明方式">两种透明方式</h3><ul><li><p>透明度测试(alpha test):一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 剔除片元  </span><br>fixed<span class="hljs-number">4</span> frag<span class="hljs-comment">(v2f i)</span> : SV_Target  <br>&#123;  <br>    fixed<span class="hljs-number">4</span> col = tex<span class="hljs-number">2</span>D<span class="hljs-comment">(_MainTex, i.uv)</span>;  <br>    clip<span class="hljs-comment">(col.a - _CutOff)</span>  <br>&#125;  <br></code></pre></td></tr></table></figure></li><li><p>透明度混合(alpha blend):这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，<strong>如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除</strong>，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为objectlevel的排序被剔除的问题。</p></li></ul><h4 id="关于透明混合渲染顺序">关于透明混合渲染顺序</h4><p>因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。</p><div style="margin:;width:30%"><img src="/imgs/透明和Early Z、Pre Z/BT.jpg" alt="一个透明物体在前、不透明物体之后"></div><p>如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。</p><div style="margin:right;width:30%"><img src="/imgs/透明和Early Z、Pre Z/TB.jpg" alt="先渲染透明物体，再渲染不透明物体"></div><p>但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。</p><p>所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：<br />1、正常渲染所有不透明物体，保持深度测试和深度写入；<br />2、把透明物体按从远及近的顺序渲染，<strong>开启深度测试，但是要关闭深度写入</strong>。<br />      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。</p><div style="margin:auto;width:30%"><img src="imgs/透明和Early Z、Pre Z/qh.jpg" alt="前后关系"></div><h4 id="开启深度写入的半透明">开启深度写入的半透明</h4><p>这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)</p><h4 id="双面透明">双面透明</h4><p>对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。</p><p>透明和earlyz就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(<br />关于透明物体顺序问题还有OIT技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++-sort-浅识</title>
    <link href="/2022/05/03/C++-sort-%E6%B5%85%E8%AF%86/"/>
    <url>/2022/05/03/C++-sort-%E6%B5%85%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和<code>stable_sort</code> 的理解一直有问题。</p><span id="more"></span><p>先说最粗暴简单的理解: <strong><code>sort</code> 和<code>stable_sort</code>定义了我们希望的"&lt;"比较，就是把我们认为小的放在前面</strong>。</p><h1 id="题目">题目</h1><p><img src="/imgs/C++-sort-浅识/题目-1677565078882-1.png"/></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class="hljs-built_in">stable_sort</span>(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string&amp; log1, <span class="hljs-type">const</span> string&amp; log2) &#123;  <br>        <span class="hljs-type">int</span> pos1 = log1.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <br>        <span class="hljs-type">int</span> pos2 = log2.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <br>        <span class="hljs-type">bool</span> isDigit1 = <span class="hljs-built_in">isdigit</span>(log1[pos1 + <span class="hljs-number">1</span>]);  <br>        <span class="hljs-type">bool</span> isDigit2 = <span class="hljs-built_in">isdigit</span>(log2[pos2 + <span class="hljs-number">1</span>]);  <br>        <span class="hljs-keyword">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 我的问题  </span><br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class="hljs-built_in">substr</span>(pos1);  <br>            string str2 = log2.<span class="hljs-built_in">substr</span>(pos2);  <br>            <span class="hljs-keyword">if</span> (str1 != str2)  <br>                <span class="hljs-keyword">return</span> str1 &lt; str2;  <br>            <span class="hljs-keyword">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> isDigit1 ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;  <br>        &#125;);  <br>    <span class="hljs-keyword">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>我的问题就是出现在数字log的处理部分:</p><p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>前面，如果返回值为 <code>true</code>，不做修改；如果返回值为<code>false</code>，二者交换位置。</p><p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p><h2 id="我的反思">我的反思</h2><p><img src="/imgs/C++-sort-浅识/sort.png"/></p><p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是<code>&lt;</code> 比较。<br />关于返回值的理解就是，如果返回值为 <code>true</code> 就是<code>s1 &lt; s2</code>，那么返回值为<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>就是 <code>&gt;=</code> 。</p><blockquote><p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />true: 就是 s1 &lt; s2</p><p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p></blockquote><h1 id="总结">总结</h1><p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p><h1 id="相关链接">相关链接:</h1><p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和<code>stable_sort</code> 的理解一直有问题。</p><!--more--><p>先说最粗暴简单的理解: <strong><code>sort</code> 和<code>stable_sort</code>定义了我们希望的"&lt;"比较，就是把我们认为小的放在前面</strong>。</p><h1 id="题目-1">题目</h1><p><img src="/imgs/C++-sort-浅识/题目-1677565078882-1.png"/></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class="hljs-built_in">stable_sort</span>(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string&amp; log1, <span class="hljs-type">const</span> string&amp; log2) &#123;  <br>        <span class="hljs-type">int</span> pos1 = log1.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <br>        <span class="hljs-type">int</span> pos2 = log2.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <br>        <span class="hljs-type">bool</span> isDigit1 = <span class="hljs-built_in">isdigit</span>(log1[pos1 + <span class="hljs-number">1</span>]);  <br>        <span class="hljs-type">bool</span> isDigit2 = <span class="hljs-built_in">isdigit</span>(log2[pos2 + <span class="hljs-number">1</span>]);  <br>        <span class="hljs-keyword">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 我的问题  </span><br>        &#125;  <br>        <span class="hljs-keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class="hljs-built_in">substr</span>(pos1);  <br>            string str2 = log2.<span class="hljs-built_in">substr</span>(pos2);  <br>            <span class="hljs-keyword">if</span> (str1 != str2)  <br>                <span class="hljs-keyword">return</span> str1 &lt; str2;  <br>            <span class="hljs-keyword">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> isDigit1 ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;  <br>        &#125;);  <br>    <span class="hljs-keyword">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>我的问题就是出现在数字log的处理部分:</p><p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>前面，如果返回值为 <code>true</code>，不做修改；如果返回值为<code>false</code>，二者交换位置。</p><p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p><h2 id="我的反思-1">我的反思</h2><p><img src="/imgs/C++-sort-浅识/sort.png"/></p><p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是<code>&lt;</code> 比较。<br />关于返回值的理解就是，如果返回值为 <code>true</code> 就是<code>s1 &lt; s2</code>，那么返回值为<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>就是 <code>&gt;=</code> 。</p><blockquote><p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />true: 就是 s1 &lt; s2</p><p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p></blockquote><h1 id="总结-1">总结</h1><p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p><p>相关链接:<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <ahref="https://stackoverflow.com/questions/45929474/why-must-stdsort-compare-function-return-false-when-arguments-are-equal">Whymust std::sort compare function return false when arguments areequal?</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++之static,const,define</title>
    <link href="/2022/05/02/C++-static-const-define/"/>
    <url>/2022/05/02/C++-static-const-define/</url>
    
    <content type="html"><![CDATA[<p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p><span id="more"></span><h1 id="static">static</h1><h2 id="静态数据的存储">静态数据的存储</h2><blockquote><p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p><p>分为DATA段与BSS段。<br />DATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p></blockquote><h3 id="static对于变量">static对于变量</h3><p><strong>1.局部变量</strong></p><p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p><p>内存位置: 静态存储区<br />初始化: 局部的静态变量只被初始化一次<br />作用域:作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p><blockquote><p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p></blockquote><p><strong>2.全局变量</strong></p><p>在全局变量上作用，其变为全局静态变量。</p><p>内存位置: 静态存储区；<br />初始化: 未经初始化的全局变量自动初始化为0；<br />作用域:全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p><blockquote><p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p></blockquote><h3 id="static对于函数">static对于函数</h3><p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p><h3 id="static对于类">static对于类</h3><p><strong>1.成员变量</strong></p><p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticNum;  <br>    <span class="hljs-built_in">MyClass</span>();  <br>    ~<span class="hljs-built_in">MyClass</span>();      <br>&#125;<br>  <br><span class="hljs-type">int</span> MyClass::staticNum = <span class="hljs-number">1</span>;  <br></code></pre></td></tr></table></figure><p><strong>2.成员函数</strong></p><p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />静态成员是可以独立访问的，无需创建任何实例就能调用。</p><p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p><h1 id="const">const</h1><ul><li><p>限定变量不可修改。</p></li><li><p>限定成员函数不能修改任何数据成员。</p></li></ul><h2 id="const-和-指针">const 和 指针</h2><ul><li>指向常量的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;  <br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class="hljs-comment">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class="hljs-comment">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class="hljs-string">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure><p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p><ul><li>指针常量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;  <br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 2  </span><br>a++;                           <span class="hljs-comment">// 3  </span><br>(*p)++;                        <span class="hljs-comment">// 4  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 4  </span><br></code></pre></td></tr></table></figure><p><code>int* const</code> 的 <code>const</code> 修饰<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>指向的是 <code>int</code> 类型，不是<code>const int</code>类型，<code>const int* const</code> 才是指向 <code>const int</code>类型。</p><h1id="static和const可以同时修饰成员函数吗">static和const可以同时修饰成员函数吗？</h1><p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br /><code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br /><code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />二者一个脱离实例，一个保护实例。</p><h2 id="const-和-define-定义常量的区别">const 和 #define定义常量的区别</h2><ul><li><p>编译器处理方式不同:<br />define: 是“编译时”的概念，在预处理阶段进行替换。<br />const: 是“运行时”的概念，在编译阶段确定其值</p></li><li><p>类型检查:<br />define: 无类型，不进行类型安全检查，可能会产生<br />const: 有数据类型，编译时会检查</p></li><li><p>内存空间:<br />define:不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li><li><p>函数参数:<br />宏定义不能作为参数传递给函数。<br />const常量可以在函数的参数列表中出现。</p></li><li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li><li><p>define宏替换只做替换，不做表达式计算。</p></li></ul><h1 id="typedef-与-define-的区别">typedef 与 #define 的区别</h1><h2 id="typedef">typedef</h2><p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p><h2 id="define">#define</h2><p><code>#define</code>为宏定义语句，就是文本替换</p><h2 id="区别">区别</h2><ul><li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li><li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li><li><p>对指针操作不同:</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * pint  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PINT int *</span><br>  <br><span class="hljs-type">int</span> i1 = <span class="hljs-number">2</span>, i2 = <span class="hljs-number">3</span>, i3 = <span class="hljs-number">4</span>;<br>  <br><span class="hljs-type">const</span> pint p1 = &amp;i1;    <span class="hljs-comment">// p1不可更改，相当于 int* const  </span><br><span class="hljs-type">const</span> PINT p2 = &amp;i2;    <span class="hljs-comment">// p2可以修改，因为就是 const int *  </span><br>PINT <span class="hljs-type">const</span> p3 = &amp;i3;    <span class="hljs-comment">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure><p>相关链接：<br /><ahref="https://www.cnblogs.com/lulipro/p/5976601.html">C++头文件，预处理详解- lulipro - 博客园</a><br />======= --- title: C++之static,const,define date: 2022-05-02 13:11:42tags:</p><hr /><p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p><!--more--><h1 id="static-1">static</h1><h2 id="静态数据的存储-1">静态数据的存储</h2><blockquote><p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p><p>分为DATA段与BSS段。<br />DATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p></blockquote><h3 id="static对于变量-1">static对于变量</h3><p><strong>1.局部变量</strong></p><p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p><p>内存位置: 静态存储区<br />初始化: 局部的静态变量只被初始化一次<br />作用域:作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p><blockquote><p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p></blockquote><p><strong>2.全局变量</strong></p><p>在全局变量上作用，其变为全局静态变量。</p><p>内存位置: 静态存储区；<br />初始化: 未经初始化的全局变量自动初始化为0；<br />作用域:全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p><blockquote><p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p></blockquote><h3 id="static对于函数-1">static对于函数</h3><p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p><h3 id="static对于类-1">static对于类</h3><p><strong>1.成员变量</strong></p><p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticNum;  <br>    <span class="hljs-built_in">MyClass</span>();  <br>    ~<span class="hljs-built_in">MyClass</span>();      <br>&#125;<br>  <br><span class="hljs-type">int</span> MyClass::staticNum = <span class="hljs-number">1</span>;  <br></code></pre></td></tr></table></figure><p><strong>2.成员函数</strong></p><p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />静态成员是可以独立访问的，无需创建任何实例就能调用。</p><p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p><h1 id="const-1">const</h1><ul><li><p>限定变量不可修改。</p></li><li><p>限定成员函数不能修改任何数据成员。</p></li></ul><h2 id="const-和-指针-1">const 和 指针</h2><ul><li>指向常量的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一种  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;  <br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class="hljs-comment">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class="hljs-comment">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class="hljs-string">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure><p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p><ul><li>指针常量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;  <br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 2  </span><br>a++;                           <span class="hljs-comment">// 3  </span><br>(*p)++;                        <span class="hljs-comment">// 4  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="hljs-comment">// 4  </span><br></code></pre></td></tr></table></figure><p><code>int* const</code> 的 <code>const</code> 修饰<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>指向的是 <code>int</code> 类型，不是<code>const int</code>类型，<code>const int* const</code> 才是指向 <code>const int</code>类型。</p><h1id="static和const可以同时修饰成员函数吗-1">static和const可以同时修饰成员函数吗？</h1><p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br /><code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br /><code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />二者一个脱离实例，一个保护实例。</p><h2 id="const-和-define-定义常量的区别-1">const 和 #define定义常量的区别</h2><ul><li><p>编译器处理方式不同:<br />define: 是“编译时”的概念，在预处理阶段进行替换。<br />const: 是“运行时”的概念，在编译阶段确定其值</p></li><li><p>类型检查:<br />define: 无类型，不进行类型安全检查，可能会产生<br />const: 有数据类型，编译时会检查</p></li><li><p>内存空间:<br />define:不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li><li><p>函数参数:<br />宏定义不能作为参数传递给函数。<br />const常量可以在函数的参数列表中出现。</p></li><li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li><li><p>define宏替换只做替换，不做表达式计算。</p></li></ul><h1 id="typedef-与-define-的区别-1">typedef 与 #define 的区别</h1><h2 id="typedef-1">typedef</h2><p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p><h2 id="define-1">#define</h2><p><code>#define</code>为宏定义语句，就是文本替换</p><h2 id="区别-1">区别</h2><ul><li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li><li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li><li><p>对指针操作不同:</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> * pint  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PINT int *</span><br>  <br><span class="hljs-type">int</span> i1 = <span class="hljs-number">2</span>, i2 = <span class="hljs-number">3</span>, i3 = <span class="hljs-number">4</span>;<br>  <br><span class="hljs-type">const</span> pint p1 = &amp;i1;    <span class="hljs-comment">// p1不可更改，相当于 int* const  </span><br><span class="hljs-type">const</span> PINT p2 = &amp;i2;    <span class="hljs-comment">// p2可以修改，因为就是 const int *  </span><br>PINT <span class="hljs-type">const</span> p3 = &amp;i3;    <span class="hljs-comment">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure><p>相关链接：<br /><ahref="https://www.cnblogs.com/lulipro/p/5976601.html">C++头文件，预处理详解- lulipro - 博客园</a><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <ahref="https://zhuanlan.zhihu.com/p/152046509">C++中的static</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针、RAII、Block(To Be Continued)</title>
    <link href="/2022/04/13/C++-Smart-pointers/"/>
    <url>/2022/04/13/C++-Smart-pointers/</url>
    
    <content type="html"><![CDATA[<h1 id="c-智能指针smart-pointers">C++ : 智能指针(Smart Pointers)</h1><p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p><span id="more"></span><h2 id="对象生存期和资源管理raii">对象生存期和资源管理(RAII)</h2><p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p><p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p><p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resourceacquisition is initialization.)</p><blockquote><p>Resource 资源</p><p>acquisition 获取</p><p>initialization 初始化</p></blockquote><p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p><h3 id="为什么要提raii">为什么要提RAII？</h3><p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p><pre><code class="hljs">class widget  &#123;  private:      int* data;  public:      widget(const int size) &#123; data = new int[size]; &#125; // acquire      ~widget() &#123; delete[] data; &#125; // release      void do_something() &#123;&#125;  &#125;;void functionUsingWidget() &#123;      widget w(1000000);   // lifetime automatically tied to enclosing scope                          // constructs w, including the w.data member      w.do_something();&#125; // automatic destruction and deallocation for w and w.data</code></pre><p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p><pre><code class="hljs">#include &lt;memory&gt;  class widget  &#123;  private:      std::unique_ptr&lt;int&gt; data;  public:      widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;      void do_something() &#123;&#125;  &#125;;void functionUsingWidget() &#123;      widget w(1000000);   // lifetime automatically tied to enclosing scope                  // constructs w, including the w.data gadget member      // ...      w.do_something();      // ...  &#125; // automatic destruction and deallocation for w and w.data</code></pre><blockquote><p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。此模型适用于其他资源，例如文件句柄或套接字。</p></blockquote><p>C++ 的设计可确保对象在超出范围时被销毁。也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。销毁对象时，将按特定顺序销毁其基项和成员。在全局范围内在任何块之外声明的对象都可能会导致问题。如果全局对象的构造函数引发异常，则调试可能很困难。</p><blockquote><p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p><p>block是一片具有以下特性的内联代码片段集合:<br />可以像函数一样有类型参数；<br />可以声明或推算出一个返回类型；<br />可以访问和block定义在同一个词法范围里的变量（即Status）；<br />可以修改同一个词法范围里的变量；<br />同一个词法范围的block之间可以共享变量和变量的修改结果；<br />当栈被摧毁后，栈里的block依旧可以保持状态信息；</p></blockquote><h4 id="什么是句柄">什么是句柄</h4><blockquote><p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p><p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p><p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(FileDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p></blockquote><h2 id="智能指针">智能指针</h2><p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p><p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong><em>(例如，动态分配的内存或系统对象句柄)</em>的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p><p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p><p>原始指针和智能指针对比：</p><pre><code class="hljs">void UseRawPointer()&#123;      Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);      ......      // dont forget to delete      delete pSong;  &#125;</code></pre><p>​<br />​void UseSmartPointer(){<br />​unique_ptr<Song> song2(new Song(L"Rock Rill", L"Rock Rill"));<br />​    ......<br />​    wstring s = song2-&gt;duration_;<br />​    ...<br />​}// song2 is deleted automatically here</p><p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(thecall todelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p><p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p><p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p><p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p><p><code>unique_ptr</code>封装指向大型对象的指针示例：</p><pre><code class="hljs">class LargeObject&#123;      public:          void DoSomething()&#123;&#125;  &#125;;void ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  void SmartPointerDemo()&#123;      // Creat the Object and Pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());          // Call a method on the object      pLarge-&gt;DoSomething();    // Pass a reference to a method      ProcessLargeObject(*pLarge);  &#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre><p>上述例子展示了如何使用智能指针执行以下关键步骤。</p><p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p><p>也就是说智能指针要直接初始化。</p><p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p><p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p><p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p><p>    5.允许智能指针删除对象。</p><p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。使用重载 * 和 -&gt;运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p><p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用<code>.</code> 表示法进行访问。 例如，某些C++标准库智能指针具有释放指针所有权的重置成员函数。如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p><pre><code class="hljs">void SmartPointerDemo2()  &#123;      // Create the object and pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());    //Call a method on the object      pLarge-&gt;DoSomething();    // Free the memory before we exit function block.      pLarge.reset();    // Do some other work...&#125;</code></pre><p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p><p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且<code>CComPtr</code> 具有公共 <code>p</code> 类成员。通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p><pre><code class="hljs">void SmartPointerDemo4()  &#123;      // Create the object and pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());    //Call a method on the object      pLarge-&gt;DoSomething();    // Pass raw pointer to a legacy API      LegacyLargeObjectFunction(pLarge.get());    &#125;</code></pre><h2 id="智能指针的类型">智能指针的类型</h2><h3 id="c标准库智能指针">C++标准库智能指针</h3><blockquote><p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p><p>plain old C++ object</p></blockquote><ul><li><p><code>unique_ptr</code></p><p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li><li><p><code>shared_ptr</code></p><p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li><li><p><code>weak_ptr</code></p><p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li></ul><h2 id="section">=======</h2><p>title: C++智能指针、RAII、Block(To Be Continued) date: 2022-04-1311:14:05 tags:</p><hr /><h1 id="c-智能指针smart-pointers-1">C++ : 智能指针(Smart Pointers)</h1><p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p><!--more--><h2 id="对象生存期和资源管理raii-1">对象生存期和资源管理(RAII)</h2><p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p><p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p><p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resourceacquisition is initialization.)</p><blockquote><p>Resource 资源</p><p>acquisition 获取</p><p>initialization 初始化</p></blockquote><p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p><h3 id="为什么要提raii-1">为什么要提RAII？</h3><p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p><pre><code class="hljs">class widget  &#123;  private:      int* data;  public:      widget(const int size) &#123; data = new int[size]; &#125; // acquire      ~widget() &#123; delete[] data; &#125; // release      void do_something() &#123;&#125;  &#125;;void functionUsingWidget() &#123;      widget w(1000000);   // lifetime automatically tied to enclosing scope                          // constructs w, including the w.data member      w.do_something();&#125; // automatic destruction and deallocation for w and w.data</code></pre><p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p><pre><code class="hljs">#include &lt;memory&gt;  class widget  &#123;  private:      std::unique_ptr&lt;int&gt; data;  public:      widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;      void do_something() &#123;&#125;  &#125;;void functionUsingWidget() &#123;      widget w(1000000);   // lifetime automatically tied to enclosing scope                  // constructs w, including the w.data gadget member      // ...      w.do_something();      // ...  &#125; // automatic destruction and deallocation for w and w.data</code></pre><blockquote><p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。此模型适用于其他资源，例如文件句柄或套接字。</p></blockquote><p>C++ 的设计可确保对象在超出范围时被销毁。也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。销毁对象时，将按特定顺序销毁其基项和成员。在全局范围内在任何块之外声明的对象都可能会导致问题。如果全局对象的构造函数引发异常，则调试可能很困难。</p><blockquote><p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p><p>block是一片具有以下特性的内联代码片段集合:<br />可以像函数一样有类型参数；<br />可以声明或推算出一个返回类型；<br />可以访问和block定义在同一个词法范围里的变量（即Status）；<br />可以修改同一个词法范围里的变量；<br />同一个词法范围的block之间可以共享变量和变量的修改结果；<br />当栈被摧毁后，栈里的block依旧可以保持状态信息；</p></blockquote><h4 id="什么是句柄-1">什么是句柄</h4><blockquote><p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p><p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p><p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(FileDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p></blockquote><h2 id="智能指针-1">智能指针</h2><p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p><p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong><em>(例如，动态分配的内存或系统对象句柄)</em>的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p><p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p><p>原始指针和智能指针对比：</p><pre><code class="hljs">void UseRawPointer()&#123;      Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);      ......      // dont forget to delete      delete pSong;  &#125;</code></pre><p>​<br />​void UseSmartPointer(){<br />​unique_ptr<Song> song2(new Song(L"Rock Rill", L"Rock Rill"));<br />​    ......<br />​    wstring s = song2-&gt;duration_;<br />​    ...<br />​}// song2 is deleted automatically here</p><p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(thecall todelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p><p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p><p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p><p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p><p><code>unique_ptr</code>封装指向大型对象的指针示例：</p><pre><code class="hljs">class LargeObject&#123;      public:          void DoSomething()&#123;&#125;  &#125;;void ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  void SmartPointerDemo()&#123;      // Creat the Object and Pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());          // Call a method on the object      pLarge-&gt;DoSomething();    // Pass a reference to a method      ProcessLargeObject(*pLarge);  &#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre><p>上述例子展示了如何使用智能指针执行以下关键步骤。</p><p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p><p>也就是说智能指针要直接初始化。</p><p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p><p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p><p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p><p>    5.允许智能指针删除对象。</p><p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。使用重载 * 和 -&gt;运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p><p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用<code>.</code> 表示法进行访问。 例如，某些C++标准库智能指针具有释放指针所有权的重置成员函数。如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p><pre><code class="hljs">void SmartPointerDemo2()  &#123;      // Create the object and pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());    //Call a method on the object      pLarge-&gt;DoSomething();    // Free the memory before we exit function block.      pLarge.reset();    // Do some other work...&#125;</code></pre><p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p><p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且<code>CComPtr</code> 具有公共 <code>p</code> 类成员。通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p><pre><code class="hljs">void SmartPointerDemo4()  &#123;      // Create the object and pass it to a smart pointer      std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());    //Call a method on the object      pLarge-&gt;DoSomething();    // Pass raw pointer to a legacy API      LegacyLargeObjectFunction(pLarge.get());    &#125;</code></pre><h2 id="智能指针的类型-1">智能指针的类型</h2><h3 id="c标准库智能指针-1">C++标准库智能指针</h3><blockquote><p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p><p>plain old C++ object</p></blockquote><ul><li><p><code>unique_ptr</code></p><p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li><li><p><code>shared_ptr</code></p><p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li><li><p><code>weak_ptr</code></p><p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li></ul><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>e8dca420d7048ad9484cd8252ef496504eab0a20<em>智能指针还和COM有关，等待后续的学习补充.……</em></p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dissolve in Unity</title>
    <link href="/2022/04/09/Dissolve-in-Unity/"/>
    <url>/2022/04/09/Dissolve-in-Unity/</url>
    
    <content type="html"><![CDATA[<h1 id="dissolve-in-unity">Dissolve in Unity</h1><p>参考冯乐乐所著《Unity Shader入门精要》在unity里实现简单的消融(Dissolve)效果，主要思想是利用噪声纹理，进行透明度剔除。(图片在GitHub加载失败可能是网络问题)</p><h2 id="结果预览">结果预览</h2><figure><imgsrc="https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveResult.png"alt="Alt pic" /><figcaption aria-hidden="true">Alt pic</figcaption></figure><span id="more"></span><h2 id="思路">思路</h2><p>我们先思考我们所需的消融效果是什么样的，需要物体被部分烧毁的痕迹，物体会被烧得镂空，燃烧的边缘有着颜色变化，大体而言就是这样。所以我们只需要利用噪声纹理，对物体表面进行依据透明度的剔除(Clip)来模拟镂空就好，再根据由噪声纹理得到的<strong>透明度</strong>和我们所定义<strong>消融系数</strong>对颜色进行插值就可以模拟边缘烧焦的效果(因为透明度更高的部分被clip了，所以我们这样简单的模拟就能得到很好的效果)。</p><h2 id="word-is-weak-show-me-your-code">Word is weak, show me yourcode</h2><div data-align="center"><img title="" src="https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveMat.png" alt=""></div><center>Shader 面版</center><pre><code class="hljs">Properties      &#123;          _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0          _LineWidth (&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1          _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123; &#125;          _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123; &#125;          _BurnFirstColor (&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)          _BurnSecondColor (&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)          _BurnMap (&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123; &#125;      &#125;</code></pre><p>我们首先需要定义所要用到的消融系数<code>_BurnAmount</code>，控制消融效果边缘宽度的<code>_LineWidth</code>，物体的主纹理、法线纹理、噪声纹理，以及用以模拟烧焦边缘的两个颜色<code>FirstColor</code>,<code>SecondColor</code>……</p><h3 id="pass">Pass</h3><p>然后来看第一个Pass部分，由于我们需要镂空效果所以我们要关闭Cull，来保证背面的片元也被成功渲染，渲染模式设置为普通的前向渲染即可。</p><pre><code class="hljs">Tags &#123;“LightMode” = “ForwardBase”&#125;  Cull Off</code></pre><h3 id="顶点着色器">顶点着色器</h3><p>关于顶点着色器，我们计算好视体空间坐标、所用的纹理坐标、世界坐标及切线下的光线方向，填充v2f即可。</p><pre><code class="hljs">v2f vert(a2v v) &#123;              v2f o;              o.pos = UnityObjectToClipPos(v.vertex);            o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);              o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);              o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);            TANGENT_SPACE_ROTATION;              o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;            TRANSFER_SHADOW(o);            return o;          &#125;</code></pre><p>因为我们使用了法线纹理，所以需要利用切线空间下的光照进行漫反射的计算。</p><h3 id="片元着色器">片元着色器</h3><p>接下来是重点的片元着色器</p><pre><code class="hljs">fixed4 frag(v2f i) : SV_Target &#123;              fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;            clip(burn.r - _BurnAmount);            float3 tangentLightDir = normalize(i.lightDir);              fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));            fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;            fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));            fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);            fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);              burnColor = pow(burnColor, 5);            UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);              fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));            return fixed4(finalColor, 1);          &#125;</code></pre><p>可以看到我们先对噪声纹理进行采样，之后运用clip函数(剔除传入参数小于0的片元)根据纹理结果和我们设置的消融系数来进行片元剔除。</p><p>利用smoothstep函数计算系数t，smoothstep是根据第三个参数对第一、二个参数空间进行平滑过渡，区间左侧为零，右侧为1，区间做过度。</p><p>系数t越大越接近消融部分，越小越远离消融部分，t为0即像素显示正常颜色，t为1表明像素在燃烧边界。</p><p>根据t对FirstColor和SecondColor来进行lerp插值，模拟边缘的烧焦效果，因为“烧毁的部分”已经被clip掉了，所以我们的模拟不用担心透明度大于消融系数的部分。</p><p>同时使用pow函数对burnColor处理，使其更真实。</p><p>再用系数t对光照效果(ambient+diffuse)和烧焦颜色插值，这里使用一个step函数保证我们消融系数为0时，可以正常返回物体本身的颜色。</p><p>到这里其实主要部分已经完成了，不过我们还需要处理阴影，因为我们使用了透明效果，只要涉及到透明效果我们就一定要对阴影十分留意，如果不做处理，阴影还依照原本物体的样子投射阴影那么我们的模拟就穿帮了，这肯定不是我们想看到的，还好利用Unity我们不需要太复杂的处理。</p><h3 id="关于阴影">关于阴影</h3><p>我们需要做的就是把我们在消融模拟时剔除的片元，“真正的剔除”。也就是真的把物体烧了(笑。</p><p>开玩笑的，其实还是依照纹理采样来的透明度在生成阴影的pass剔除对应的片元。</p><p>先设置Pass的渲染模式</p><pre><code class="hljs">Tags &#123; &quot;LightMode&quot;=&quot;ShadowCaster&quot; &#125;</code></pre><h4 id="顶点着色器-1">顶点着色器</h4><p>顶点着色器及v2f结构体</p><pre><code class="hljs">v2f vert(appdata_base v) &#123;                  v2f o;                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);                return o;              &#125;</code></pre><h4 id="片元着色器-1">片元着色器</h4><p>片元着色器</p><pre><code class="hljs">fixed4 frag(v2f i) : SV_Target &#123;                  fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;                clip(burn.r - _BurnAmount);                SHADOW_CASTER_FRAGMENT(i);              &#125;</code></pre><p>clip用法和消融模拟中一样，而V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT是老常客了，投射阴影重点就在于我们需要按照正常模拟那样对片元进行处理(是保留？还是剔除？)，利用Unity提供的这三个老常客我们可以省去很多很多的工作。</p><p>在结构体 v2f 中 V2F_SHADOW CASTER来定义阴影投射需要定义的变量，在顶点着<br />色器中，使用 TRANSFER_SHADOW_ CASTER <em>NORMALOFFSET 来填充V2F_SHADOW</em><br />ASTER在背后声明的变量，这是Unity帮我们完成的。。在片元着<br />色器中，SHADOW_ CASTER_FRAGMENT 来让 Unity为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>注意，在我们使用Unity的内置宏时，我们的命名以及变量使用需要符合Unity的规范，例如，TRANSFER_SHADOW_ CASTER_NORMALOFFSET会使用名称<code>v</code>作为输入结构体，v需要包含顶点位置 v.vertex和顶点法线v.normal，这些变量的appdata_base包含的，而当我们需要顶点动画时，可以在顶点着色器修改vertex，再传递给TRANSFER_SHADOW_CASTER_NORMALOFFSET，这是可以的。</p><p>最后，也可以编写一个脚本根据时间修改Mat的_BurnAmount属性，来模拟基于时间的消融效果。</p><p><a href="https://github.com/HollowEmiya/DissolveShader" target="_blank">代码地址</a></p><p><ahref="https://www.bilibili.com/video/BV1BY4y1i7a8?spm_id_from=333.999.0.0">演示视频</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>思绪之海桶狭间(</title>
    <link href="/2022/04/08/New-Start/"/>
    <url>/2022/04/08/New-Start/</url>
    
    <content type="html"><![CDATA[<h2 id="隔离期间">隔离期间</h2><p>隔离期间搞一个自己的blog。<br />原名<code>New Start</code>，<br />记录一些自己的感悟。</p><span id="more"></span><h2 id="闲言碎语">闲言碎语</h2><p>1、刘明翼和周帆要考研了，杨崇兴过两天就要去实习了，只剩下我在所剩无几的大学时光等待着琐碎破败的人生到来，这个时候我才知道我曾做的一切是多么想暂缓逝而不返的时光，然而残酷的现实是——一切都是徒劳，生活没有什么预兆、也没有什么标识，一切就这么发生了，没有惊天动地的变故，没有振奋人心的庆典，一切都是那么平常，而这平常就是生活最大的残酷。</p><p>一切都随着流水走向着尽头，走向着开始，而我注定和从前一样缅怀在自己卑谬的过去中，难看地呻吟。</p><p>2、年龄越来越大，越能明白有个能畅所欲言的对象是多么可贵，如果这个对象能回应、甚至帮助你那就更为可贵了。有些话有些事只能自己挨着。真羡慕那些什么都能说，肆无忌惮的人，好轻松。不知什么时候开始，彷佛依赖上了内心流血的状态，就像用舌头舔刀刃上的血，明明血不会止住，反而迷恋上血的味道。</p><p>没什么办法，那些面对巨大挫折却仍能坚持下来，没有丧失心智的人原来是这么的强大。</p><blockquote><p>世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。</p></blockquote><p>3、全部是真实的，却是虚假的。</p><p>用虚伪的去描绘最为真实的。我们的现实我们的感受，是虚伪的还是真实的呢？</p><p>是他人的传递，还是萌生于我们的内在呢？我不知道，不管是自己还是他人，不同的真实也许是相同的虚幻，不同的虚幻也可能是相同的真实。我又在什么时候迷失了自己的灵魂呢……</p><blockquote><p>全都是真实的 却是虚假的</p><p>用虚伪去描绘真实的</p><p>用真实去欺骗虚假的</p><p>我们的空洞眼神里</p><p>诡异着 映射着 敏感着</p><p>奇幻色彩的爆炸波</p></blockquote><p>4、明知是熊熊的烈火、不知前路如何，却仍能为了改变现状，为了更好的未来毅然献身，这样的理想主义者值得我们永远歌颂，如此高贵的品格才是人类最为珍贵的。也许有人歌颂英雄只是为了能让自己当个懦夫，但是我相信对英雄的呼唤和歌颂能唤醒这个世界隐藏的光明。</p><p>5、昨天洗澡的时候突然发现自己为什么有屯物癖。小时候家里条件不是很好，每次自己有了新东西都会很开心，可是时间久了东西就会坏掉，我失去我的这些最珍贵的东西时我十分伤心，所以再后来就喜欢“备份”，同样的东西要有很多才会安心，总是怕他们离我而去，慢慢的慢慢的就成了无意识的举动，堆着堆着就成了习惯。也许我不是屯物癖吧，我只是害怕失去的感觉，堆积备份追寻自己的安心。</p><p>6、我从不幻想着自己是特殊的、特别的，我只觉得自己是异常的，另类的。</p><p>7、我不再年轻了，我开始听伍佰，开始知道人生总是充满着不完美，人生就是一个慢慢填满遗憾的过程，我不是在说自己变得成熟，只是觉得有了什么从前从未有过的感受，我不知道这种感受叫做什么，他们都说这叫长大，可是长大真的是这样吗？别人也会和我一样忧愁、抑郁吗？问题会有答案，但那也只是在教材上，生活中大多时候问题是没有答案的。我不知道，我不知道，我不知道。</p><p>8、这个世界这么大，大到没有我的容身之处，而这个世界又是这么的小，小到我都不知道游乐场在哪？也许这个世界就是这样，像快乐套餐里没有快乐一样，荒诞合理。</p><p>9、</p><blockquote><p>前方啊没有方向，身上啊没有了衣裳</p><p>鲜血啊渗出了翅膀，我的眼泪湿透了胸膛</p><p>飞翔着强忍着伤，逃离了猎人的枪</p><p>我的双脚没有了知觉，我的心情下冰冷的雪</p><p>亲爱的母亲挚爱的朋友，我会坚定好好的活</p><p>沉默的大地沉默的天空，红色的血继续的流</p><p>纵然带着永远的伤口，至少我还拥有自由</p><p>飞翔吧飞在天空，用力吹吧无情的风</p><p>我不会害怕也无须懦弱，流浪的路我自己走</p><p>那是种骄傲阳光的洒脱，白云从我脚下掠过</p><p>干枯的身影憔悴的面容，挥着翅膀不再回头</p><p>纵然带着永远的伤口，至少我还拥有自由</p><p>纵然带着永远的伤口，至少我还拥有自由</p><p>至少我还拥有自由，至少我还拥有自由</p><p>呜——</p><p>——《白鸽》伍佰</p></blockquote><p>10、当她看见我没有所谓“餐票”便要阻止我就餐时，我仿佛看到了那个使用粮票、饭票的时代，那时候我们还是可以胜利的，贪婪的投机者和黑心的资本家还没有破坏我们的宝贵成功，我们走在一条崎岖但蓬勃的道路上。</p><p>可是我面前的这一景象和那时已经截然不同了，她口中的那张纸不过同“优惠券”，“代金券”这些促销手段一样，是那些吸血鬼的把戏，一个劣质的谎言罢了，只不过是为了中饱私囊掏空他人腰包所想出来的卑劣的技俩罢了。</p><p>11、你这么费力有什么用，到时候人家不过是领着ta去道个歉认个错，这事情也就罢了。上面松松口，走动走动，也就过去了，上面都松了手，你在底下还能一直死咬着不成？<br />我今天还就和你把话说透了，我倒是要教教你这法是什么法！法就是皇帝的法，就是皇家的法，任你个小芝麻再怎么搅和也休想把这官场给搅得天朗水清。咬到了最后你也只得落一句：“算了，草草结案吧！”</p><p>12、某些所谓顶流，不过是套了个炫丽的虚假的外壳罢了，拿着剥削来的资源卖弄起来，竟也装做出砥柱的样子，不禁令人作呕。就像是马戏团的小丑换了一套滑稽的万圣节戏服罢了，里面装的都是铜臭糜烂。</p><p>13、为什么一定要有什么思想、什么主旨呢？只是看着难道就不可以吗？<br />就只是看着就不能感受到作者传递出来的感情、思想、观念了吗？我一直认为人心是十分奇妙的东西，是强大的东西，我觉得就像这样看着他的感受也能传递给我，在潜移默化地影响我。只是单纯地看着就不可以的话，是我们太小瞧了这副作品，还是太小瞧了人心。</p><p>14、我一直觉得土地很神奇，春种秋收。播下种子挥洒汗水，在种地种菜的过程中憧憬着未来，憧憬着美好的明天，用自己的劳动换取美好的生活，切身感受自然的奇迹，在这个过程中自我彷佛得到了救赎。<br />人终归是自然的一份子，在这个种菜劳作的过程中，也许也是我们追根溯源，回归自然的一个过程。作为自然的一员，这种回归的过程带给我们慰藉和安逸，让我得到身心的放松，道教认为小孩子生下来是最完美的，先天之气完足，没有尘世的侵扰，我认为某种程度也是一种我们人类最贴近自然的状态，神完气足和自然融为一体，和自然同在，感受美妙的世界，体悟生命的奇迹，让我们能够放下世俗的争扰，去追寻自己真正的内心。<br /><em>对了，黄瓜和苦瓜别种在一起，会串花粉，黄瓜会变苦的。</em></p><p>15、我很喜欢给事物带来终结，或者说是去感悟事情的结束，因为我从小时候见到的一切，他们的结尾总是那么令人铭记于心、痛彻心扉，这样看来，结束彷佛是一件美好的事，可是真的是这样吗？是结束太过痛彻心扉，刻在了心上，造成了一种感情的涟漪让我感动，还是结束真的是一件很美好，值得铭记的事情？也许这两种都是一样的吧。<br />思来想去我只能说我不知道，彷佛生活不知从什么时候开始就变得很复杂，什么东西我都搞不太懂，也许复杂的不只是生活，或者说复杂的根本不是生活，复杂的是我。也许生活本来是很简单的，只是我太复杂了，所以把生活搞得也复杂了。诶，又或者说，生活很复杂，然后我被生活搞得很复杂……你看很复杂吧，我完全搞不懂。我不知道诶。</p><blockquote><p>所有年轻人，年轻人，年轻人，问题出现我再告诉大家！</p></blockquote><p>16、明知是假的却只能依赖，因为不这么做便活不下去。<br />或许人类注定是悲哀的生物，但是悲哀的命运也不妨碍我们去追寻美，去创造美。<br />即便是悲惨的命运也能创造出无比美丽的生物。</p><p>17、言语稚嫩，文笔不成熟又怎样呢？心中这份感情可是货真价实的，不把这么美妙宝贵的情感写下来的话，不是可惜了吗？是自己的可惜，也是全人类的可惜哦~<br />用自己的语言，文字记录自己的情感，没什么好难为情的，这是一件无比浪漫，足够引以为傲的事情。因为稚嫩的记述本身就是动人的。</p><p>18、</p><blockquote><p>逃げちゃ駄目だ，逃げちゃ駄目だ，逃げちゃ駄目だ。</p></blockquote><p>19、<ruby>燃烧了…<span class="template-ruby-hidden"></span><rt><spanlang="ja">燃えたよ…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>直至雪白……<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">まっ白に…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>已经燃烧殆尽了…<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">燃えつきた…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>只剩下雪白的灰……<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">まっ白な灰に……</span></rt></ruby></p><blockquote><p><ruby>燃烧了…<span class="template-ruby-hidden"></span><rt><spanlang="ja">燃えたよ…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>直至雪白……<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">まっ白に…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>已经燃烧殆尽了…<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">燃えつきた…</span></rt><spanclass="template-ruby-hidden"></span></ruby><ruby>只剩下雪白的灰……<spanclass="template-ruby-hidden"></span><rt><spanlang="ja">まっ白な灰に……</span></rt></ruby></p></blockquote><p>20、挽救烂尾的方式之一：播放结尾的时候配上最悲情、悲壮的音乐，不时穿插之前的回忆，人物不要发出声音，声音只放bgm就行，<del>最后来个意识流从天空俯瞰，所有人围着主角，然后突然黑掉屏幕，赫然打上几个大字：“全剧终”</del>。</p><p>21、最宝贵的情感只属于自己，若是有人能感怀一二对于自身来说便是极大的幸福了，很少有人去体悟别人的感情，自己的感情终究是属于自己的，他人不会关心，纵是共情，也是他人的悸动。</p><p>22、不深入涡流直面深渊，便没有评价的资本。</p><blockquote><p>没有调查就没有发言权</p></blockquote><p>23、没有能力的勇敢就是鲁莽，自己没有能力就什么都保护不了。</p><p>24、后来我才知道你也和我听一样的歌，我们也都一样，曾一样愤懑，曾一样踌躇，我不知道是什么样的原因，不知道是默契还是缘分，还是同样的时代背景，家庭环境？不，你应该过得比我好，一定要比我优渥。我很想浪漫的说，你我的相同是命运的馈赠，是千古最长情的缘分，可是也许这份共同是这个时代带给我们每个人的。<br />珈乐和焰火青年。</p><p>25、我突然明白了，我的心上已经有了口子，虽然会愈合，但是随着悸动，它的伤口会崩开、流出血来，想要止住血只能拿新的伤痛插在上面，可是这么一插血是止住了，也造就了新的创口。</p><p>26、其实张之铭每次晾内裤都会踩着杨崇兴的凳子，放心是脱了鞋的，这样的小恶作剧对于张之铭来说也算是一种乐趣，可是杨崇兴去实习了，张之铭再也没踩过那张凳子，也许是因为那个人走了就不再回来，也可能是因为那个人把在寝室剪头用来围脖子的破布放在了凳子上，张之铭怕脚沾上头发茬子。</p><p>27、网络浪潮有最迅猛的两个时候，一个是ta诞生的时候，另一个就是ta死的时候。</p><p>28、当我们欣赏过去的经典追忆过去时，是不是在追寻着眼中那个人的步履。聆听过去，也是追寻过去，体悟过去。</p><p>29、其实无私的爱是无比宝贵的，是可遇而不可求的，可是因为我们大多数人出生便得到了父母无私的、厚重的、广阔的爱，导致我们以为这种爱是常见的，乃至更有甚者认为是没有价值的。<br />等我长大与人接触后，才发现没有人爱我自己，曾经“最廉价”的爱居然是那么昂贵的。对周遭急切的期待，往往迎来的都是冰冷的“款待”。爱是一种可贵的能力，是一种宝贵的体验，无论是给予爱还是获得爱，我们所需要的第一件事就是爱自己。<br />希望所有人都能自爱自重，希望所有人都能收获爱，也希望所有人也有余力去爱。</p><p>30、</p><blockquote><p>天下风云出我辈，一入江湖岁月催。<br />皇图霸业谈笑中，不胜人生一场醉。</p><p>提剑跨骑挥鬼雨，白骨如山鸟惊飞。</p><p>尘世如潮人如水，只叹江湖几人回。</p><p>英雄路远掌声近，莫问苍生问星辰。</p><p>天路有涯风有信，大海无量不见人。</p></blockquote><blockquote><p>本来无一物 何处惹尘埃</p></blockquote><p>31、语言真是有意思，如果你直接说"不明白"，"看不懂"，"不知道"，人们可能不以为意，但是如果你说"真有深度"，不仅能欺骗自己，还能蛊惑他人，何乐而不为。<br />可是这种行事我终是觉得厌恶，而自己却不知意地做了，故而我也常常厌恶我自己。<br />这追慕虚荣的卑劣，就刻在了我们每个人的身子里，我厌恶我自己。</p><p>32、现在我才明白了，原来他是对的，真实竟然如此不堪，满是令人作呕，卑劣才是通性，高尚终是凤毛麟角。</p><blockquote><p>因为我们不知道，所以错过了晚霞、潮汐和海浪。</p></blockquote><blockquote><p>你的实力是货真价实的，我南部赝作可以保证，这次绝不是虚张声势。</p></blockquote><p>33、朋友的猫，吃了被老鼠药毒的老鼠中毒了，打了两针，现在情况也不到怎么样，那时只看见它趴伏在水泥地上，耷拉着头，也不理人，身上的毛脏脏的、有几根毛毛涔涔地立出来，它小巧的脚背上沾粘着灰色的土，水泥地有些年头了，上面裂开了几道七扭八歪的缝，缝里藏着红色的砖。不知道，明天还能不能再见到这只猫。<br />也许被耗子药毒死的猫并不少见，这也不是第一只、也许也不会是最后一只，但可能是朋友的最后一只。就同那些那些被冲垮的村落一样，也不是第一个也可能不是最后一个，但却是我们的最后一个。<br /><em>面对现代城市化的冲击，传统的小农经济不断遭受着挤压，那些用尽被碾压着的最后一丝气息给我留下美好回忆的乡村时光，已经是很久之前的记忆了，我不知道该说什么来表达这种感情，也不知道能做什么挽回点东西来宽慰自己，我只能像朋友那样打了两针，和猫一起坐在老旧的水泥地上，让阳光不舍地洒下一点夕阳，剩下的便只有孤独的陪伴。</em><br /><del><em>这段话就是我给自己打的针，我就是那只猫。描写水泥地也是描写猫，不过我真的很担心朋友的猫怎么样了，希望猫没事🙏。表达对猫的缅怀，和城农冲突的无奈，对美好生活的思念，对农田生活的向往。</em></del></p><p>34、这个世界真神奇，一方面游戏行业寒冬、版号缩水，另一方面国内经济情况低迷、人们消费意愿降低，国内厂商纷纷开源节流，而人才市场的竞争反而愈演愈烈，世界真魔幻啊，今年失业的恐怕是我。</p><p>35、时代的沙砾那么大，他却想爱每一个人。为什么我想做游戏，因为在我最难过的时候，是空洞骑士带给我了唯一的快乐，我不是想煽情的说，是他给了我活下去的勇气巴拉巴拉的，事实上我也没有勇敢的活下去，也没有变成优秀的大人，我还是和以前一样失去很多，依旧悲伤，但是它带给我的那些快乐是那么的深刻，再后来我玩旷野之息时，我再次体会到了这样的美好，在一个新的世界了，奇妙、自由没有烦恼，只有快乐。世界那么大，我却想爱每一个人，因为当初的我没有人爱。<br />之前爽鸭看到米的惊呼，我不以为意只觉得好笑，如今我望向米，发出“我超，米！”的惊叹，更甚于爽鸭。只觉得人生的悲哀罢了。</p><p>36、朋友的猫还活着，毛还是一样脏兮兮的，躺在混乱的电子设备堆里，嘴巴对着麦克风，朋友一直有一个歌手的梦，猫猫还活着我不知道为什么我会很开心，明明我的梦是那么遥远。</p><p>37、人生就是一个不断发现自己，认识自己，超脱自己，和解自己的过程，希望大家都能找到实现自我价值的方式和平台，满足自己的内心需求，活出只属于自己的人生，哪怕它没有那么缤纷多彩。</p><p>38、人生难免有遗憾，但是不要……不要……不要太多吧。<br />不是你的问题，是时间。时间就像深海，我们每个人都只能在中慢慢浮沉，无能为力。<br />时间是没有办法停止的，我们只能往下走了。<br />感情是人类最大的累赘，肉体是飞升的负担。<br />但真挚的情感总是可贵，令人动容。感情无法被人为模拟复现，真挚而可贵，也许正是这奇妙的心拥有超脱一切的力量。</p><p>39、我再也不看v了，原来我一直追寻虚假的过程只不过是寻找自己的投影，我在虚拟的身上几近疯狂地寻找真实的证明哪怕没有表表征，我的内心却是这样追寻的，我在人造的虚拟背后看到一丝真实的投影便自我感动地落泪，原来我是这般的不堪，我再也不看v了，我，再也不看v了。</p><p>40、如果不能在璀璨的烈焰中死去，便在无波的颓唐中磨平了一生。</p><p>41、如何创造一个悲剧——在路边抓来一个路人。</p><p>42、忽然发现自己什么都不会，成为了社会废人。</p><p>43、如果一个人不能得到生的光辉，便会理所应当地追求死的慷慨。</p><p>44、每当我体会到生的美妙，都会下意识的痛彻死的悲痛，因为我知道那些美妙终是虚幻的、终是离我遥远的是我无法触及的。</p><p>45、愈是压抑沉闷的今照，才能愈发凸显阴云散去、万里晴空的激动；在无数苦闷坚守的日夜后，迎来的朝阳更加痛彻心扉。<br />人被生活的枷锁所桎梏，在挫败与困顿中抗争，于失意绝望后而觉醒，坚韧的人性之光方显弥足珍贵。<br />“与天斗，其乐无穷。”</p><p>46、原以为最辉煌的日子是未来，没想到竟是毫无建树的过去，宛如雨后的积水只能映出一点赛博的霓虹，根本无法与日月争辉。又是入夜只留我暗自唔泣，待到朝阳氲氤被叶尖的露珠顶替。</p><p>47、我不是三峡好人，也游不到海水变蓝，我只是小武在站台上用一个桶所装载的忧愁。</p><p>48、22/10/13，在如此严峻的秋招环境中，有的人收获米哈游和网易雷火的offer，而有的人还在失业，我却一心只想摆烂当个废物，事实上我也完成了我成了一个只会摆烂自怨自艾的废物。<br />49、22/10/14，库洛测试题做的一塌糊涂，根本比不过别人，所以我选择摆烂了，技不如人，菜的自己想哭了，突然发现以前别人开的玩笑可能是真的，自己真的一点技术含量都没有。<br />50、22/10/16 18:21如果能够死得壮烈我一定不会犹豫因为生命已经让我没有了欢愉，但我却不敢结束一切，因为我懦弱到了只想死去。<br />我不知道自己什么时候死了，我也不知道自己活了多久，只能记得如弥留之际看到他人的痛彻自己竟也受了感动，连一个死人都扮演不好，也许最终归宿也找寻不到了吧。<br />51、22/10/16 18:38如果我死了请不要为我悲伤，用礼炮为我欢呼；如果我死了请不要怀念我，我的一生毫无建树；如果我死了请不要为我歌唱，因为我是生活的败者；如果我死了请不要为我激动，因为我是空中虚无；如果我死了请把我忘记，因为我已经离去。<br />52、22/10/16 18:38我一直都是生活的失败者，做着不切实际的美梦立下旖旎的目标麻痹自己，现在秋天过半，寒冬踏着欢歌来到，朝露褪去夕阳沉沦，夜带着星光皎洁，我的梦也该醒了，早已枯死的花是时候凋落。<br />53、22/10/16 18:42我还记得欢乐的感觉，沐浴在阳光里的温暖，但我未来马上就会将他们遗忘，曾经我体悟到的欢乐以后再也没有了，想到这在看见那阳光动人的笑脸，我的十指就刺痛了起来，原来快乐也会给人悲伤。<br />54、把狂妄无知当作清醒，把诡辩欺诈当作真理，拉帮结派狐假虎威狗仗人势，有什么可夸耀的，简直令人恶心至极。<br />55、如果不能在平静的海面上，补到伏在水底的鱼，便会寄予希望于疯狂的海啸，哪怕这灾难将会把自己席卷，破灭而来的希望也比枯死的等待更靓丽的多。</p><p>56、后来张之铭留在了平昌，他和以前一样早上会去书店门前的大树下看落叶，只是从此以后与他为伴的唯有晨朝的寒气，他就这样在那里等着，在秋季的冷风中。<br />57、我曾经的朋友已经许久未见，今日方得知原来她早就去了美国，群里的大佬知识技术也十分雄厚都有了不错的工作，有的人去了米哈游，有的人去了鹰角，看到他们我无比的羡慕，那是我曾憧憬的生活。但我的水平与他们差得太远，只知道自己差的多了，不会的多了……不知道心里这种感受是什么，也许是落寞吧。<br />58、每个人都喜欢酷姐姐，就像每个人都喜欢死亡。<br />59、如果爱就不要接近选择离开，爱和生活虽然都很难，但生活不是爱，爱也不是生活。<br />60、好冷啊，原来已经是冬天了吗？<br />我原以为我可以熬过这个冬天，但是素色的和服我终究没有收到，我想我应该不会活到夏季了。<br />61、安逸只能带来晨昏的死寂，而唯有痛彻方能焕发振奋的创作。<br />62、成长就是学会遗憾。</p><p>63、深情的缠绵尤为沉痛，人生的豁达也同样可贵，有的人死去却被人们怀念在心中，人生的感动永远留在民族的心中，作为我们共同的回忆。<br />64、世人多叹英雄迟暮，丈夫壮志难酬。惜少年踌躇，豪杰壮志，最后时过境迁物是人非，天下不定，生而不能如愿，如何不叹？<br />“死后葬于城北！”<br />“朕不能为弟报仇，虽有万里江山，何足为贵？”<br />“悠悠苍天何薄于我！”</p><p>65、发现自己找工作就像段誉和王语嫣聊天，王语嫣只想表哥，段誉却痴痴地想着王语嫣，面试官想要顶级人才，我却妄想一个工作机会，“我这辈子要是能一直哄着你开心就知足了”，我要是有一份工作就知足了。"我不喜欢和轻浮的人交朋友"，你好像不太适合这个岗位。<br />66、鸠摩智这个角色真是颇有佛缘，身为大轮明王通晓佛法道理，又有一身的武学修为，受人"指点"千里迢迢来到大理，段誉授其逆练心法，不曾想竟能成功练成少泽剑。<br />67、想不出活下去的理由，眼前所见都是赶快死去的事实。人生的旅途还未开始便受了一身的病，理想尚未起步，行业的寒冬就已经到来，千疮百孔的心智，学艺不精技不如人，残存的人生仿佛一眼就望到了头，我失去了活下去的理由，只能想到死的绝望，因为我是最软弱无能的妖怪。<br />68、GenShin上ys没什么好评价的，都说烂了，鸡场加堵场。从米看前有画月发家史，再有前车之鉴绷绷绷，从羊看前有尼、谷、丁，尼古丁，还有人搞什么“两岸猿声啼不住，轻舟已过万重山”，只有你是高贵的，狭隘的闵翠主义，”不识庐山真面目，只猿身在此山中“。<br />69、tnnd，都tm的怪段正淳！cao！<br />70、他人入我门，善果非常，我门破戒悔，罪无可恕。<br />71、打扰一个人的美梦残忍，还是让他沉沦其中残忍，我分不清。<br />72、每次看到那么奢华富贵的生活，我都在怀疑我是在革命前还是革命后，有时候再看几期牛事，我便更分不清了。<br />73、怎么样才能活下去啊。<br />74、我的人生这么funny，我是不是应该去做喜剧演员。<br />75、<em>西湖好，西湖好，九州百姓乐眉梢。群妖伏，魔首逃，九州春风万处飘，壮志凌云鲲鹏鸟，鲲鹏鸟。万圣好，万圣好，万圣明鉴平病灶。除岁炮，春来到，呕心沥血谱功劳。万圣锦旗昭，神州土木牢，土木牢。</em><br />76、死亡对我来讲也许真的是甜蜜的，但却会有人因为这份甜蜜而伤心，所以我也失去了品尝这甜蜜的勇气。<br />77、回头看了看自己之前写的所谓感悟，原来我也思考过，也有那么一点有趣，我究竟是如何变成现在这个样子的啊。人都盲目地走在自以为正确的道路上越走越远，越走越远，直到找不到自己。<br />78、事到如今才明白我真正擅长的事啊，我既不聪明也不灵活，我所擅长的只有<strong>逃避</strong>罢了，一味的逃啊，逃啊，从现实逃向虚拟，又从虚拟逃向二者的夹缝之中，我就想躲在阴暗夹层的老鼠，只能窥视微弱的光，没有出去战斗的勇气，因为逃避是我最擅长的。<br />79、你为什么监视我？还是我们本来就都一样，在坠向地面的短暂一生中不甘着，渴望超脱。</p><p>80、事实比故事更荒诞，因为不仅真实还伤人，就在你我每一个人的身边。</p><blockquote><p>前段时间在公园跑完步，看见有一个妈妈带着她的女儿在卖一些便宜的东西，我在她摊子上买了一个钥匙坠，她的女儿大约6-7岁左右，穿着粉红色的棉服，挺可爱的也不怕人。我随后坐在了旁边休息顺便刷抖音，小姑娘看见了就站我后面一起看，我也没在意。抖音视频有一条狗吃各种比较贵的食物。休息一会我准备回家，我听见小妹妹问她妈妈:妈妈，我想当一只狗狗。她妈问:为什么啊，琴琴(是这个读音，不确定字）小姑娘说:当狗狗可以每天吃肉啊，还有零食吃，我看大哥哥手机上的狗狗是这样的，我也想当那样的狗狗。她妈没有接话，只是伸出手扶正了小女孩的蝴蝶结。</p></blockquote><p>b站狗吃奢华大餐：BV15E411P7Pz<br />我能理解宠物主人有给宠物吃各种各样东西的权力，但是我不甘和愤怒的是这背后更深层次的悲哀，在这荒诞视频的背后是阶级矛盾，是资产阶级对无产阶级的压迫，他们用无产者的辛苦劳动去喂养低贱的畜生，而我们的人民，我们的劳苦大众每天过着艰难的生活，甚至不如那吸血鬼所圈养的一条狗！牢记阶级苦！当阿廖莎再吃二遍苦受二茬罪时，他们会在父亲的大树下想起他曾经的教诲，那是无产者定会胜利，因为不胜利就会像今天一样迈向死亡，而死亡不属于无产者。</p><p>81、我感性时常落泪，有人也说我软弱或许吧，但是我的内心却实打实的痛到流出鲜红的泪。<br />82、你是要成为只会哀叹的懦夫，还是向生活奋起反击的勇者？<br />不畏艰险、不怕牺牲，敢于奉献的探索者精神和只会隅泣的逃兵哪个更值得歌颂。<br />我知道你饱受委屈和折磨，怕血肉模糊的心智再受折磨，可是逃避不能解决问题，愈合的肱骨才会更硬，羊啃食过的青草才会分蘖。<br />83、母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡。    ——施耐庵<br />84、原来荒诞的才是现实，文学作品只是借用。<br />85、我不会拥有 [Happy End] 了，我的路途结束了，[Bad End] 就是我的 [LastEnd]，也是我的 [TrueEnd]。这个世界太糟糕了，我恨透他了，但是我最恨的是我自己，因为我只有[Bad End]。<br />86、如果没有人关心我，我说出去的话又有谁懂呢？既然我说出去的话没有人懂，又怎么会有人关心我。<br />87、“虚伪”登堂入室，”真诚“嗤笑失意，这个世界已经不适合我了。<br />88、"丐帮有多少弟子不是我说了算，是您说了算。如果您真的英明神武，又有谁愿意当乞丐。"<br />89、我想回到过去，因为我能看见那些曾给我带来快乐的东西，曾让我温暖的东西，而未来却是黑漆漆的看不见的冰冷，至于现在……我在想过去。<br />90、</p><blockquote><p>我明明没有喝酒，眼睛里却流出了酒。一想到大叔在某个地方从眼睛里流出酒来，酒就从我的眼睛里流个不停。</p><p>他明明没有喝酒，酒却从眼里流了出来。</p><p>嗯，我一直都知道的，MADAO早就开花了。</p><p>MADAO是抛弃了一切英雄色彩的武士，却在每次人生的关键选择上，做出了最英雄主义的抉择<br />MADAO其实早就已经开花了</p></blockquote><p>91、我们每个人都是一座孤岛，只是恰巧在同一片海，被阳光映上彼此的影子。<br />92、我是一棵树，一棵树先生一样的树，所以我的根要向下，到那广袤深沉的泥土里去，作他们的一员。<br />93、中国太大了，大到里面装了好几个世界。<br />——神功盖世的吕大侠，源自b站视频<ahref="https://www.bilibili.com/video/BV1cM411w7D9">《被挂上热搜的“第一次吃华莱士”，背后藏着最残酷的底层之痛》</a>评论<br />94、他们是聪明人装糊涂，你以为他不知道？他只不知道咱们过得苦！他只知道怎么去骗我们，却装作不会骗我们的糊涂样子，根本不关心人民的死活。<br />95、<br />每年都有好建议，每年都没见落实，只有一天天变瘦的荷包，和一天天饿瘪的肚子，一天天萎靡的精神<br />一天天疲倦的身体，铸成城市梦幻的霓虹，用我们炽热的青春和血液，灌溉黑色的混凝土，发出耀眼的光<br />又到了夜晚，我很是不安，曾有这样无数的夜，我难以入睡，我一无所长却疲惫不堪，每时每刻都深陷不安。<br />96、看来是找不到工作了，不是被嫌弃菜，就是嫌弃没实习，要么就嫌弃没经验，还没开始就走到头了，人生已经肉眼可见的结束了。<br />97、23届的我最合适的结局竟是横死街头，在时间的长河中没人会在意我，前面有21，22的，后面有24的，只死我一个23的弱爆菜鸡，对这个世界也没有什么影响，时间根本不会在乎，没人关心我这具死在路边的尸体。<br />98、只是我一个人的寒冬罢了，我在广袤的狭小天地之间，踏着笨拙的舞步，雪花一片片排在我的身上，在温暖的春天里把我埋在最美丽的寒冬里，我能感受到他们携带着我的温暖向安逸的天堂飞去，我就在这只属于我一个人的寒冬中笨拙的挣扎，这是世界留给我最后的温柔。<br />99、我知道为什么我一直在寻找自己的影子了，我在同情自己投影的时候，是在可怜自己，我所有的悲痛欢喜愤懑都是为自己，我才发现原来自己是这样一个自私的人。<br />100、有时候真想毁灭啊，因为我所拥有的便是这一点仅存的名叫生命的能量，利用这微弱的力量绽放出不起眼的火花可能是我最大的成就了，但是我却缺少爆炸的勇气，因为我只是个胆小鬼罢了。<br />101、我目前最大的成就就是有关爱我的父母，我最大的罪恶就是没有回报他们。<br />102、不会解决问题只会喊人填表，要是填表就能实现共产主义，那东北大学在新时代就又一次成为革命领袖了，傻屄。<br />从根本上就不关心学生，只想着把自己那点破数据做得好看些，不能切实地帮助学生解决就业问题，那就恳请您别来浪费我的时间，肏你妈的，臭傻屄。<br />不仅浪费普通学生时间，还特么浪费学生干部的时间，臭傻屄。<br />只针对傻屄措施，不针对人，只针对形式主义，只针对情报特科，本人傻屄大龄愤青，脾气暴躁，思想极端。<br />103、“我只能看到一片黑暗，还有老大姐的背景。”杀哥这样说道，背景中是他常用的那首音乐，以往一样哀伤的旋律，竟格外的有诗意，杀哥躺下睡了，明天他还要去那片黑暗里探索生活，而我也一样只不过我看着这黑暗有些许难眠。<br />104、才发现自己C++不会，计组没学，计网没学，操作系统没学，图形学也不会。<br />我大学的四年究竟干了什么，为什么我什么都不会啊。<br />自己学了四年计算机什么都不会。<br />105、我还记得那天是小雨的天气，外面的乌云浮在天上，遮掩着太阳，他很轻松地说道：“我悟了，元凯，我得道了。”，说完他就转身走了，我只看见雨淅淅沥沥地落在他的肩上，后来我也离了道观，就再也没见过他，我至今也不知道他悟到了什么。<br />106、现在是2023/3/11原来罪恶王冠都已经是12年前的作品了，现在的二次元和那时的二次元已经有了天差地别的变化，我还是觉得那时候好，那时候的二次元给人一种独立、探索、思考的感觉、很有生命力比较干净，那时候总是有天马行空的幻想虽然很幼稚但是令人沉醉，如今大部分给我的感觉只是沉浸在娱乐里，我不能说哪种的好坏，因为我是带着滤镜去看过去，只能说我怀念那个时代，那个每部作品都个性分明、独有新意百花齐放的年代，如今的圈子虽然大了，但是我却再也找不到当年的味道了，也很少看新番了，偶尔想翻出过去的番剧看一看，也许我们这些老二次元都已经被生活压弯了腰，面对曾经的热爱已经没有多少力气去燃烧自己的生命，只能看着过去的背影映在夕阳橙红色的阳光里给自己一点安慰。<br />二次元变了，它变得不再是那个二次元了，二次元变了，它变得还是那个二次元。<br />二次元变了，他变得不再是那个二次元了，二次元变了，他变得还是那个二次元。<br />107、我看见棒棒拉了满满一摞的货，比快递三轮车的小仓库都大上一圈，但是他还是跨过公路，向左拉去了，他脸上没有什么情绪，只是一个普通的辛苦工人，日复一日的努力让他对生活的热情和未来的向往都消耗的差不多了，而迎着他开过去一辆不知道什么牌子的豪车。<br />108、为什么别人那么牛而我这么菜，nmd，地球怎么不爆炸。<br />109、“听丁大哥说啊，离咱们这一百多里地就是共产党，这个党啊，是我们工人自己的党，领袖是毛主席，领着好几百万大兵啊，叫解放军，只要他们到咱们这来啊，咱们的苦日子就熬到头了。”<br />一百多里地好远啊，一百多年好近啊，丁大哥，我上了当，我走错了。<br />110、npy问你什么时候跟她回家见家长，你不敢搭话，她说今天的鸡蛋又涨了，你摸了摸兜里的20块钱，皱巴巴的，全是汗渍，你鼓起勇气“我这还有20”，她却说“你拿着吧，吃点好的，在外面干活不容易。”<br />你吃完了饭感觉很难受，晚上你做了梦，梦里你有车有房，让辛苦了一辈子的父母过上了好日子。<br />111、等鸡长大，就变成了俄，等饿长大了就变成了洋，羊长大了就变成了new，牛鬼蛇神长大了啊，就……只有天知道了。<br />112、我是一块残留热血的肉贴在这钢铁、混凝土的树林，用热血和生命去浇筑，待到冷却、待到麻木，在树林中做最后的飞翔，却因桎梏太久只能坠落。他是一块残留热血的肉……<br />113、我要用的文字做一把利刃，像这个冷酷无情的世界奋力反击！哪怕我摔得粉碎，动作可笑滑稽，我也无所畏惧，因为即便我一败涂地，至少我拼劲全力愤怒过、燃烧过、绽放过，纵使这一切没那么绚烂美丽，但这也是我对这个无情宇宙的最大反叛。<br /><ahref="https://www.bilibili.com/video/BV1HN411F7KV">失业死宅日记</a>，<ahref="https://acg.tv/sm11365022">n站原本视频</a><br />世界是以混沌残忍著称的混蛋，他用利刃把所有的敏感温柔全部搅碎，残酷麻木附着在刃上随着他的死亡之舞做着旋转，所有人在这疯狂的舞步中要么麻木、要么沉沦、要么受伤，然而即便随着他起舞最后也会和遍体鳞伤。他就像一只贪婪的野兽，舔舐鲜血痛苦为乐，也有天才的幸运儿站在中心绚丽的起舞，但那不是我，我只是一个被搅碎的、被蹂躏的发出悲鸣的懦弱的人。<br />每一个对抗生活的人都是勇敢的战士，即便普通却不意味着他们平凡，平凡是扎向他们的武器，在这场和自我、和世界的无尽对抗之中，踏上战场已经是一种荣耀。<br />114、明明判决的是违法者被绳之以法，可最后回头看来，却是一桩桩由人性深处的幽暗引起的惨案和悲剧。<br />115、以前我不知道为什么有人会觉得动漫角色是活的，我虽然很喜欢动漫，但是我应该只是觉得故事有趣，角色丰满，画面美丽等等，我应该是知道那些只是假的，是文学创作，直到今天听到ai阿尔托莉雅翻唱的富士山下，我真的获得了来自动漫角色安慰，我突然觉得她真的活过来了，就在我身边。<br />116、“别以为父母和钱和年轻和房间和T恤和我和你和银魂动画永远都有”——空知英秋<br />117、<br />“tmd“<br />”好像把人全杀光了啊“<br />”但我没本事只能杀我自己啊“<br />”我好像真的不正常了“<br />”是因为周一吗？“<br />”要是能永远都是万圣节就好了，这样大家都会以为我在Cosplay了“<br />118、像你们这种人中龙凤，英才豪杰自然是体会不到我等平平之辈的痛苦的。<br />119、我病了，我患了一种怪病，在这个冰冷的混凝土的世界里，在这个现实和虚幻边界愈渐模糊的时代，我渴望温暖，怀念过去，时光在一声声的排风中逃走了，我的思绪不知在哪里，我病了，我患上了一种奇怪的病。<br />120、我只是一个普通的人，一个再普通不过的普通人，我和你一样过着普通的生活，或者你比我艰难得多，或优渥得多，但我是像千千万万个这样的我一样平凡而普通的人，我只想用我自己的汗水让父母过上好的生活，我只想实现那仅存的支撑我活下去的所谓人生理想，我和千千万万的我一样是一个普通的人。<br />121、我这几天要动用我全部的思绪把他们都写下来，因为我马上就会离开这个世界，这是我能留给这个世界最后的东西，也是我能留下的唯一的痕迹了，但是在这个信息如海般的世界，我的文字只是空中微末的尘埃，后来的人啊不要像我一样，要努力地学习，要勇敢地去生活，去解放我们哪些还在遭受苦难和压迫、剥削的兄弟姐妹，不过这一天我终是看不见了，我要把我的肉体埋葬在一片鸟语花香的地方，这是我能想到的唯一的美好，我要把我悲哀的思绪带离这人世，若这世界上有我这样的悲哀那就只让他在我一个人身上发生就够了，我悲哀的灵魂我低劣的思想把我的人生带入了一场不能回头的悲剧，熟悉的陌生人啊不要重蹈我故事的覆辙，把我作为你的反面教材勇敢的前进下去吧。<br />122、刚才突发奇想的最喜欢的音乐制作人应该是<ahref="https://zh.moegirl.org.cn/%E6%A2%B6%E6%B5%A6%E7%94%B1%E8%AE%B0">梶浦由记</a>老师，啊，每次听到《晓之车》总是很感动，内心深处的某些东西被触动着，这样的歌实在是太优美了，有着很强的力量能够直击听众的内心，仿佛是只有在天上才能听到的，用中国话来说就是，“此曲只应天上有，人间能得几回闻”，这句话出自唐朝诗人杜甫的古诗作品《赠花卿》，那也是一首很美的诗。<br />123、没有神仙救世主，同志们我们只能靠自己！<br />124、重读《范进中举》有感，范进回到家只有挨饿多日、瘦骨嶙峋的母亲，母亲让他变卖了家里仅存的下蛋的母鸡，范进走上集市去买鸡，却被这社会又毒打了一顿，他倚在墙边，拖着满是伤痕的身体困倦了，恍惚中他看见有人对他说他中了举人，在这场举人梦里他发了疯，周围的人也发了疯，我也发了疯。<br />125、当阿廖莎在生产队的枯树下，吃二茬苦遭二茬罪时，会拾起他的思想，我们会找到一口井，他们当时就是在那样一口井边出发的，这口井会在各个地方涌现，这场征途我们只能靠自己，而且过程必然是残酷的，是要流血的，注定是不温和的，纵观过去温和的结果往往是招来团队的毁灭。我们是不怕斗争的，是不怕死亡的，我们是一定要胜利的。<br />126、别人一张嘴就是ssp，年薪百万，轻松的工作，优秀的同事，优渥的工作环境，充满前景的发展空间，而我只是想找一份游戏行业的工作养活自己，减轻父母的负担，我错在哪里，我不知道。<br />127、《西游记后传》还是不错的，《西游记》讲了一直发生的事而且很隐晦，其文学价值无需多言，而后传虽然通俗一些，但是讲的现在的过去发生的事，那时候的事都不提也看不清，但是他却讲了这么一个事，看起来很有意思，当然导演本人肯定没有这个想法我只是自己看着自己瞎想好玩。<br />128、鲁迅真的好厉害，他活在那么久之前，却清清楚楚地看清了我的样子，把我的现况，作为往事一篇篇写下。<br />129、人们不关心我，他们只在乎自己，他们凑过来不过是因为我的悲鸣比较可笑，他们只想听一声沉重的闷响然后在发表一些感动自我的深思，这之后人们就再也想不起来了，仿佛这一声闷响从未发生过，他们又等下一声闷响去了，却不知下一声闷响可能就是自己。<br />130、我像一首不符合时代旋律的歌，在时代的合奏中我的旋律格外刺耳，充斥着违和感和不协调。我融不进这美丽的时代，我在他们的映衬下是一首悲伤的歌。<br />131、怀着满腔热血想进入游戏行业，还没跨出半步就被这寒冬冻死，我像一块受了潮的木头，内外都感到刺骨，只希望我在最后能发出一点微弱的热量给这口炉子增添一点温度，此后便没有了我这块薪柴。<br />132、短评浅析<ahref="https://www.bilibili.com/video/BV1Vm4y167AC/">小岗同学葬礼</a>人未死去给自己办了一场告别仪式，我觉得还是挺有艺术气息的，人的内心深处都有着死亡的冲动，他用一种积极快乐的方式去向过去、向自我发起一场单方面的告别，因为这场和过去自己的告别是无疾而终的，从事实而言是无法达到的，从心理上讲是一种自我的分割。他用这样一种方式对自己发起反叛，对社会的固有认知发起一场属于自己的浪漫冲锋，他用众目睽睽向世界宣布过去死亡的宣言，然后让自己能够向着未来发起一场新的冲锋。<br />133、我恨人类，所以我挥刀向自己砍去。<br />134、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />135、有的人是真的逆天，就像我朋友说的“铁拳没砸到自己头上觉得自己挺能耐”，能说出比“何不食肉糜”还逆天的话，古人诚不欺我也。自己站在风口上便以为自己是时代的弄潮儿了，可惜这种人目光短浅又毫无同理之心，命比时代的浪还要短，只能看见自己顺着波涛拍动两下翅膀，看不见此波退去，下一波浪潮来临时的悲哀内有千百个自己的悲惨死相，还在这摇唇鼓舌，真是可笑，不骂他个八辈祖宗都是给他的面子了。<br />136、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />137、已经等不及想看后人如何评价我们了，自轰轰烈烈的公运失败后，这些叛徒朝着准备主意方向走去，却为了得到人民群众的信任不敢去承认，搞几波枪打出头鸟，后来再也没人敢在公共场合讨论，在网上日常说话发表评论都有敏感词看着，和过去的文字狱别无二致，阶级固化日益严峻，阶级矛盾愈演愈烈，过去地主小姐之流又出现在了这片土地上，革命先辈的血当真被这些投机倒把倒行逆施的叛徒们搞得白流了。<br />照这样看我想歌名的时间就快来了，不知是百年还是多久，这漫长的等待在史书上可能只有短短几页，但是一个人可能耗尽一生可能都望不到曙光，希望以后我们能实现真正的共产主义。<br />史记三页纸为轻，人生百世命何沉。<br />138、如果生活需要喜剧演员那我一定是一位出色的影帝，但是生活是一场闹剧，而我却偏偏里面演了一出喜剧，所以显得格外的悲剧，但是喜剧终是要人笑得，所以最后大家都露出了开心的笑容，只有我留下了悔恨的泪水。<br />139、“我只是想毁灭掉，这个，腐朽的世界”<br />既然超脱自我是如此的困难，那么追求毁灭和堕落，我想也是理所当然，情有可原的。<br />得不到的就期盼着它毁灭，还要在走向死寂的昏暗路口乞怜他人的宽慰，我不值得任何人为我哀叹，我不配任何人为我歌唱，我不配为任何人所留恋。<br />后来的人啊，如果你在人生的路牌上看见我的这番话，就不要像我一样沉沦，去冲破这命运的诅咒，去打破这可悲的诅咒，去勇往直前的做吧，去不断进取、不断学习吧，去放开手勇敢地爱吧，去活出精彩的、只属于你自己的样子吧。<br />后来的人啊，不要成为前面的人。<br />后来的人啊，祝你拥有幸福美满的一生。<br />140、后来我才知道，同理心是一种可贵的品质，这种品质不是每个人都有，甚至有的畜生遗忘了它。<br />141、网络真神奇啊，每个人都在上面聊着自己，对他人漠不关心，看似彼此能聊以安慰，仔细一看人家只不过在宽慰自己。<br />142、我一直都沉浸在难过的情绪中，以至不能自拔，我想痛苦也是一种毒药，而我就是他的吸食者。<br />143、我本质是一个糟糕透顶的人，我只是把我理想的样子伪装出来罢了，我一直都是祥林嫂，只不过在我死前呻吟一两声罢了，鲁迅在数十年前就写尽了我的荒唐。<br />144、因为我毫无建树，有没有特点，而且性格屌差，长得也丑，上有年迈的父母，我不能创造美好的生活报答他们的养育之恩，对于社会也没有帮助。<br />145、其实很多时候你们看那些我说出的哗众取宠之语，很多都是我肺腑之言，但是在这个荒谬的时代就成了令人哂笑的笑料，太多力，一时反而说不上来，就像面具戴在脸上时间久了就不自知了，就像悲伤沉浸其中时间久了就以痛苦为常态了。<br />146、生活是一个温柔并残酷的对手，他温柔的地方在于用名为平常的毒药渐渐损食人的心智磨灭热情和冲动，待回过神来已经在平凡中不能自拔；他残酷的地方在于这一过程没有表征，当看见别人鱼跃龙门时心中不少悸动，但是在两三下的挣扎后又再次沉浸在这沉沦的毒坛中。<br />若是你凭借超凡的毅力和坚韧战胜了自我，他还有压箱底的把式，用最残酷的方式终结你的抗争，可能是身体的也可能是精神的，正因为这对手如此的可怕，我们才会敬佩歌颂哪些坚韧不拔的英雄。<br />147、在心理学上有一种概念叫“缺失取向”，就是说一个人越是缺少什么越是表现什么。一个人越是极端地去表现积极乐观，他的内心就越是脆弱不堪，在他几近疯狂地、甚至令人感到违和不适的快乐面具下，可能隐藏着的是一颗遍体鳞伤的心，就像一张拉满弦的弓，一旦松手便是崩坏般的毁灭。<br />这种积极是悲哀的，只是在欺骗自我罢了，在生活中我曾见过这样的人，他是自知的，但是他无法放下，因为他弓弦的另一端是沉重的6便士，我什么都做不了，我听见他的笑声一下下刺痛我的鼓膜，看到他扭曲疯狂的笑容一幕幕映入我的眼帘，令我身心都感到些许的不适，我并不反感、或者说我没有资格反感，我只是感觉悲伤罢了。<br />148、我经常回忆过去因为他离我遥远、朦胧我能随意的想像令他完美，我不敢去想将来因为那是未知，我用尽一切方法逃离当下以远离未来，但无论我逃去何方他总能追上，在我于当下困顿时，我又想起过去，在过去中我从当下迈向未来。<br />149、骑士在扮演小丑，小丑在扮演骑士，这是个荒谬的时代，人们戴着不属于自己的假面，展露容颜者被称为异类，粉末假饰者收获赞美，人们被虚幻迷盖，对真实漠不关心，肉林的霓虹掩饰了沉重的担子，眼帘中都是狂欢迷醉，而死亡毁灭接踵而至。<br />150、和生活的这场战斗没有胜利可言，一旦开始便没有归途，最后的结果莫不是和解便是毁灭。<br />151、我想我是一个自私的人，每当我有所思考都是从自我的角度出发，很少想到他人，而想要说些什么欲从他人角度进行阐述，又有些不好意思，不知从何处下手。这应该是一个坏习惯我应该改一改，但是我又不知道怎么开始，很多事情我都是这样的，想要有所改变却迟迟迈不出手脚。<br />152、之前一直不理解《太吾绘卷》里的武学逆练是什么，因为在过去的教育过程中都是专心但粗糙地学习书本上、学校教授的知识不太理解，后来看见一个视频标题叫<ahref="https://www.bilibili.com/video/BV1TX4y1z7D5">[《官僚主义如何逆练群众理论》]</a>，再想想现实中藿香正气的例子便有些明白了，懂了理论但是为了自己的利益和欲望反其道而行之达到自己的预期，背离了知识的思想初衷，现在想想真是唏嘘。<br />153、我终是没发出光的，在这个炫丽的时代，寒冷的雨夜浇灭了我稚嫩的荧光，绮丽的世界不再希望炬火，因为和未来感的世界相衬起来是那么格格不入，在华丽的舞台背后，我在垃圾桶里等待死亡。<br />154、“莫说你一个宋慈就是十个八个也休想把这浑浊的世道变得天朗水清”，随着一把大火所有的罪证都化作灰烬，这些个衣冠禽兽都作了清白之身，刁光斗死在法不责众的乱拳之下，这场游戏，宋慈输了，刁光斗也输了，获得胜利的也只有王权一人，这场游戏从一开始就注定是王权之下的一桩悲剧罢了，所谓的你争我斗平反冤案，也只不是在王权的平台上的一幕而已。<br />155、人们总是在幻想中寻找认同，希望自己拥有打败一切的力量，希望自己能面对挫折坚毅不拔，从能打爆一切的勇者、拥有无数朋友的冒险家，面对残酷生活依旧坚韧的主人公，人们总是把自己的希望向外投影并追寻，但是摄像机是永远追不上投影屏的，想要成为幻想中的存在要自己行动。<br />156、我很害怕“结束”，仿佛只要没有“结束”一切都还来得及一切就都还有机会，我就还能在做些什么，但是“结束”是无可避免的无论如何逃避都要迎接“结束”。<br />157、今天是2023/05/11，晚上11点就是是《塞尔达：王国之泪》发售日了，在这个平凡的日子，世界上最伟大的游戏续作发售了，在这个伟大的发售日一切都那么平常，一切都仿佛没有发生，母亲还是在做饭，父亲还是辛苦的工作，我还是一如既往的失业，我还是没有解决生活的难题。虚拟世界的伟大波澜击不起我平凡生活的一丝浪花，人们用虚拟世界的梦幻来装饰糊涂的现实，世界上最荒诞的现实主义就在我身上发生。<br />158、突然想聊聊王家卫的抽帧，这种抽帧的手法营造了一种不真实感，这种不真实感就如同做梦，用这种去真作幻的手法去给观众想像感悟的空间，人在回忆时想像力是最强的因为不真切却又想极力看清所以就用想像弥补了空白，而王家卫的抽帧留给观众的是留白的画面，引起观众潜意识的想像补充，所以给人一种朦胧和梦幻的感觉。<br />159、我见过一家工厂，那里的材料要交钱才能变成罐头，这材料也是要分三六九等的，有的走了高级通道便通到什么堂皇的所在，不过我看应是颠倒过来的，叫荒唐才对。这样的流水线效率可高的呢，若是哪个落了队脱了群断是要不得的，他们说这是现代化，我是不懂的。<br />这样造出的罐头终是卖不出的，因为味道是差远了的，倒是那些堂皇的罐头是炙手可热的玩意。<br />160、那时候还有每天都会弹出来的腾讯新闻，可是这粗糙又美好的一切都成为了只能追忆的过去，眼前只有疲于奔命的现实和逐渐被压垮的身心，如果可以我希望在这场名为现实的噩梦中，回到过去。<br />161、无产者的哀伤竟被小资产阶级篡夺，作为生活的调剂和故作高深的资本，他妈的，你配吗？恶心。<br />162、人生的顿悟和无知竟是极为的相似，在无知时对自我没有喜欢讨厌不知其为何物，在学习中发现自己的闪光点心存喜爱不足心存悔过，这一过程知晓喜恶，在最后顿悟时接纳自己的一切有回到无厌喜的状态，虽然相似，但是也许应该有不同吧，我在漫长的学习过程中回滚到了无知的深渊，那顿悟的一朝我想我终是达到不了了。<br />163、<br />如果今天是你最后一次看见我，<br />你会对我说什么，<br />我想你什么都不会说，还会觉得我莫名其妙，<br />所以这结束还是由我来说更合适，<br />“再见，我将要去往新的明天。”</p><p>164、现在是2023/05/22晚22:02我的精神越发的不振了，我的精神几近癫狂，我想我很快就会病倒了，或者结束这一切了，我将死亡。</p><p>165、我是在做梦吗？我想这应该是一场噩梦吧，毕竟整个世界都没有人理睬我，难道我在梦里都不受人待见吗。在梦里也会肚子饿吗？在梦里也不能受到别人的眷顾吗？在梦里也不能受到他人的青睐吗？<br />那梦和现实有什么区别吗？那我还是在梦里死去吧，这样比较浪漫。<br />在自己的梦中死去算是自杀吗？在这个和现实一样悲哀的梦中死去。</p><p>166、“只要你还没意识到自己并非无所不能，那你就还是雏鸟。”</p><p>167、别着急，没什么，弗拉基米尔·伊里奇，他只是而昏过去了，等他醒来世界将再次插满红旗。</p><p>168、明年也许会有，也许不会，但是明年我的青春一定没有了。在每日的时光流逝中，随他而去的还有我曾以为无穷的可能性，我的一切生机活力都在慢慢消失，有人说这是长大的代价，但我只感到了死寂的悲凉。明天的太阳会再次升起，但明天我的生命也许不再蓬勃。</p><p>169、"我的瓦西亚死了，"妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，"自然我的日子也完了，我活活的给人把心挖了去。然而汤是不应该糟蹋的，里面放得有盐呢。<br />---屠格涅夫<白菜汤></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ RAII</title>
    <link href="/2022/04/01/C++RAII/"/>
    <url>/2022/04/01/C++RAII/</url>
    
    <content type="html"><![CDATA[<p><a href="https://medium.com/swlh/what-is-raii-e016d00269f9">What isRAII?</a><br /><a href="https://www.youtube.com/watch?v=q6dVKMgeEkk">YoutubeVedio</a></p><span id="more"></span><h1 id="c-raiiresurce-acquisition-is-initialization">C++ RAII(ResurceAcquisition Is Initialization)</h1><h2 id="raii-用来做什么">RAII 用来做什么?</h2><h3 id="内存">内存</h3><p>当我们在 C++中分配内存时，比如开辟一个数组，<code>int *arr = new int[dynamicSize]</code>,那么我后续一定要记得去<code>delete[] arr</code>，否则就会发生<strong>内存泄漏</strong>。也就是管理内存都需要我们手动去进行。</p><h3 id="锁">锁</h3><p>然后我们看看使用锁，假设我们想显式同步代码的某些部分。我创建一个<code>std::mutex</code>，然后调用<code>mutex.lock()</code>。如果忘记调用<code>mutex.unlock()</code>，或者在解锁前发生异常(导致<code>mutex.unlock()</code>)未被调用，当其他线程尝试获取锁时将死锁。</p><h3 id="线程">线程</h3><p>如果我们想在另一个线程运行代码，然后我创建了一个线程。如果我们记得<code>jion</code>就没有问题，但是如果我们忘记了，并且线程超出了自己的作用域，<code>std::terminate</code>将被调用，程序会终止。</p><h4 id="线程相关内容补充">线程相关内容补充</h4><p>在C++中，创建线程后，如果没有适当地处理线程的结束，可能会导致程序意外终止。</p><p>当你创建一个新的线程并开始执行代码时，主线程和新线程是并行执行的。如果在主线程退出之前没有join（或者使用 detach 分离线程），那么主线程结束时，程序会调用<code>std::terminate</code> 来终止所有尚未结束的线程。</p><p>这种情况的发生通常是由于在主线程退出之前，新线程尚未完成，而没有等待新线程结束（或者分离）而导致的。因此，在使用线程时，确保在适当的时机对线程进行join 或 detach 是非常重要的。</p><h5 id="关于-join-和-detach">关于 join 和 detach</h5><p>join 和 detach 是 c++ 两种管理线程的方法。</p><ol type="1"><li><p><code>join</code>通过阻塞当前线程等待被调用的线程完成，确保主线程在子线程执行完毕后在继续执行，从而避免子线程在主线程退出去终止，或者超出作用域导致<code>std::terminate</code> 导致整个进程结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(threadFunction)</span></span>;<br><br>t.<span class="hljs-built_in">jion</span>();<span class="hljs-comment">// 阻塞该主线程，等待子线程完成  </span><br></code></pre></td></tr></table></figure></li><li><p><code>detach</code>将当前线程和新线程分离，使其独立运行。一旦被分离后就无法使用<code>join</code>方法等待线程结束。<u><strong>此时</strong>线程的生命周期就由自己控制了，主线程和子线程可以并发执行，互相独立。</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">thread</span>(threadFuntion);  <br>t.<span class="hljs-built_in">detach</span>();  <br></code></pre></td></tr></table></figure></li></ol><p>通过以上三个例子，我们可以看到错误发生是有一定规律的。首先在这些例子中我们获取了某些资源，如Heap上的内存、锁、线程。获取资源当然没有问题，但是当资源超出作用范围问题就发生了(内存泄露，死锁，进程终止)，在第一个问题中我们要时刻记得delete、第二个需要 unlock，第三个需要 join，这显然是很繁琐的。</p><p>RAII 就是为了避免犯错和繁琐的手动释放。<br />C++ 和Java，Python等的垃圾回收不同其析构函数是显式的，离开作用域自动销毁。<br />其他比如向 vectorpush一个资源，然后退出引用计数归零，但是不会立即删除，而是过段时间后调用一个GC 程序将引用计数为零的对象删除。</p><p>但是如果对高性能计算有要求，如<strong>时序</strong>或<strong>性能</strong>就不能依赖GC。</p><h3 id="raii-异常安全-exception-safe">RAII: 异常安全( exception-safe)</h3><p>C++ 标准确保在异常发生时，也能调用 已创建对象的析构函数，因此 C++不需要 Java 那种 finally 语句确保执行。</p><h3 id="raii-离不开-构造函数-和-析构函数">RAII 离不开 构造函数 和析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-built_in">Pig</span>():<span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;Kit&quot;</span>),<span class="hljs-built_in">age</span>(<span class="hljs-number">10</span>)<br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-built_in">Pig</span>(string n, <span class="hljs-type">int</span> a):<span class="hljs-built_in">name</span>(n),<span class="hljs-built_in">age</span>(a)<span class="hljs-comment">// 拷贝构造函数</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-built_in">Pig</span>(string n, <span class="hljs-type">int</span> a)<span class="hljs-comment">// 拷贝赋值函数</span><br>    &#123;<br>        name = n;<br>        age = a;<br>    &#125;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pig pig0;<br>    <span class="hljs-function">Pig <span class="hljs-title">pig1</span><span class="hljs-params">(<span class="hljs-string">&quot;Kiii&quot;</span>,<span class="hljs-number">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>高效：使用初始化列表可以避免重复初始化，如果不使用，首先会先将数据成员空初始化，然后在构造函数内部进行赋值。<br /></li><li>避免错误，因为不用初始化列表会先对成员进行无参初始化，而这时若类成员没有无参构造函数就会出错。<br /></li><li>类成员为 const，因为 const对象只能初始化一次，所以只能在初始化列表中进行。</li></ul><blockquote><p>要记住非初始化列表都是先进行无参初始化然后再在函数内进行一次赋值，即一次初始化，一次赋值。</p></blockquote><h4 id="构造函数单个参数">构造函数单个参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-built_in">Pig</span>(<span class="hljs-type">int</span> age_):<span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;a Pig aged&quot;</span>+<span class="hljs-built_in">to_string</span>(age_)),<span class="hljs-built_in">age</span>(age_)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pig pig = <span class="hljs-number">80</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>= 80</code>是隐式地调用了构造函数，如果想为了可读性避免这种隐式构造，可以使用explicit。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>string name;<br>    <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(<span class="hljs-type">int</span> age_)</span>:name(<span class="hljs-string">&quot;a Pig aged&quot;</span>+to_string(age_)),age(age_)</span><br><span class="hljs-function">    &#123;</span><br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Pig pig = 80;</span><br>    <span class="hljs-function">Pig <span class="hljs-title">pig</span><span class="hljs-params">(<span class="hljs-number">80</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>explicit使其必须使用<code>(80)</code>这种格式显式调用构造函数。<br />explicit 的作用就在于避免因为隐式调用而导致代码可读性的降低。</p><h4 id="explicit-多参数">explicit 多参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string p_name;<br>    <span class="hljs-type">int</span> p_age;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(string name, <span class="hljs-type">int</span> age)</span>:p_name(name),p_age(age)</span><br><span class="hljs-function">    &#123;</span><br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pig pig = &#123;<span class="hljs-string">&quot;Kit&quot;</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">// Error</span><br>    Pig pig2&#123;<span class="hljs-string">&quot;Kit2&quot;</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">// Right</span><br>    <span class="hljs-function">Pig <span class="hljs-title">pig3</span><span class="hljs-params">(<span class="hljs-string">&quot;Kit3&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">// Right</span><br>&#125;<br></code></pre></td></tr></table></figure><p>explicit 可以用于多参数，并且在上面例子中，explicit 避免了<code>&#123;"kit",5&#125;</code> 的隐式调用，并且接受了<code>Pig pig2&#123;"Kit2",7&#125;</code> 的显式调用。</p><h4 id="和-调用的区别">() 和 {} 调用的区别</h4><ol type="1"><li><code>int(3.14f)</code> 不会报错，但是 <code>int&#123;3.14f&#125;</code>会报错，因为 {} 是非强制类型转换。<br /></li><li>假如 使用 <code>Pig pig2&#123;"jit2",4.5&#125;</code> 这就会出错了……</li></ol><p>by the way，现在别使用 int() 了，太蠢了，而且不安全，比如要是转换为指针可能会发生错误。应该使用<code>static_cast&lt;int&gt;()</code> 进行。</p><h3id="编译器默认生成的构造函数无参-pod-陷阱">编译器默认生成的构造函数：无参( POD 陷阱 )</h3><p>当一个类没有定义任何构造函数，且类成员都有无参的构造函数，编译器会自动生成一个无参构造函数，会调用每个成员的无参构造函数。</p><p><strong>注意</strong>这些类型<strong>不会被初始化为0</strong>。</p><ol type="1"><li>int, float, double 等基础类型<br /></li><li><code>void*</code>, <code>Object*</code> 等指针类型<br /></li><li>完全有这些类型组成的类</li></ol><ul><li>这些类型称为 <strong>POD( plain-of-data )</strong><br />POD的存在是出于兼容性和性能考虑，这些类型会将其所在内存位置的数据直接作为自己的初始值。</li></ul><p>所以如果你打算使用编译器自动生成的初始化函数，最好对类成员用<code>&#123;&#125;</code> 进行一个指定初始化，这样在自动生成的构造函数中就会初始化为你指定的值。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string p_name;<br>    <span class="hljs-type">int</span> weight&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 自动生成的构造函数会将其初始化为0</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>或者使用<code>=</code>也可以，但是要注意类对象其本身的构造函数是否有explicit 修饰<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Demo</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Demo</span><span class="hljs-params">(string a, string b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string p_name;<br>    <span class="hljs-type">int</span> weight = <span class="hljs-number">0</span>;<br>    Demo pd&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>&#125;;<span class="hljs-comment">// 可以通过编译</span><br>    <span class="hljs-comment">// Demo pd = &#123;&quot;a&quot;,&quot;bb&quot;&#125;;// 这样就不行</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><blockquote><p><code>int x&#123;&#125;;   void* p&#123;&#125;;</code></p><p>和</p><p><code>int x&#123;0&#125;;   void* p&#123;nullptr&#125;;</code></p><p>等价，都是<strong>零初始化</strong></p></blockquote><h3id="编译器默认生成的构造函数c11-初始化">编译器默认生成的构造函数：C++11初始化</h3><p>在 C++11 中，如果一个类(和他的基类)没有定义任何构造函数，这时编译器会自动生成一个<strong>参数个数和成员一样的构造函数</strong>。</p><p>会将 {} 内容，<strong>按顺序赋值给对象的每一个成员</strong></p><p>不过这种只支持 {} 或者 = {}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Deo</span><br>&#123;<br>    Pig pig;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Write C++ code here</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!&quot;</span>;<br>    Pig pig&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    std::cout &lt;&lt; pig.a &lt;&lt; std::endl;<span class="hljs-comment">// 1</span><br>    Deo deo&#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;,<span class="hljs-number">1</span>&#125;;<br>    std::cout &lt;&lt; deo.pig.a &lt;&lt; std::endl;<span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这时候无参构造函数也是存在的。</p><p>和默认指定结合<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string p_name;<br>    <span class="hljs-type">int</span> p_weight&#123;<span class="hljs-number">0</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pig pig&#123;<span class="hljs-string">&quot;kit&quot;</span>&#125;;<span class="hljs-comment">// weight 未指定，使用 0</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3id="有自定义构造函数时仍想用默认构造函数default">有自定义构造函数时仍想用默认构造函数：<code>=default</code></h3><p>一旦我们自定义了构造函数，编译器便<strong>不会生成默认的无参构造函数</strong><br />但是如果我们仍然想使用，就可以用 <code>=default</code> 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string pName;<br>    <span class="hljs-type">int</span> pWeight;<br>    <br>    <span class="hljs-built_in">Pig</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-built_in">Pig</span>(string name, <span class="hljs-type">int</span> wei)<br>        :<span class="hljs-built_in">pName</span>(name),<span class="hljs-built_in">pWeight</span>(wei)<br>        &#123;<br>            <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>but 初始化列表的那个构造函数好像不能 =default 出来</em></p><h3id="编译器默认生成的构造函数拷贝构造函数">编译器默认生成的构造函数：拷贝构造函数</h3><p><code>Pig(cosnt Pig&amp; other)</code><br />参数为 Pig 类型，调用如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Pig pig&#123;<span class="hljs-string">&quot;Kit&quot;</span>,<span class="hljs-number">90</span>&#125;;<br>    <br>    Pig pig2 = pig;<br>    <span class="hljs-comment">// Pig pig2(pig);// 与上面的一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即便我们自定义了构造函数，拷贝构造函数也不会删除。</p><h3id="舍弃拷贝构造函数delete">舍弃拷贝构造函数：<code>=delete</code></h3><p>如果不想使用拷贝构造函数可以使用 <code>delete</code> 修饰<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span><br>&#123;<br>    string pName;<br>    <span class="hljs-type">int</span> pWeight&#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-built_in">Pig</span>()=<span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-built_in">Pig</span>(string name, <span class="hljs-type">int</span> wei):<span class="hljs-built_in">pName</span>(name),<span class="hljs-built_in">pWeight</span>(wei)<br>    &#123;&#125;<br>    <br>    <span class="hljs-built_in">Pig</span>(<span class="hljs-type">const</span> Pig&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">// 禁止拷贝构造</span><br>    Pig&amp; operatpor=(Pig <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//  禁止拷贝赋值</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>Pig pig2 = pig;</code></p><p>这是<strong>拷贝构造</strong><br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Pig pig2;<span class="hljs-comment">// 无参构造</span><br>pig2 = pig;<span class="hljs-comment">// 拷贝赋值</span><br></code></pre></td></tr></table></figure></p><p>这是<strong>拷贝赋值</strong></p><h4id="为什么拷贝赋值函数返回值是引用">为什么拷贝赋值函数返回值是引用</h4><p>为了实现链式赋值，返回要是左值引用，而非临时对象的将亡值。</p><h3 id="构造函数全家桶">构造函数全家桶</h3><h4 id="三五法则一">三五法则：一</h4><p><img src="imgs/C++RAII/35.png"></p><ol type="1"><li>如果定义了析构函数，为了防止 doulefree 要么 delete拷贝构造和拷贝赋值，要么自定义。<br />也就是深拷贝和浅拷贝。<br />浅拷贝会导致两个对象内的指针指向同一内存，所以我们要手动实现深拷贝。<br />如果定义了析构函数很有可能是因为我们类内对象有些无法被默认的析构函数销毁，<br />所以可能会有深拷贝和浅拷贝问题，如果只需要浅拷贝那就删除拷贝构造和拷贝赋值函数，C++会默认生成的。<br /></li><li>如果不实现拷贝赋值函数，编译器可能会以 析构+拷贝构造的方式实现拷贝赋值的效果。<br /></li><li>与上面同理。</li></ol><h4 id="拷贝和移动">拷贝和移动</h4><p>有时候我们只需要一份 data，不需要复制，我们更希望把 对象<strong>移动</strong>过去。<br />拷贝是 O(n)，移动是 O(1)<br />可以使用 std::move<br />v2 被移动到 v1 后原来的 v2 会被清空，所以一定要确保 v2后续不会会再被使用。</p><h4 id="移动进阶swap">移动进阶：swap</h4><p>我们不仅可以使用move<br />也可以使用 <code>std::swap</code> 交换 v1 和 v2<br />可以利用 swap 实现双缓存技术。</p><h4 id="哪些情况会触发-move">哪些情况会触发 move</h4><ul><li>会触发move<ul><li><code>return v2;</code> 作为返回值<br /></li><li><code>v1 = std::vector&lt;int&gt;(200)</code> 就地构造<br /></li><li><code>v1 = std::move(v2)</code> 显式move<br /></li></ul></li><li>拷贝<ul><li><code>return std::as_const(v2)</code>，显式拷贝<br /></li><li><code>v1 =v2</code> , 默认拷贝<br /></li></ul></li><li>下式不会 move 也不会 copy<ul><li><code>std::move(v2)</code><br /></li><li><code>std::as_const(v2)</code><br /></li><li>这两个函数只负责转换类型，不会发生实际的 copy 和 move。</li></ul></li></ul><h3 id="移动构造函数缺省实现">移动构造函数：缺省实现</h3><ul><li>移动构造 ≈ 拷贝构造 + 解构他 + 他默认构造(这里的他是移动的源对象)<br /></li><li>移动赋值 ≈ 拷贝赋值 + 他结构 + 他默认构造</li></ul><p>只要 我们不自己定义，编译器就会这样做<br />这也就是三五法则中 第4点, 为什么定义 <strong>拷贝构造</strong> 和<strong>拷贝赋值</strong> 后最好定义 <strong>移动构造</strong> 和<strong>移动赋值</strong></p><h2 id="raii-解决内存管理unique_ptr">RAII解决内存管理：<code>unique_ptr</code></h2><p>C++11 引用 <code>unique_ptr</code> 容器，其结构函数会调用 deletep。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span><br>&#123;<br>    <span class="hljs-built_in">C</span>()&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C&quot;</span>);&#125;<br>    ~<span class="hljs-built_in">C</span>()&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;~C&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;C&gt;();<br>    <span class="hljs-keyword">if</span>(..)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 自动释放 p</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 自动释放 p</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>而且将 C++98 的<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></p><p>封装为了一个操作：<br /><code>p = nullptr;</code> 等价于 <code>p.reset();</code></p><h4 id="uniqur_ptr-禁止拷贝"><code>uniqur_ptr</code>: 禁止拷贝</h4><p>为什么禁止拷贝，如果拷贝了这个指针，<br />而 <code>unique_ptr</code> 的析构函数使用了 delete，可能就会出现 doublefree 的问题。<br />所以，在我们写函数时，如果用 <code>unique_ptr</code>作为参数就会报错。</p><h5 id="解决方案1获取原始指针-c">解决方案1：获取原始指针( C* )</h5><ul><li><p>第一种情况，我们不需要 夺走 资源的 <strong>占有权</strong><br />比如只是一个函数调用，<strong>并不需要结果掌管对象生命周期的大权</strong>。<br />使用 <code>p.get()</code> 获取指针，然后进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(C* cp)</span>  </span><br><span class="hljs-function"> </span>&#123;<br>     <br> &#125;<br><br><span class="hljs-built_in">func</span>(p.<span class="hljs-built_in">get</span>());  <br></code></pre></td></tr></table></figure></li><li><p>第二种，我们需要夺走 资源的 <strong>占有权</strong>。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::unique_ptr&lt;C&gt;&gt; objectList;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::unique_ptr&lt;C&gt; p)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    objectList.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p));  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    std::unique_ptr&lt;C&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;C&gt;();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;移交前:%p\n&quot;</span>,p.<span class="hljs-built_in">get</span>());<span class="hljs-comment">// 不为null  </span><br>    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(p));  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;移交后:%p\n&quot;</span>,p.<span class="hljs-built_in">get</span>());<span class="hljs-comment">// 为null  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></p><p>因此我们要使用 move 接过掌管对象生命周期的大权。</p></li></ul><h4 id="移交控制权后仍希望访问到-p-指向的对象">移交控制权后仍希望访问到p 指向的对象</h4><p>我们移交后，原来的指针就变 nullptr，这时无法访问。<br />##### 解决办法：提前获取指针</p><p>使用get函数提前获取原始指针，<br />不用担心周期问题，这个原始指针的所有权归move后的新<code>unique_ptr</code>所有。<br /><code>C* raw_p = p.get();</code></p><p>但是要时刻注意 move 后的 <code>unique_ptr</code> 是否被删除！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;C&gt;();<br>C *raw_p = p.<span class="hljs-built_in">get</span>();<br><span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(p));<br>    <br>    raw_p-&gt;<span class="hljs-built_in">do</span>();<br>    <br>    objlist.<span class="hljs-built_in">clear</span>();<br>    <br>    raw_p-&gt;<span class="hljs-built_in">do</span>();<span class="hljs-comment">// !!! Error 悬空指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared_ptr"><code>shared_ptr</code></h2><ul><li><code>unique_ptr</code> 由于为了解决 double free而<strong>禁止拷贝</strong>，导致使用起来很困难，容易犯错。<br /></li><li><code>shared_ptr</code>，牺牲效率换取自由度，通过<strong>引用计数</strong> 来解决 <strong>重复释放</strong> 的问题。</li></ul><ol type="1"><li>当 <code>shared_ptr</code> 被初始化时，将计数器设为1；<br /></li><li>当 <code>shared_ptr</code> 被拷贝时， 计数器 +1；<br /></li><li>当一个 <code>shared_ptr</code> 被解构时，计数器 -1，直到计数器为0，则自动销毁其所指向的对象。</li></ol><ul><li>我们可以使用 <code>p.use_count()</code> 获取当前的引用计数。</li></ul><h3 id="shared_ptr-和-循环引用"><code>shared_ptr</code> 和 循环引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span><br>&#123;<br>    std:;shared_ptr&lt;C&gt; m_child;<br>    std::shared_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> parent = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <span class="hljs-keyword">auto</span> child = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br>    <span class="hljs-comment">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 失败，child 的 m_parent 还在引用</span><br>    child = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 失败，parent 的 m_child 还在引用</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即便 main 函数退出，这两块内存都无法释放。</p><h2 id="weak_ptr"><code>weak_ptr</code></h2><h3 id="循环引用解决方案1">循环引用：解决方案1</h3><ul><li>将逻辑上“不具有所属权” 的那一个 <code>shared_ptr</code>，改为<code>weak_ptr</code> 即可。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>  <br>&#123;  <br>    std:;shared_ptr&lt;C&gt; m_child;  <br>    std::weak_ptr&lt;C&gt; m_parent;  <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">auto</span> parent = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();  <br>    <span class="hljs-keyword">auto</span> child = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;  <br>    child-&gt;m_parent = parent;  <br>    <span class="hljs-comment">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 释放，因为 child 指向的是其 **弱引用**  </span><br>    child = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 释放，因为指向 child 的 parent 已经释放了</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li></ul><h4 id="不影响-shared_ptr-计数弱引用-weak_ptr">不影响 shared_ptr计数：弱引用 weak_ptr</h4><ul><li><p>expired() 可以判断，weak_ptr 是否失效，如果 shared_ptr已经释放了，该 weak_ptr 就失效了。<br /><code>waek_p.expired()</code></p></li><li><p>lock()，如果有需求可以随时使用 lock 函数产生一个新的shared_ptr。但不 lock 时 weak_ptr 不会影响计数。<br /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;C&gt; p = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();  <br>std::weak_ptr&lt;C&gt; weak_p = p;  <br>weak_p.<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">do_something</span>();<span class="hljs-comment">// 执行完毕后 lock 出来的 shared_ptr 就销毁了，不影响 shared_ptr 的计数，我理解为 lock 返回一个 shared_ptr 的将亡值，这行结束后自动解构  </span><br></code></pre></td></tr></table></figure></p></li></ul><h2 id="智能指针作为类的成员变量">智能指针：作为类的成员变量</h2><ol type="1"><li>unique_ptr，<strong>当该对象仅属于我</strong>，比如父窗口下的子窗口<br /></li><li>原始指针，<strong>当对象不属于我，但是他释放</strong><u><strong>前</strong></u><strong>我必然被释放。</strong><br />有一定风险，比如子窗口中指向父窗口的指针。<br /></li><li>shared_ptr：<strong>当有多个对象共享时，或虽然该对象仅属于我，但是有weak_ptr 的需要</strong><br /></li><li>weak_ptr：<strong>当该对象不属于我，且他释放</strong><u><strong>后</strong></u><strong>我仍可能不被释放。</strong>比如：指向窗口上一次被点击的元素。<br /></li><li>初学者可多用 shard_ptr 和 weak_ptr 的组合，更加安全。</li></ol><h3id="循环引用解决方案2设置为原始指针">循环引用解决方案2：设置为原始指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span><br>&#123;<br>std::shared_ptr&lt;C&gt; m_child;<br>C* m_parent;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> parent = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br><span class="hljs-keyword">auto</span> child = std::<span class="hljs-built_in">make_shared</span>&lt;C&gt;();<br><br>parent-&gt;m_child = child;<br>child-&gt;m_parent = parent.<span class="hljs-built_in">get</span>();<span class="hljs-comment">// 这里 parent.get 得到的原始指针是归属于 shared_ptr parent 的</span><br><br>parent = <span class="hljs-literal">nullptr</span>;<br>child = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有更适合父窗口-子窗口的解决方案。<br />刚才提到原始指针的应用场景：当一个对象不属于我，但是他释放<u>前</u>我必须释放。<br />这里可以发现父窗口的释放必须导致子窗口的释放。</p><h2 id="智能指针使用">智能指针使用</h2><h3id="成员都是安全类型五大函数一个也不用声明">成员都是安全类型：五大函数，一个也不用声明</h3><ul><li>如果类的所有成员都是 <strong>安全</strong>类型，那么五大函数都无需声明，你的类型就是自动<strong>安全的</strong>。<br /></li><li>最好的判断方式是：如果你不需要 <strong>自定义的解构函数</strong>这个类就无需担心。<br /></li><li>如果我们需要自定义解构函数，往往意味着你的类成员中，包含不安全类型。<br /></li><li>一般有两种情况：<ol type="1"><li><strong>类管理着资源</strong><br /></li><li><strong>类是数据结构</strong></li></ol></li></ul><h4id="管理着资源仅需要浅拷贝删除拷贝函数统一用-shared_ptr-管理">管理着资源(仅需要浅拷贝)：删除拷贝函数，统一用shared_ptr 管理</h4><ul><li><p>因为资源，往往是不能被复制的。比如 一个 openGL 的 shader</p></li><li><p>如果允许拷贝(浅拷贝)，就相当于把 标记资源的 int复制两遍，之后就会出现 double free 的问题。</p></li></ul><h4id="数据结构需要深拷贝如果可以定义拷贝和移动">数据结构(需要深拷贝)：如果可以，定义拷贝和移动</h4><ul><li>我们设计的<strong>数据结构</strong>通常是支持深拷贝的，这需要我们自己去定义实现，如果实在无法实现那就删除。</li></ul><h3 id="函数如何避免拷贝">函数如何避免拷贝</h3><p>使用常引用：<code>Pig const &amp; pig</code></p><h4 id="如何避免不经意的隐式拷贝">如何避免不经意的隐式拷贝</h4><p>我们可以将 拷贝构造函数声明为 explicit<br />这样隐式拷贝就会出错，让我们发现隐式拷贝的发生。</p><h2 id="后续阅读">后续阅读</h2><ol type="1"><li>P-IMPL模式<br /></li><li>虚函数与纯虚函数<br /></li><li>拷贝如何作为虚函数<br /></li><li><code>std:unique_ptr::release()</code><br /></li><li><code>std:.enable_shared_from_this</code><br /></li><li><code>dynamic_cast</code><br /></li><li><code>std::dynamic_pointer_cast</code><br /></li><li>运算符重载<br /></li><li>右值引用&amp;&amp;<br /></li><li><code>std::shared_ptr&lt;void&gt;</code>和 <code>std:any</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>摸鱼画图</title>
    <link href="/2022/04/01/MoyuPics/"/>
    <url>/2022/04/01/MoyuPics/</url>
    
    <content type="html"><![CDATA[<p>只是偷偷放一下自己平时摸鱼的"产物"。</p><span id="more"></span><h6 id="卷发长直">卷发，长直</h6><div style="width:45%;margin:left"><img src="/imgs/MoyuPics/卷发5.26.jpg"/></div><p>好像还是不行，感觉自己画的头发像是一张纸，薄薄的，没有质感……还是要继续摸鱼啊!(</p><div style="width:45%;margin:left"><img src="/imgs/MoyuPics/5.29.jpg" alt="mole"></div><p>为什么没有下半身？因为我摸崩了(</p><p>22/6/4今天看到极乐迪斯科的边缘层次结构理论，主创团队认为在画面中并不是所有物体的边缘都是必须可见的，一些边甚至可以柔化甚至完全消失，而在实际生活中物体是没有界限的，我们所观测到的边界是由光线和对比度等造成的视觉效果。主创团队所营造的美术效果更加注重氛围和环境，相比常规的边缘清晰的美术作品，游戏内呈现的更加"油画风"，人们更能进行整体感知，如果着重边缘某种程度上分离了物体和环境的关系，一副优秀的美术作品不能忽略物体与环境，当物体与环境相近我们的视觉就会忽略物体的边缘。正式由于这样的美术理念，极乐迪斯科造就了一个迷幻的世界，一个充满绘画风格的世界。</p><div style="width:45%;margin:left"><img src="/imgs/MoyuPics/边缘.jpg"/></div><div style="width:45%;margin:left"><img src="/imgs/MoyuPics/eye614.jpg"/></div><p>其实眼睛才是我摸鱼时画的最多的，好久不摸手都生了。</p><div style="width:45%;margin:left"><img src="/imgs/MoyuPics/2022.6.15.jpg"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/starve.jpg" alt="饥饿,消瘦的男孩"></div><div style="width:15%;margin:left"><img src="/imgs/MoyuPics/617e.jpg" alt="普通的眼睛"></div><div style="width:15%;margin:left"><img src="/imgs/MoyuPics/617m.jpg" alt="普通的嘴"></div><div style="width:25%;margin:left"><img src="/imgs/MoyuPics/617w.jpg" alt="普通的人"></div><div style="width:25%;margin:left"><img src="/imgs/MoyuPics/220630jo.jpg" alt="普通的jio"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702光头.jpg"  alt="光头" ></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702CF.jpg" alt="光头变长发" ></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702P1.jpg" alt="摸鱼P1"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702P2.jpg" alt="摸鱼P2"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702P3.jpg" alt="摸鱼P3"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/220702P4.jpg" alt="摸鱼P4"></div><div style="width:30%;margin:left"><img src="/imgs/MoyuPics/20221114EyeCue.jpg" alt="摸鱼P3"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>已修复</title>
    <link href="/2022/01/01/%E7%B4%A7%E6%80%A5%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/01/01/%E7%B4%A7%E6%80%A5%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="紧急通知">紧急通知</h1><p>因为本人玩<code>hexo-renderer-markdown-it-plus</code>，玩崩了，所以本Blog处于不稳定状态，很多文章图片加载不出来。目前看来是什么神秘的插件缺失了吧，大概。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读刘盆子传</title>
    <link href="/2020/04/16/%E8%AF%BB%E5%88%98%E7%9B%86%E5%AD%90%E4%BC%A0/"/>
    <url>/2020/04/16/%E8%AF%BB%E5%88%98%E7%9B%86%E5%AD%90%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>话不多说，只是看看刘盆子传。 <span id="more"></span></p><p><img src="/imgs/读刘盆子传/zzpbzb.JPG" style="zoom:200%;" ></p><h1 id="刘盆子传">刘盆子传</h1><h2 id="原文">原文</h2><p><ahref="http://wyw.5156edu.com/html/z5710m8368j7539.html">《后汉书·刘盆子传》原文及翻译--在线文言文(5156edu.com)</a></p><p>​刘盆子者，太山式人，城阳景王章之后也。祖父宪，元帝时封为式侯，父萌嗣。王莽篡位，国除，因为式人焉。</p><p>​天凤年，琅邪人樊崇起兵于莒。时寇贼蜂起，众盗以崇勇猛，皆附之，一岁间至万余人。崇同郡人逄安、东海人徐宣等各起兵，合数万人，复引从崇。初，崇等以困穷为寇，无攻城徇地之计。众既浸盛，乃相与为约：杀人者死，伤人者偿创。以言辞为约束，无文书、旌旗。王莽遣军击之，崇等欲战，恐其众与莽兵乱，乃皆朱其眉以相识别，由是号曰赤眉。遂大破之。</p><p>​初，赤眉过式，掠盆子及二兄恭、茂，皆在军中。及恭随崇等降更始，即封为式侯。恭以明经数言事，拜侍中，从更始居长安。盆子与茂留军中，主刍牧牛，号曰牛吏。及崇等欲立帝，求军中景王后者，得七十余人，唯盆子与茂及前西安侯刘孝最为近属。崇尝闻古天子将兵称上将军，乃书札为符曰“上将军”，又以两空札置笥中，列盆子等三人以年次探札。盆子探得符，诸将乃皆称臣拜。盆子时年十五，被发徒跣，敝衣赭汗，见众拜，恐畏欲啼。茂谓曰：“善藏符。”盆子即啮折弃之，而犹从牧儿遨。</p><p>​军及高陵，入长安城，更始来降。盆子居长乐宫，诸将日会论功，争言讙呼，拔剑击柱，不能相一。又数虏暴吏民，百姓保壁，由是皆复固守。盆子惶恐，日夜啼泣。刘恭见赤眉众乱，知其必败，自恐兄弟俱祸，密教盆子归玺绶，习为辞让之言。建武二年正月朔，崇等大会，盆子下床解玺绶，叩头曰：“今设置县官而为贼如故。此皆立非其人所致，愿乞骸骨，避贤圣。”因涕泣嘘唏。崇等及会者数百人，莫不哀怜之，乃皆避席顿首曰：“臣无状，负陛下。请自今已后，不敢复放纵。”既罢出，各闭营自守，三辅翕然，百姓争还长安，市里且满。后二十余日，赤眉贪财物，复出大掠。城中粮食尽，遂收载珍宝，因大纵火烧宫室，引兵而西。</p><p>​光武遣军分为二道，以要其还路。赤眉忽遇大军，惊震不知所为。樊崇竟将盆子及丞相徐宣以下三十余人肉袒降。上所得传国玺绶、更始七尺宝剑及玉璧各一。明旦，大陈兵马临洛水，令盆子君臣列而观之。谓盆子曰：“自知当死不？”对曰：“罪当应死，犹幸上怜赦之耳。”帝又谓崇等曰：“卿所谓铁中铮铮，庸中佼佼者也。”</p><p>​帝怜盆子，赏赐甚厚，以为赵王郎中。后病失明，赐荥阳均输官地，以为列肆，使食其税终身。（取材于《后汉书·刘玄刘盆子列传》）</p><h2 id="翻译">翻译</h2><p>​刘盆子，太山郡式县人，是城阳景王刘章的后代。他的祖父刘宪，在元帝时被封为式侯，父亲刘萌继承了爵位。王莽篡夺了王位后，封国被取消，刘盆子就成了式县人了。</p><p>​王莽天凤年间，琅邪人樊崇在莒县起兵，当时盗匪四起，许多盗贼因为樊崇勇猛，都依附他，一年之内发展到了一万多人。樊崇的同郡人逄安、东海人徐宣等人各自起兵，一共有几万人，又率众前来跟从樊崇。起初，樊崇等人只是因为穷困窘迫才去做盗匪的，并没有攻占城池掠取土地的计划。现在人马日渐壮大，就一起约定：杀人者偿命，打伤人要抵罪。只有口头的约束，而没有文书、旌旗。王莽派遣部队攻打他们，樊崇等要和他们交战，又怕手下的人和王莽的士兵混在一起，就把他们的眉毛全部染红用来区别，因此称为赤眉军。于是赤眉军大败王莽军队。</p><p>​当初，赤眉军经过式县，劫掠了刘盆子以及他的两个兄长刘恭、刘茂，都安置在军中。到刘恭跟随樊崇等归顺更始帝，即被封为式侯。刘恭因为精通经书多次进言论事，被封为侍中，在长安中侍奉更始帝。刘盆子与刘茂留在军中，负责割草牧牛，被称为牛吏。到了樊崇想要拥立新皇帝时，在军中寻找景王的后代，一共找到七十多个人，只有刘盆子、刘茂以及前西安侯刘孝是最近的后裔。樊崇曾经听说古代天子带兵时称为上将军，于是就在竹简上写上“上将军”作为符书，又拿了两个空竹简放在竹筐里，让刘盆子等三个人站在中间，按年纪长幼顺序抽取竹简。刘盆子拿到了符书，将领们都向他称臣跪拜。刘盆子当时只有十五岁，披头散发，光着两只脚，穿着破衣服，涨红了脸，满头大汗，看到大家都向他跪拜，吓得快要哭出来。刘茂对他说：“好好保管符书。”刘盆子将符书咬破，胡乱折叠，然后扔掉，还是跟着牧童们一起嬉戏。</p><p>​赤眉军到了高陵，进入长安城，更始帝投降。刘盆子住进长乐宫，将领们天天聚在一起争论战功，经常喧哗呼叫，拔出剑来砍柱子，难以达成一致。他们还屡次掠夺施暴于官民，百姓关紧门户，从此又都各自坚守。刘盆子十分惊恐，日夜哭泣。刘恭眼看赤眉军中混乱，知道他们必将失败，担心兄弟们要一起惹上灾祸，就偷偷地教刘盆子交还玺绶，学会讲推让之辞。建武二年正月初一，樊崇等举行大集会，刘盆子从坐榻上下来，解下玺绶，叩头说：“如今设置了天子但还是像过去一样做盗贼的事情。这都是你们拥立了不合适的人所导致的，希望让我保存自己的一把骨头，让位给圣贤之人。”说完就涕泪交加，欷歔不止。樊崇及在座的几百个人，没有人不同情他的，都离开座席磕头说：“臣等不守规矩，辜负了陛下。从今以后，我们保证不再放纵。”集会结束大家出宫后，各自坚守军营，三辅地区安然无事，百姓争相回到长安，市场街里又拥挤起来。过了二十几天，赤眉军因贪图财物，又出来大肆抢掠。城中的粮食吃光了，就收罗装载珍宝，又放大火烧了宫殿房屋，带着兵马向西进发。</p><p>​光武帝派遣部队分两路，切断赤眉军的退路。赤眉突然遭遇大军，惊慌恐惧不知所措。樊崇最终带着刘盆子以及丞相徐宣以下的三十多个人赤膊前去投降。献上得到的传国玺绶、更始帝的七尺宝剑以及玉璧各一个。第二天，光武帝在洛水边上陈列兵马，让刘盆子及他的臣子们站在一旁列队观看。对刘盆子说：“自己觉得应当被处死吗？”刘盆子回答说：“臣论罪本该被处死，还希望皇上怜悯饶恕我。”光武帝又对樊崇等人说：“你们可以说是铁中的铮铮上品，平庸之辈中才华出众的人。”</p><p>​光武帝可怜刘盆子，给他很丰厚的赏赐，让他做赵王的郎中。后来刘盆子因病失明，赐给他荥阳县的均输官地，作为商铺区，让他终生享用这里的官税。</p><h2 id="关于刘盆子">关于刘盆子</h2><p>这传记是明显的告诫，刘盆子被选为赤眉军首领，而实际上只是一个傀儡，<br />刘盆子在众功臣宿将面前只是一个“小孩子”，所以挑选你，选你不是因为你功绩滔天，刘盆子只是一个15岁的孩子自是没什么功绩的，但刘盆子还是有的。<br />说回来还是因为你年轻想培养你，坐到这个位置别自以为了不起，天下无敌；<br />能不能在这个位子上坐住，要看你能不能处理好当初起兵的功臣宿将们，<br />既要处理好他们，还要拜他们为师。<br />赤眉军败后，刘盆子自然当不了皇帝了，但是“帝怜盆子，赏赐甚厚”，后因病失明还是被受了赏赐，还得了终身享用官税的商铺区，汉光武既没让他坐牢，也没砍他的头，结局好像不错。<br />但刘盆子的结局是悲剧的，因为他驾驭不住这样一支军队，这样一群的功臣宿将。<br />这支军队后来西入长安，弄得天下大乱。</p><p>农民起义军进城是一个考验，纪律约束只是一时的，没有觉悟便不能持久。<br />刘盆子后来是被刘秀养老死去的。<br />读 刘盆子传 目的是为了告诫，可能成功、可能失败，希望你好自为之。</p><h2 id="下期预告">下期预告</h2><p>洛水河阴白马陈桥。</p>]]></content>
    
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日Emo小短句</title>
    <link href="/2020/04/10/%E6%AF%8F%E6%97%A5Emo%E5%B0%8F%E7%9F%AD%E5%8F%A5/"/>
    <url>/2020/04/10/%E6%AF%8F%E6%97%A5Emo%E5%B0%8F%E7%9F%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>你能翻到这整明你很有耐心啊，说明你对我的Blog还是有一定兴趣的，或者是我直接发的链接。<br />这里记录一下自己在群里的每日Emo小短句，"每日一句emo小短句，我们明日再见。"<br /><span id="more"></span><br />温情提示偶尔伤痛文学一下舒缓压力可以理解，但是不能实际地跟本地解决问题，美好的生活需要自己创造。<br />还有如果你时常心情低落，难受，要注意心理健康，必要的时候要去看医生哦~<br />那么废话结束，我们开始Emo吧。<br /><span class="math display">\[我从未看透，我只想感受慷慨赴死的颤抖。\]</span></p><p>这里只有低级的思考和最卑劣的情绪宣泄，除此之外没有任何文学意义，我所述之一切，不过尘烟。</p><h1 id="独油群每日emo小短句">独油群每日Emo小短句</h1><p>2023/04/09<br />“我好想问一问进入游戏行业打工的愿望就这么奢侈吗？”</p><p>2023/04/10<br />虚拟的数据能分析出我真实的病情，为什么真实的世界却不能带给我一丝虚假的温暖呢？</p><p>2023/04/11<br />人生最大的悲哀也许就是平庸的自己配不上远大的理想吧，纵有孟德之志，却无丞相之才啊。可是即便意识到也在名为平凡的泥潭中越陷越深……<br />这场名为人生的冒险好艰难啊。</p><p>2023/04/12<br />今人又见古时月，古月不救今时人。<br />这里用救字，是我自己对外的求救，是一种直白的表述方法，我希望给读者更强烈的情感冲击，如果追求诗歌的美可以用别的字，比如照、抚、望。<br /><strong>今人又见古时月，古月已忘今时人。</strong><br />这里又想到一句更好的，不知道好不好。</p><p>2023/04/13<br />无能是灼烧我的业火，他人的光辉刺痛我阴暗的鼠目，宏大的理想也变作狂妄。<br />每日一句emo小短句，我们明天日永别。</p><p>2023/04/14<br />浑浑噩噩成了日常，萎靡颓废成了习惯。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/15<br />骑马跨栏的判定太阴间了，cnmd。<br />每日一句emo小短句，今天开始摆烂，我们明天再见。</p><p>2023/04/16<br />小时候父母告诉我要有一颗，像铁一样坚强的心，但是他们没告诉我的是，这世界上磁铁太多了。<br />每日一句emo小短句，今天的emo比以往来的更早一些，我们明天再见。</p><p>2023/04/17<br />好想回到过去，好想变成芝士面包。<br />每日一句emo小短句，我们明天再见。<br />是因为我早就死在了过去，所以灵魂索求着还阳吗？ 2023/04/18<br />我是一个怀旧的人，因为我的未来没什么希望，我在过往的欢乐中，种下了一棵在未来通向衰败的枯树，<br />当我茫然地走上自己铺就的幽暗小道时，我总是回头望去，我怀念那些欢乐的日子，我悔恨那些蹉跎的日子，<br />我在枯树旁的荆棘丛中哭泣，我在梦境的虚幻里沉沦，以忘却这痛苦的生活，在美丽的梦里，我是一个怀旧的人，因为我的未来充满希望。<br />每日一句emo小短句，我们明天再见。 2023/04/19<br />于我而言，生活的琐碎就是一个不断发现自己失败的过程，<br />我时常懊悔无助，但我想，发现自己的失败不应像我一样悲伤、自怨自艾，理当奋起直追、弥补不足，<br />可惜我是做不到的，因为我总是在发现新失败的伟大征程上，义无反顾地航行，<br />我是绘制不出五彩蓝图的幽灵，我已经同海底的死寂共赴沉默。<br />岸上的人不要上我这条残破不堪的船，去在广阔的大海上勇敢地航行吧，去开辟你的新航路吧，<br />鼓足你的风帆去禁受狂风的肆虐，不论前方是文兰或是礁石。<br />“面朝大海，春暖花开。”<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/20同理心是种可贵的品质，我好希望每个人都能有这种品质，这样大家就都会关心我了，可惜我只想着别人来关心我，这样看也许这种可贵的品质我自己是没有的，不知不觉又犯了宽于待己，严于律人的错误，我想我是不配这样的奢望的，渐渐地我便不再去幻想了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/21<br />看到你们美好的生活我真的很羡慕，我也好想和你们一样，虽然理想的工作和实际存在差距，但是能进入自己热爱的行业对目前的我来说就是最大的愿望了，但这愿望终究是小女孩划燃的火柴，在这寒冬中燃不久，便消失了。我蜷缩着身体彷佛看见自己坐在一家游戏公司里，同事都温柔可近，工作生活都很愉快，这样的梦好虚假啊，连我也意识到这是弥留的回光，人们渐渐围在了我的身边，对我指指点点，我依稀听到他们说“活该啊，冻死了吧”，随后我也指着自己说道“活该啊，冻死了吧”。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/22<br />躺在床上怅然若失的望着天空，青春的活力和萎靡的精神在我体内冲突，我同旧厂街过去的哪些青年一样，眼中充满对未来的迷茫，从梦幻中惊醒，面对的是生活残忍的另一面。<br />哪些在镜头前迷茫的青年曾经是一定存在过的，昏暗的室内和朦胧的镜头记录下他们短暂的一瞬，我希望未来别再有他们了，想到这，我再看向窗户映出的模糊倒影，越发清晰却渐渐的陌生了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/23<br />我想，把自己的痛苦与挣扎用矫情的文字表示出来，是不值得夸耀的、甚至是应当感到耻辱的；用人们共同的痛楚去博取同情未免有些太卑鄙了，但我一直都是这么做的。所以我常对自己感到厌恶、对他人感到羞愧；一个真正有爱的、坚强的人，我想应当是在痛苦之中感受、反思；在有所顿悟后，用爱和希望去鼓舞他人，带给他人力量！人们因生活的痛苦而困顿，却也因困顿而坚强，我在生活的沉沦中越陷越深，唯一能带给别人的就是一首赞歌，一首歌唱反抗平庸、超脱自我的赞歌。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/24<br />小短句总是越写越长，可能是因为压抑不住的表达欲和内心深处对于他人认同的渴望吧，写得越多自己向外暴露出的也就越多。向外表达的行为也是祈求认同的过程，是想被他人了解、关心的强烈渴望。<br />所以我决定继续写小作文。<br />我在行动的过程中内心总是充满怯懦，对于自己的目标总是处在一种迷茫的状态，找不到前进的方向，在光怪陆离的森林中不断地徘徊、观望他人的世界，美好的青春和时光就在自己的惘然中眼睁睁的溜走了，直到今日也未能触及心中的理想。如果说理想是名为文兰的陆地，抵达它的过程，就是一场被称为人生的伟大航行，我们时常同海上的漩涡斡旋，和水下的礁石战斗，而脆弱的风帆和桅杆已经在终日地雨打风吹中受伤磨损，但依旧看不见陆地，却常常听闻别人登陆文兰的讯息。有时我会想投入这广袤的海洋中结束我悲哀的航行，或是祈祷一场巨浪掀翻我的扁舟让我拥有退出的理由，但是在朝露打湿我干瘪的嘴唇，在凄冷的素晖映得海面粼光闪闪时，我又在幻想中看见了文兰的影子。<br />每日一句emo小短句，我们明天再见。 2023/04/25<br />孤独是上天赐予我的礼物，死亡是世界给我的解脱。<br />我是有意识的玩偶，在戏谑的闹剧中进行着荒诞的演出，宇宙和眼白是我变态的观众，平庸和愚蠢是他们最爱的戏码。广阔的舞台扭曲我的身体，我的精神不甘地嘶吼，软弱的躯体和颓唐的精神揉搓成一团混沌的烂泥，而这丑陋的模样就是他们解闷的笑料。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/26<br />今天一如既往的浑浑噩噩度过一天可是并没有感到快乐，没有休息也没有玩乐，也没有工作，但是一晃就到了晚上，心中更烦闷了，很疲惫。罗素曾说悲伤让人疲惫，我本不知如今倒是感同身受了，也许我应当痛下决断，去正常的生活。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/27<br />我靠着虚假的希望和混沌的疯狂来麻痹自己，这膨胀的幻想被他人用现实刺破，我沉浸在真实的伤痛里，我的诉说和抱怨都是无用的呻吟，在锋利的剃刀前迎接我的是毁灭的命运，在这口疯狂旋转的大染缸里我只是时代光鲜背后被丢弃的渣滓。我是一个失败者，我决定从这场残酷的战争中逃走，做一个懦弱的逃兵，于是在一个最美丽的清晨，我坐在冲入云霄的花托上，对着太阳说我的故事，和月亮谈我的理想，最后我和风自言自语道“我将走向死亡”。<br />每日一句emo小短句，我们明天再见。</p><p>2023/4/28<br />钟鼓磨灭了意志，平常让人麻木，在平静中一步步走向海的深处，意识到这毁灭的到来，却没有做出反抗，只是左顾右盼地张望，虽然激起朵朵的浪花可脚下的步伐并未停止，沙滩上的足迹被一袭又一袭的波涛卷走，海里的鱼对着断翅的海鸥说，别害怕，海啸会带走一切的。<br />每日一句emo小短句，我们明天再见。<br />生活是一场无法规避的战斗，<br />有的人轻松写意，有的人举步维艰，<br />无论是胜利还是溃败，世界并不在乎，<br />受伤的只有向着红色风车冲锋的傻鸟。<br />每日一句emo小短句被对线爆出金币了。(</p><p>2023/04/29<br />有一条鱼拼命地往渔夫的网口里钻，渔夫把他拎起来看了看，肉少的可怜、长得又颇为难看，“浑身的腌臜味，一看就不好吃”，然后把他扔回了浑浊的泥潭，鱼想着要是自己是一只锦鲤就好了，这样渔夫们都会挣着捕获、是什么“濒危物种”也好啊，可笑的是这年头“濒危”也是要持证上岗的，像他这条只是快死了的鱼，是远远碰不上“濒危”的边的；他望着泥潭外的世界，万类霜天竞自由，飞禽走兽、奇珍异兽，可谓是无奇不有，从蒲公英的耳语中他也曾听闻隔壁池塘和远处大海的景象，那里的水更清澈、那里的水草更细腻，远是比这片小小的泥潭好得多的。他又沉下泥潭里，在他翻身休憩的过程中，他督见一条鱼摆在盘子里，浇上了些许酱汁，被筷子们分食着，“呸，这条鱼刺又多肉又少，还这么腥，真他妈难吃。”，少顷后，盘子里只有被开膛破肚的残羹，一片狼藉。<br />每日一句emo小短句，我们明天再见。</p><p>2023/04/30<br />现在这个世界真有趣，虚拟的东西越来越活灵活现，这块荧光屏幕里的小东西们总是那么动人，比外面的世界有趣多了，盯着这绚丽的光彩久了，现实的色彩便显得灰暗下来了，目之所及便没什么趣味，甚至感觉到些许的烦躁，也有投机倒把的人抓住这追求七彩祥云的心理，造出炫丽门面的假象吸引猎物上钩；也许离现实太久了，生命和精力融进了这块小小的屏幕中，等发觉才意识到，这发光的不是太阳，过于沉迷是会食人心血的。<br />是时候做出些改变了，因为该给手机充电了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/01<br />心中很烦很急，每次总是拖延，最后又是悔过，但是终究不改，为什么我的性格如此低劣。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/02<br />我常用宏伟的目标和理想主义者的虚伪躯壳来遮蔽我丑陋的容貌，然而在这重重伪装之下真实的内心中，是一个彻头彻尾的幻想主义者，我用这些东西来麻痹自我、达到精神世界的超脱，只是假借幻想来满足自我的私欲，就如刘森所言<strong>“你从未看透你只想感受 慷慨赴死的颤抖”</strong>，犹如一片落叶追寻着秋日的肃杀和远方坠落的夕阳，希望毁灭和宏伟能装饰自己蹉跎的一生。<br />面对这样的踌躇，我要抽出宝剑斩断这懒惰的羁绊，随着盖格计数的哒哒声，我要义无反顾地冲向那片红色的海阳。我想在每个人的生命旅程当中难免会有失败、会被路边美丽的风光所吸引，但是每个人都应该拥有鼓起勇气、提起胸膛去修正错误的机会，和对自己人生负责的义务，从今天十点钟开始我就要发奋图强，追回失去的光阴！<br />但是十点钟已经过了，那没关系……我不是今天的十点钟开始，我不定哪天的十点钟开始！<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/03<br />我看着他踉跄地走在铁道旁散乱着灰黄石头的小路上，他的步伐太慢，已经追不上这趟向前飞奔的火车了；他总是提着一瓶酒，那并非笑看生活洒脱自我的、潇洒的酒，而是为了麻痹自我逃避现实所依赖的毒药，最后一次我看见他走在秧歌队里，脸上带着些许的红晕，和花扇一起舞动，他的舞姿无法称为曼妙，只能说是灾难，这最后的放荡自我和追寻解脱的舞让我感到了毁灭和死亡的味道。后来直到今天，我再也没见他了，听说他害了病，也许他死了，不过我想虽然他迈上了死亡，但是终是没死绝的，我看了看镜子，再望了望太阳，我想大抵是如此的。<br />每日一句emo小短句，我们明天再见。</p><p>2023/5/4<br />好怀念小时候，稚嫩的画笔虽然绘制不出写实的画风，却充满着童趣，那是一幅粗糙的蜡笔画，阳光明媚、绿树成荫，背景里奏起的是悠扬的音乐，那时候不知道什么是烦恼，我只负责快乐就好，那个夏日的下午骄阳暖的正好，身上挎着清凉的背心，在可爱明艳的画面中我为了快乐而努力，我似乎还朦胧的记着那些我可爱的伙伴们，我还记得那个美丽奇幻的世界，我的脸上露出了开心的笑容。<br />那时候一切是那么的简单、一切是那么的美好，彷佛一切都是有希望的、一切都是光明的，我怀念那个时候。<br />快乐是怎么样消失的呢？那个无忧无虑的孩子到底去哪里了？我想不通，我不明白，我只觉得指尖有些疼痛，现在才知道快乐原来也是会伤人的，这天真的童趣在我这破败的一生中显得少见而珍贵，我想是不会再有了。<br />每日一句emo小短句，我们明天再见。 2023/05/05<br />自嘲也许也是自卑的一种吧，在别人指出自己的弱点之前先把自我贬低一番，这样他人的批评也就是“自我反思”的一剂辅药罢了，以此来宣誓自我的主导权，也免得自己不那么尴尬。这种自嘲就和舔舐伤口一样，实际上无用，但是甜蜜的鲜血流进唇齿之间时能品到一种满足的滋味，作为痛苦的调剂。自己虽然也知道有缺点、有问题，但是是难以去纠正的，便摆出一副“啊对对对”这般的态度，不过也是应该比被人指出便暴跳如雷要好得多的。极强的自尊也许会使自己很愤怒别人指出自身短板，在时间久了之后，发现自己终不能改正，这种自尊便化作一种自卑了吧，锋利的尖刺就在世故的雨水中慢慢的侵蚀掉了。<br />今天感觉没有那么emo，也许是回光返照吧，也可能是用一天虚假的努力欺骗了懒惰的自己，得到了一丝宽慰吧，所以也就随便写写，我想这事是不能放弃的，因为我已经蹉跎了太多，这小小的玩乐也许能作为我极少的坚持吧。<br />每日一句emo小短句，我们明天再见。 2023/05/06<br />如果我能开花，<br />我会在清晨和太阳耳语，<br />我会在夜晚和婵娟摇曳；</p><p>如果我能开花，<br />我会把思念揉碎在风中，让他携着我的愿望，飘向远方；<br />我会把诗意溶化在雨中，让她裹着我的烂漫，浸入大地；</p><p>如果我能开花，<br />我会把花瓣葬在泥土中，回馈他的恩德；<br />我会把芳香散在世界中，歌颂她的美丽；</p><p>如果我能开花，我将带着马头骨一起葬在海中央；<br />如果我能开花，我将偕同蒲公英一起散在风中央；<br />如果我能开花，我将绽放一朵血色的玉英。</p><p>每日一句emo小短句，我们明天再见。</p><p>2023/05/07<br />人类的SNP排除体外后通过马桶可以全部链接在一起，为什么人类内心的想法不能通过马桶连在一起呢？是因为其实人类只痴迷于肉体的链接，而不在乎心境的联通吗？<br />如果可以的话，我要造一个大大的马桶把所有的心理SNP收集起来，把大家全部连接到一起，就用这条链接彼此的管道，贯穿你我之间的壁垒吧。就算是为了我，对全人类的内心使用发光马桶吧。<br />补充：snp可能是最接近人内在的东西了，想要理解人的内心就去理解snp吧，比良坂曾云“你连心爱的女人的大便都不敢吃，还敢说爱她”，相必背后也是有着这样的哲思吧。(<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/08<br />生活大多都是苦闷，羊只顾着食草，至于草是经过怎样的艰难他是不顾的，在人生的创作中你我虽然是作者，但是很多时候剧情没办法自己做主，名叫老天的混蛋编辑总是喜欢安排一些稀奇古怪的操蛋情节，嘛，迫于种种的无奈，我们也许只能在这苦闷中自己去创造快乐了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/09<br />人生最大的痛苦不是整日都只能陷在悲伤之中不能自已，而是无悲无喜，面对残酷的现实精神和肉体都被摧残的麻木，一切的动荡都激不起涟漪，无论是福是祸都无动于衷。<br />在这样悲喜不加的琐碎平常中我已经渐渐看不清曾经的影像，他慢慢的从我枯燥的生活中消失，没和我道别。他也许就和我一样自私吧，自顾自地离开，而我自顾自地放他走了。我们在这无法言说的默契中被分离了，自他走后我常常忘记了这梦幻的过往，但我有时又会猛地记起，这段记忆就像夏日傍晚时映过窗户的那束橙黄的光——我是记住了的，但却真真地忘记了。<br />“1997年过去了，我很怀念他。”<br />每日一句emo小短句，我们明天再见。 2023/05/10<br />上天曾赋予我天真的秉性让我能发现生活中的快乐，但是现在他想收回这份馈赠，于是便用残酷的现实一点一点磨灭我的心智，但是我不想放手，因为我会再也找不到快乐。<br />可无论我放不放手，都已经不再快乐了，这个世界有太多的难题我解不开了，有太多的问题我不会了。也许我真的不行，但是我不想承认，我知道认输很轻松，但是一旦低了头就再也抬不起来了，我的自信就像在一把锉刀下一点点的磨碎了。不能再像曾经的那个中二的少年一样冲着一无所有的广袤世界大喊了，那样豪言壮志的盛情已经不再了，如今只有被现实打败的萎靡和颓废了。<br />他朝着被夕阳映红的世界大喊，回应他的只有随风起伏的草场和远处寂静的校舍，但是其实他并不在乎有无回应，他只是想宣战罢了。<br />每日一句emo小短句，我们明天再见。 2023/05/11<br />我想喝可乐，碳酸充斥口腔很奇妙，因为很好喝所以很想喝，但是妈妈说不健康呢，而且已经很晚了，所以不能喝呢。如果我有钱的话我会买一瓶可乐，最好是冰的，但是我没有，所以我很想喝可乐。<br />我想如果我长大了就可以喝可乐了吧，但是浑身脏兮兮的大哥哥却说不要长大会很痛苦呢，大哥哥说话很有趣人也很好玩。有时大哥哥会拿一个红色的大罐子和我炫耀说多么好喝，但其实是我知道的，那是他在绿色箱子里找到的，因为我看见过别人偷偷把罐子塞进去，也许大家和大哥哥早就商量好了，在玩找宝藏游戏吧，但是大哥哥每次都不让我找，他总是一个人找，好贪心啊。大哥哥每次都会和我说可乐有多么好喝，但是我一次也没看过他喝过，大哥哥到底有没有喝过可乐呢？<br />大哥哥常常躺在广场上的长椅上，他总是给我看到他在绿色宝箱里发现的宝藏，有园的有方的，又蓝色的有白色的。他总能掏出我没见过的东西，我想他应该是个探险家吧，但是他很多时候总是阴沉沉的而且不准我叫他大叔；他有长长的头发却是大哥哥呢，好奇怪啊，但是却很有趣，可能长大的世界就是这么好玩吧，也许大哥哥是怕我和他抢可乐喝，才害怕我会长大吧，大哥哥好小气啊，我会分给他喝的，因为可乐很好喝所以没问题的。<br />不过妈妈不让我和大哥哥玩，说什么他很脏，可是他的眼睛明明很干净很漂亮啊，为什么妈妈会说很脏呢？妈妈说我长大就明白了，看来还是要长大的，但是大哥哥不想让我长大，为什么呢？这也要我长大之后才明白吗？那我还是快点长大吧，因为我想喝好喝的冰可乐啊。<br />我到底喝没喝过可乐呢……</p><p>其实我就是大哥哥，而写下这些文字的也是我，充满童趣的我和沧桑的我是我的两面，最后一句是我和大哥哥一起的感叹。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/12<br />今天大哥哥没有来，我也没有喝可乐，大哥哥去哪了呢？大哥哥说过他曾经也是有梦想的，但是不知怎么的就变成浑身破破烂烂的样子了，然后梦想也走丢了，梦想是什么啊？我不太清楚，大哥哥是因为有梦想才会破破烂烂的吗？我也经常做梦，我也会变得破破烂烂吗？变得破破烂烂是不是可以变得和大哥哥一样去冒险了呢？<br />今天没见到大哥哥，心中有什么奇怪的感觉涌上来了，大哥哥今天应该是到新的地方去冒险了吧，不知道他明天会不会回来。<br />大哥哥今天还是没有来，是迷路了吗？还是被新的冒险吸引了？不会是一个人偷偷去喝可乐了吧？<br />……<br />大哥哥已经一周都没来了，也许他不会回来了。我想他可能是去找那个走丢了的梦想了，如果是这样那大哥哥就是我的梦想，因为他和梦想一样都走丢了，等有一天，我也去找大哥哥吧。<br />大哥哥究竟喝没喝过可乐呢？<br />每日一句emo小短句，我们明天再见。 2023/05/13<br />大哥哥回来了，但是我没有问他前几天去了哪里，就像我没有问他从哪里来，他也没有说去了哪里。他没什么变化只是身上的衣服换的更轻便了，白色的短袖已经变得灰黄了，他好像很没有精神，我和他打招呼他也只是木讷的回应，他是怎么了呢？大哥哥变得和其他大人一样了，总是面无表情、无精打采的样子，可能只有拿红色的可乐罐才能把他明亮的眼睛变回来了。也许大哥哥只想快乐，但是繁重的现实令他无法超脱，难道源自内心的欢愉只能依借外物来所求吗，难道精神的享受只能由物质带来吗……我想不是的，但是精神的交流和思想的碰撞是难得的追求，所以我只能用物质的华丽和感官的疯狂哺乳我混沌的精神。<br />所以，我想喝可乐。<br />大哥哥究竟喝没喝过可乐呢？<br />每日一句emo小短句，我们明天再见。 2023/05/14<br />今天是阴天，我一如既往的去广场找大哥哥，大哥哥一如既往的瘫坐在长椅上，他灰暗的眼睛里映着被天空压得蒙蒙的广场，蓝色的建材旁没有曾经嬉戏的孩子们，只有略带潮湿的风抚摸着我的脸。大哥哥没有理我，自顾自的唱起了歌，但我听不太清，不知道唱的什么，他萎靡地神往、我无措的徘徊，很快淅淅沥沥的雨散在我的肩头，我转头逃走了，我可耻的遁走，我又羞愧地回头望去，大哥哥已经不见了，我有些怅然地走在雨中，唱起了歌。<br />“没有花香，没有树高，我是一棵无人知道的小草……”<br />下雨天很凉，所以我自是又一天没有喝到可乐的。<br />大哥哥究竟喝没喝过可乐呢？<br />每日一句emo小短句，我们明天再见。 2023/05/15<br />我是新时代出土的崭新古老废柴，在泥土捏住的废墟中起身后，在绚丽的装饰中不知所向。一面是小县城日趋衰败的丧钟，一面是城市钢筋的逼近和霓虹的威慑；一面是无所适从的现实破烂，一面是歌舞升平的虚拟狂欢；一面是家庭崩塌的通牒，一面是生存无计的惘然；我和马大帅一样在这个崭新的世界无处藏身，生活的琐碎片片地压在头上，无处藏身、无地自容；被迫在这个混沌的垃圾堆里左支右绌，希望能找到点活下去的办法，可迎来的只有广厦高楼里传出的欢乐，连一生讥笑都没有、没有回应就是世界给我最后的回应。我面对宏大时代产生的困窘太大了，大到我不知道怎么形容、我不知道怎么表述内心的感受，但是这种困窘又太小了，小到别人看不见他。<br />”而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。“<br />也许唯一幸运的是，迫于我的精神状态和身体原因，至少还有人能对我展露出一丝理解的姿态，不知是自愿还是出于道德的被迫，想到这里我更加悲伤了。如你所见，宽容和理解也可以作为伤心的利器，温柔和体贴也会带来痛苦，而咒骂和拳脚更不必言说。我想我病了，我在最嘈杂的时代失声，我在最杂乱的树丛迷路，我，一个崭新出土的时代废柴。<br />“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”<br />这一天，我23岁，在我一生的黄金时代，我有好多奢望——<strong>我渴望死亡</strong>。<br />每日一句emo小短句，我们明天再见。 2023/05/16<br />在无数次的失败中我知道的，其实是我自己的问题，怨不了天也怨不了地，“废话，你不过不是你的问题，还是我的问题吗”，也曾无数次的被讥笑过。人生也许就是这样吧，在浑浑噩噩中就突然直接没有了能前进的路，我的生活就像窗外黑沉沉的天气一样，已经走向了全部哒咩的end了。在这场没有鲜血的残酷竞技中，输家是没有发言的权利和表演的镜头的，我走在自我否定的螺旋中，在如海般的寂寥中下沉。我不害怕挑战，我畏惧失败；我不会失败，因为我总有借口。借口是一把刀，用它来逃避，用它割碎我的梦。我是人生的懦夫，我是战场的逃兵，我是竞技的输家，我是新时代鼓钟旁最丑陋的尸体。<br />我已经死亡。<br />每日一句emo小短句，我们明天再见。 2023/05/17<br />我好像做了一场梦，<br />在混沌的梦中我看见有人刨开垃圾堆寻找着残羹冷炙以求果腹，有人倒在街头红色点缀天空，<br />在糜乱的梦中我看见贵族门阀极尽奢华，<br />在无助的梦中我看见一个人茫然的站在风中眼神中无悲无喜，<br />在无尽的梦中我看见一个个荒诞的轮回，一股股鲜血浇筑这片大地，可是没有什么神迹，这炽热的血很快就被衣冠禽兽的虫豸吸食干净了，<br />在衰败的梦中我看见一个个消瘦的皮囊，<br />在梦中我看见了一场梦，在朦胧中我依稀听见不能言说的蛊惑。<br />在这荒诞的梦中我醒了过来，看见了一场真实的梦。<br />每日一句emo小短句，我们明天再见。 2023/05/18<br />梦幻的灯光在淅沥的雨水映衬下更外动人，<br />今夜天空没有月亮也没有星辰，面对这美丽的人类荣光，他们自然是羞愧的躲起来了，<br />水浸的马路映出如幻般的城市炫丽，耸入云宵的是无法逾越的高塔，<br />现代的奇迹循着古时的悲哀螺旋上前，<br />但这一切的磅礴都是他的背景，他从那灰暗的角落露出身来说<br />“城市的绚烂霓虹照不到我们的黑暗生活”<br />是的，无论远处的光多么妖艳，无论多少个日夜在天空上接力，这残破的窟洞也未曾见过一丝光明。<br />上个世纪一个孩子对父亲说想成为艺术家被暴打了一顿，这个世纪一个孩子想成为艺术家却没有道出，时间的分界就如同一面镜子照出相似的彼此，我们怀着同样对理想的执着，然后被生活打击到失去对一切的热爱，在无数的悲天悯人后激发出愤恨与悔过，昨日的夕阳是今朝的晨光，今日的余晖是明早的梦想。<br />每日一句emo小短句，我们明天再见。 2023/05/19<br />世界总是充满着变化，把自信好强变为偏执自卑，生活的作弊就在于把困苦转嫁旁人，在从襁褓中慢慢褪去外壳面对这疯狂的一切时，正常的精神认知早就沦为玩物，巨大的手抽离矫造着癫狂的心智，若如是亦无需置论，却有得意者假借他人的痛楚予以调味，痛苦后深层的哀伤他自然是不懂的，只觉得好玩消遣罢了，我的肉体、我的精神、我的心智都被这疯狂的世界夺走，而这躯空旷的泥瓦罐也只能装满癫狂的海水。<br />把我的一切还给我，还给我吧，那年轻的亲人，那些离去的人，那无忧无虑，那个没有丑陋伤痕的我，我会在那最美的瞬间按下暂停，哪怕这是永恒的死寂，也比这无尽的疯狂来的更有意义。<br />“因为再往后就是只有失去的现实”<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/20<br />坏了，把每日一句给忘了……就连这么重视的事情都在昏昏度日中忘却了，我想我没什么可以辩解的了，之前那么忙都想的起来，现在休息了一天反倒忘记了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/21<br />我不知道是我萎靡的精神导致我诸多的失败还是我那不顺的过往导致我失去活力，我唯一能确信的就是在这个疯狂而糟糕的社会中，我的失败和顿挫不会就此止步，目光所及的未来是一片狼藉，在他人蓬勃一生开始的年龄，我的生命已经所剩无多，迎来的并非接近疯狂的不甘，反倒有种解脱的释然——终于能从这混沌中离开了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/22<br />我的人生就和我破烂的电脑一样，也许在某一天，就突然开不了机了，光怪的屏幕里堆满着无用的别人毫不在意的垃圾，这狭小的窗口成了井底的死尸观望广阔天空的井口，可笑的是我的电脑可以因为莫名其妙的原因黑屏宕机，我却卑微地不敢指责他；而我荒诞的生活已经不能继续却仍要强撑，我却严格的咒骂着自己。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/22<br />我是如何的失败我自是清楚不过的了，我是如何的无能导致我这般的颓丧，在这场只有lost的游戏当中，会有人乐在其中吗？我只是找不到完美的退出方式，却又没有直接关闭电源的勇气罢了。<br />我当然知道自己多么可笑，我当然知道自己是如何的软弱，用结束去要挟一切就是我最大的勇气，我不过是一个疯狂的病人，在试验田的舞台上做最癫狂的表演，我不配在这个陆离的世界中拥有聚光灯，我只能在底层的泥泞中失去我曾假借的一切。<br />如果我这极致的失败、这几乎疯狂的精神是独一无二的，是否我也能说自己拥有过人之处，而显得不那么狼狈？如果曾有人和我一样，是否说明我不过如此，而我所相似的那个他是否比我更加悲哀，毕竟我只配做别人的影子，从来都是我像别人，我只不过是后来的低劣、无能地模仿着。我面对这一切真的累了，我想我的Quit就是电源键了。<br />每日一句emo小短句，我们明天再见。 2023/05/23<br />电脑因为C盘的爆满而黑屏宕机了，不过经过他自我的紧急修复又腾出几个G的空间，彷佛一切都可以继续，只是我不知道黑屏的时间里电脑失去了什么。<br />如果世界黑屏宕机了是不是第一个删除的就是我呢？之后的一切都会照常进行但是不会有我了，而世界应该也不会在乎。<br />电脑比我更会内存释放，也许他比我更配用电脑？那为什么是我在用电脑？还是我在被电脑使用着用电脑。我不知道，我只能借着胡乱的思考来假装对生活的深思，用故作高深来麻痹自己的浅薄。<br />电脑黑屏宕机能修好继续，我的生活可以吗？我能修好他吗？或许根本就没有修好只是出卖了什么东西而我并不自知罢了。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/24<br />人生的一切可能都会在平常和迷茫中渐渐磨灭，在物理角度看熵增的世界以混沌为食，所以一切的荒诞和疯狂似乎都理所当然，而在这如黑暗般的一切中是曾有过耀眼的光辉的，宛若一颗流行划破漆黑的夜幕，似乎是黎明的到来，而那光亮往往被周围的雾霭所吞噬，“面对我们的骨灰高尚的人挥洒下热泪”，我并不高尚，我的泪是因为惋惜和痛恨。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/25<br />浸润着都市淅淅沥沥的夏雨，朦胧的雾气蒙上了我失明的双眼，<br />肉体和灵魂在此刻分割，我昏昏的青春倒进这炫丽的城，<br />外边是奔波的迫切，里面是梦寐的挣扎，<br />我在月光铺就的路上疯狂的向前奔跑，<br />甩开身体、甩开安睡、甩开梦想、甩开月亮，<br />在这个千年之月和都市夜灯共同辉耀的雨夜，<br />我甩开自我，奔向月亮。<br />在月亮上，我抱着干瘪的红薯，离月亮越来越远。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/26<br />原来快乐也使人堕落，所谓生活就是在一团混乱不堪的琐事之中挣扎，最终结束的过程。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/27<br />生活的痛苦就在于，处在毫无新鲜的平静中疲于奔命。人们渴望改变却又不希望动荡，人们希望安慰却又不希望枯燥平常，每天的生活就像一条可以看见的、逐渐平缓的线，渐渐的没有波澜、没有改变的可能，一切都走向热寂。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/28<br />在不舍和茫然中踏上了旅途，途中我看见拉满羊的货车，货车上的羊在想什么呢？我和羊有什么区别呢？我们都在无形的压力下被迫登上这辆不知终点何方的列车。最终的结局都是被残酷的刀屠戮殆尽，我想我和羊是没有区别的，想到这我不仅的发出”咩“的一声。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/29<br />我悲哀的一生还未开始就已经结束，别人的起点是我一生都难以企及的高度，人生就在一个个不知不觉慢慢的错开了，等意识到时已经无可挽回，别人都在一步一步的积累着成功而我一步一步地迈向失败，面对我一团乱麻的生活我只觉得悲哀和无助。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/30<br />在旁人每日的伟大进度推进时，我无忧无虑的快乐时光就一天天消耗了。我曾经是开放世界里那个无忧无虑的孩子，每日在和煦的阳光下踏上去学校的乡间小路，但是残酷的勇者一天天坐着篝火，我不多的童年急速地消失了，我只能看着我变得不再快乐，烦恼和忧愁日益增多，但我什么都做不了，因为这个过程叫做长大，在长大的过程中我要独自面对一个藏在安全屋外数年的劲敌叫生活。<br />每日一句emo小短句，我们明天再见。</p><p>2023/05/31<br />人与人之间的差距实在是太大了，这巨大的鸿沟令我难以逾越，他人数倍、百倍于我的智慧和实力地位，我所有的一切别人只不过弹指之间，而我唯一的成就只有拼命地活着。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/01<br />第一步:沉淀。<br />第二步:那场寒冬毁了我的游戏梦。<br />第三步:黑作坊也能做游戏。<br />第四步:两年换皮游，一生氪金情。<br />第五步:游手好闲也是游！<br />第六步:Steam我想你了。<br />第七步:独油炒粉。<br />第八步:城管太凶了，独油地摊。<br />第九步:经济不景气，独油代驾。<br />第十步:吊销驾驶证，碧桂园五星上将<br />第十一步：指点天天打游戏的业主，欺负骗氪的策划狗，遇到危险全身而退。<br />第十二步：若Jam召必回。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/02<br />我好像丢了什么东西，或者缺了什么东西，但是我不知道那是什么，我想我找到它一切都会好起来，但是我都不知道那是什么，我只是茫然。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/03<br />分别的日子日渐近了，我不想那一天到来，却无法阻止，这就是生活、这就是长大，不再无敌，事情不再和美好的想像一样。但我不会忘记，我是活在过去的人，所以我不会忘记。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/04<br />相聚的时间不多了，结束的那一天一步步到来，我不能阻止这别离，也看不到未来的希望，渴望着更好的明天会到来，但不论我的期望如何混沌的未来终将如期而至，“正义会在正义的终点等着所有人”。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/05<br />现实不能靠勤劳致富，所以我想在游戏里满足一下这个心愿。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/06<br />今天是个沉重的日子，不仅因为分别的日子更近了，还有一位同系的同学和这个残酷的世界做了最后的悲惨的告别，生命的沉重和死亡的压抑在这一刻涌上来心头，强权和威压摧残了一条鲜活的生命，我曾想人终是要积极的面对生活，迎难而上的，即便结果是惨败，这样的冲锋至少能让自己以英雄的身份离开；然而残酷的现实是脆弱的身心可能根本抵不住生活的压力和强权的逼迫，稚嫩的生命所留存最后的坚强只有纵身的勇气。<br />我不配去理解，我只感到悲伤，希望每个人都能拥有美好的生活，希望每个人都能有幸福的明天。<br />也许之后，他们会给你看论文、帮你改PPT、平台审核第一时间进行，但这都是因为有鲜血来过这里。正义会找到的，一 直沿着海 滨找到他的终点。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/07<br />回到学校这几天总是打游戏，完全无心学习，明明自己的人生已经是一塌糊涂却还是一副等死的样子。我这样的人注定是一团垃圾。<br />每日一句emo小短句，我们明天再见。</p><p>2023/06/08<br />我以前一直不懂克苏鲁，现在我明白了我的克苏鲁就是生活当我看见他是，那无法用语言描绘的疯狂就充斥在我的大脑中。我处处低人一等没有人认可我，我就是一条处在社会底层的虫子，面对这样的现实我陷入深深的自卑，我想过改变却没有成效。这混乱疯狂的一切，血淋淋的才是现实，幻想和谎言所修饰的只是最悲惨的故事。</p><p>2023/06/09<br />一切都要结束了，我最美好的过去就要画上一个句号。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/10<br />离别总是匆匆，形形色色的人各自奔向自己的前程，回想我的当今犹如一团烂泥，我做什么事都是半成不就，烂透了的样子，这样满身疮痍的我将要迎接一段注定会满是烂泥的人生，我想不如轰轰烈烈地死去来的痛快一点，在我这样胡思乱想时，离别的匆匆又渐渐地近了。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/11<br />我只能说个人的职业选择和社会环境密不可分，每个人的选择都情有可原，但是可悲的是九品中正制，各大门阀家族互相举荐，构成自己错综复杂的利益网络，朝廷官员冗余等问题，大清已经烂透了。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/12<br />我转过头去没有看他，我坐在共享单车的座垫上，看着这个颓唐的小镇中心，脑中不知道在想什么，却又感觉有万般思绪涌上心头，我盯着天空，不知不觉地就留下泪了，从此一别我想不会再见了，他会有新的朋友，新的美好生活，我的好朋友又一个离我远去了。我哭得更伤心了，我想这就是分别的感觉吧。今晚的小镇一如既往，没有什么新鲜的事发生，只有一场无可奈何的雨，在月光满轮的晴夜落下。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/13<br />所有年轻的人啊，不要长大，所有年轻的人啊，不要让生活夺走你的梦想，所有年轻的人啊，不要成为我这样的人。<br />所有年轻的人啊，长大是件悲伤又无可奈何的事，长大意味着你不再无所不能，曾经的无限活力都变为深深的无力，长大意味着生活很可能会夺走你的梦想，长大意味着你可能会不再是你自己，意味着你可能会成为自己最讨厌的人和那场美好祥和的梦越走越远。<br />所有年轻的人啊，不要长大。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/14<br />分别和重逢相冲突在这一刻我不知道是该悲伤还是快乐，我的心中充满无措，我其实一直都是个天真的孩子，本就没准备好去面对这一切，生活不像game那样有趣还可以重来，面对未卜的多艰和枯燥的死寂，我每每消沉，这欢聚只是短暂的，离别又近了一天，欢乐和悲伤浇筑出一杯苦涩的酒，我的脸上没有了表情。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/15<br />回到这最温馨的地方，我终于感到了放松，哪些令我烦恼的、令我悲伤的我仿佛都看不见、听不到了，在这短暂的快乐的时光中，我应格外珍惜，因为这美妙的一切都将要离我而去，这曾经最不以为然的平常，从今往后也许就是我最大的奢望，我爱你我的爸爸，我爱你我的妈妈，我厌恶它这可悲的生活。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/16<br />时间总是无情，岁月给心爱的人平添了伤痕，看到她瘦峋的样子和手背上青色的血管、白色的胶带，这个面露苍老的人已经不再年轻了，我所爱的人都回不去了，我最无忧无虑的快乐日子也不在了。每感时光飞逝的无力，才知亲情的可贵，回家的路上我想说“我大姑老了”，但我终究没说出口，我极力让自己不去思考、不去悲伤，我想我的父亲会说“别太愁了，儿子”，而我会回道“你也是”。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/17<br />有时提笔真不知道写些什么，但觉得这写些东西的习惯自是不能丢掉的，毕竟已经别无什么长处，唯有这一点还能作乐给自己些许的开脱，也算是一种倾诉，不过没有人聆听罢了。最近都在打王国之泪比较放松，没什么思考，没什么感伤。只是觉得王国之泪很有趣，玩起来很忘我，但是再也没有当初第一次玩旷野之息的震撼来的猛烈了，倒不是麻木我想，应是自己“脱敏”了，见识到的也有些了。所以智慧、快乐、财富对大多数人而言其实并不是能全部得到的，不过像我这样一无所有的倒也是少见，也许我可以领个勋章，毕竟在这个物欲横流的社会中，我也是个不小的珍稀物种。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/18<br />“公道不在人心，是非在乎实力”——《笑傲江湖·东方不败》，正义和公道只是小孩子的游戏，在这个世界上那只不过是可遇而不可求的奢望，在这波涛滚滚的江湖中，有太多的不公了。天下英雄又有几人能够笑傲江湖呢……<br />每日Emo小短句，我们明天再见。</p><p>2023/06/19<br />我喜欢下雨天，因为可以随便哭，雨落在脸上也没人知道那是我的眼泪。<br />每日Emo小短句，我们明天再见。<br />句子不在多寡，兵刃不在长短，功力一到，便可力通人心。</p><p>2023/06/20<br />我知道的，在雨里能蒙混过关的只有我糟糕的人生，想流泪的话就放声哭泣吧，即便是阳光万丈的日子。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/21<br />我觉得自己再一次放松了，沉浸在混乱的日子中，这种生活就像是沼泽，不知不觉越陷越深，想改变却做不了什么。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/22<br />有时候隐瞒是一种让事情更混乱的方式。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/23<br />也许现要承认自己的无能不足才能更好的前进，每日的emo感觉更像是命题作文了，思考一些东西，然后记录下来，也算是一种对写作的锻炼吧，不过断然不是日记的，这种东西还是太……做作了，最近没有什么灵感，也很少思考，所以笔下也都是些鸡毛蒜皮了。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/24<br />一味地恐惧担忧未来是愚昧的，“不看当下而盼未来，不看未来而盼过去。”，恐惧来源于未知，而未来永远未知，原地踱步永远无法克服这种担忧，而解决这种忧虑的方法就是行动，基于当下去行动，总是思考担心并不能让我们认清未知，只有一步一步地向前迈进才能揭开未知的面纱，把曾经的忧虑变为当下或过去的不足为奇；当然不是说毫不思索上去蛮干，而是要有一个核心的思路方针，所有的行动都依赖于它，并在实践的过程中不断修正，我想大概应该是这样的。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/25不看当下而盼未来，不看未来而盼过去。<br />如雷灌顶，我就是一个怀旧的人，总是回忆过去，对现在麻木，对未来迷茫，我一直觉得我的生活充满了绝望，想做什么都不敢开始，也没有坚持，也不知道自己怎么就变成了这个样子。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/26<br />我终于知道梦想在生活面前是多么无力梦想只是自我的虚幻，而生活是庞大的真实，这份真实的重量无比沉重，它变成一个黑洞吞噬了所有的一切。<br />这是我在家的最后一个日子，也是我最后的无忧无虑的日子，面对我最爱的父母和未来未知的生活，我的眼泪止不住的流。<br />我不知道什么毁了这一切，然后把它灌满了悲伤。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/27<br />后来我才懂得那些我不曾理解的文字背后的含义，当再次回想时都有了不同的感觉，可惜的是人很难跨越地成长没有经历便没有体会，我终于明白了初读不识文中意，再看已是剧中人。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/28<br />我的父亲中午只点了一份白米饭加小葱拌豆腐，这洁白的一餐就如同他洁白的一生，我想说“你怎么不多点几个菜”，但我想我是没资格说的，彷佛他少吃了一些这个举步维艰的家就能多往前走上那么一步，我想了良久不知道说什么，只能打出一串省略号“……”。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/29<br />我来到这陌生的城市看见了不同的人，有暴躁吼人的大巴司机，和对我网开一面的保安，和提示我的路人，收留我过夜的华莱士服务员，帮助我使用优惠的店员以及想帮我省钱的打工小哥，和太阳下辛苦的外卖员，在这里我看见了各式各样的人，在这里我看到了那么多我不曾看到的。<br />每日Emo小短句，我们明天再见。</p><p>2023/06/30<br />Before was was was, was was is.<br />逝时曾是时。<br />一颗玻璃球在液压机的压力下可能会瞬间粉碎，但若是一把玻璃球那是击不碎的，一个人也许抵不住那可怕的压迫，但是千千万万的人民群众团结起来时一切的压迫都不足为惧怕。<br />每日Emo小短句，我们明天再见。</p><p>2023/07/01<br />茫然地走在这陌生的街头，世界上的一切都和我息息相关却又毫无关联，我找不到未来，只觉得生活的悲哀。<br />每日Emo小短句，我们明天再见。</p><p>2023/07/02<br />我不懂得这陌生的一切，我所了解的只有我卑微的生活，机遇被乌鸦叼走，苦难留我独自品尝，不甘和焦虑灌注满我的心头，我的泪已经不再流，时代飘落在人上的从来都不是一颗沙，只不过是有的人在山顶而我在五行山下。<br />每日Emo小短句，我们明天再见。</p><p>2023/07/18<br />如果死亡，也许会有人为我流泪；<br />如果死亡，也许会有零星的人感伤；<br />如果死亡，也许会有人诧异；<br />但是，我仍苟延残喘，<br />活着，便没有人去关心；<br />活着，便没有人开始理解；<br />活着，便没有死亡。<br />活着，便是死亡；<br />所以死亡不必落泪，因为我曾获得了悲伤。<br />每日Emo小短句，我们会再见吗？</p><p>2023/07/21<br />我小时候总是幻想未来的自己会穿越回来把我杀了，现在我才明白，如果我回到过去，可能会哀求小时候的我把长大的我杀掉。<br />每日一句emo小短句，我们有缘再见。</p><p>2023/07/25<br />我走到路口，落日低垂和红色的灯光相得益彰，零散的人整齐地插在路旁，头垂进手机里。<br />在这规律的耕作旁倒也是有别样的风景，一辆黄色的环卫三轮，上面有四五个大叔，皮肤已经变得褐黄了，我偷偷看着他们，假意望向空荡的路口，目光触及到围栏里的楼，就在这落日下他们望着西边的远方，我望着繁华世界中的荒凉，然后灯变绿了。<br />每日一句emo小短句，我们有缘就会再见。 2023/08/04<br />初中读《我是猫》时倒也谈不上多么被惊艳到，现在唯一能回想起来的就是，那个在猫眼中一切祥和安适的氛围。<br />如今我却真真切切地想变成一只猫，我不知道我是否怀着和夏目漱石一样的心情，但我总会回想起那个夏日慵懒的午后，翻开那本厚厚的书一页一页地读着，那时候我应该没有那么多烦恼，回忆为房间铺满了温柔的阳光，眼中的一切只是宁静和美好，就像那只猫一样。<br />夏目漱石先生，我想变成猫。<br />每日一句emo小短句，希望陌生的你可以像猫一样，充满童真和快乐，我们会再见，哪怕你不记得我。</p><p>2023/08/08<br />生活也许会欺骗你，也许会愚弄你，你可能对一切都感到绝望，但是别像我一样沉浸在悲伤中妄想活着的感觉，爱自己，我的朋友。<br />每日一句emo小短句，我们偶尔见上一面吧</p><p>2023/08/11<br />苍天已死，黄天当立。<br />岁在甲子，天下大吉。<br />今天偶然看到了13年的一个交友贴，我仿佛能看到有一群拥有共同爱好的人聚在一起，那热闹的气氛，但9年过去曾经年轻的人可能已被生活催的岁月已老，不禁感叹这群互联网遗老会不会偶尔怀念过去，是否我们曾怀着同样的心情看过去、望未来。点开这崭新的古老链接时，能看到的也不过是独属于那个时期的一个又一个有趣的灵魂罢了。但是也可能由于重拳或压力，现在望去，曾经热闹的讨论版如今也不过是纷繁混乱的网络世界中，又一个少缺人烟、落满时代尘埃的犄角罢了。<br />每日一句emo小短句，神马都是浮云。 2023/08/20<br />cheems早就不是表面上那一只普通的柴犬了，<br />我认为这是一种文化现象或者浪潮，他已经成为了一种意象，其中最为珍贵的是cheems浪潮传递的那些思想和被人们带来的激励、感动。<br />当他被遗忘时，才是他真正死亡的时候。<br />存其意而忘其形，如果你活着你早晚都会死，如果你死了，你永远都活着。<br />cheems的离世无疑是一件让人悲伤的事，但是我会记住这一切。</p><p>见过互联网的波涛汹涌后，已经习以为常，光怪陆离、充斥着荒诞的新世纪发生什么都不足为奇，在这个美妙而不知所向的时代里，我被赋予了一颗石之心，麻木地感受着无数的悲与喜。<br />每日一句emo小短句，今日突袭群友！劫营速战，措手不及。<imgsrc="D:\biancheng\Blog\source\imgs\每日Emo小短句\F1SZC9%7DW%7D_XEA5S%5D5FCJM3.png"alt="img" /></p><p>他们都太优秀了，优秀到被照到的我居然以为自己也能成为一颗星星，突然有那么一天就被随意的聊天惊醒了，什么星星啊，原来我还是那个在下水道里发臭的垃圾啊，如今切实地体会到那句话了“天才这种东西，常会不自觉地将周遭的人卷入，然后弄得遍体鳞伤。越是靠近，越会被撕裂成碎片。”，等回过神来时已经菠萝菠萝哒了。</p><p>2023/09/01<br />"我爱你。"<br />你可能觉得奇怪，也可能感到突兀或者冒犯；但是有时人们之间确实会有那种莫名的憎恨，甚至没有任何理由，所以我想人和人之间也会有这种不需要理由的爱。可能这种爱并非是深入骨髓、刻骨铭心的海誓山盟，更像是一句寻常的关心，哪怕是一种冲动。<br />然而，如果这份爱是虚假的，那我希望那莫名其妙的恨也失去意义。<br />每日一句 emo 小短句，我们有缘再会。 2023/09/02<br />触不可及却刻骨铭心，生活的无奈就在每日的平凡中展开，<br />我们也许都在做着正确的事，但悲哀的是当我们彼此交汇，这本该在时间的河流上编织的诗歌如今只有混沌。<br />“如果我不直播了 我可能会突然上个厕所 然后再也不回来了”<br />“泥头车每天还是准点来，只是车上再也没有那个女孩的身影。如果当初知道，应该放下一切，上车，不再回来。”<br />“圣地亚哥在下雨，智利别为我哭泣”<br />每日一句 emo 小短句，我们有缘再会。 2023/09/04<br />狗彘食人食而不知检，途有饿殍而不知发<br />指望资本主义的走狗良心发现简直是异想天开，为自己徒增烦恼，要明白谁是敌人，谁是朋友。<br />团结一切可以团结的力量，打倒所有的敌人。 2023/09/29<br />爱而不得才是常态，充满遗憾就是人生；<br />壮志未酬不过稀松平常，苦海无涯乃是我的命运。<br />“试问天下英雄又有几人能够真正的笑傲江湖呢”<br />我原以为自己这卑劣的样貌不过是不讨喜，对于旁人也不过是稀松平常，没想到自己竟然如此的令人恶心。在这昭然的事实后展示出的是这场淘汰机制的生存竞争，从古至今一刻不停。可悲的是，无论你赋予生命怎样的意义，在这场追寻宇宙真理或生存真谛的比赛中，败者只能是一无所有，直至死亡，所有的思辨最后恐怕都是自我安慰，一次名为自我欺骗的“和自己和解”。<br />在这场比赛中，我从来没有获胜过，我只是个loser所以我恨，我的立场不是中立，因为我尝尽了悔恨、嫉妒、憎恶的滋味，那必定不是甘甜的也不是苦涩的，而是刺痛。<br />每日一句 emo 小短句，我们有缘再会。 2023/09/29<br />当我蜷缩在这大到无边城市里阴暗的一角时，我想起了那句台词<br />“我要这满城的人都来陪葬”<br />“千里皇城尽作焦土”|<br />我仿佛能理解李儒的焚城决策，但我没有那样的智慧，我只有偏执的疯狂。<br />每日一句 emo 小短句，我们有缘再会。 2023/10/06<br />有时候我们耗尽一切都得不到自己渴望的东西，其实这才是生活的常态，长大的世界就是求而不得、学着放手；不知不觉我们都不再是那个哭哭闹闹就能得到冰淇淋的小孩子了，那种无忧无虑的时光最后只能成为宝贵的回忆，让我们在痛苦的现实中去怀念、去流泪。<br />不过我没吃过冰淇淋。<br />如果不用上班是否所有的悲伤都会变作欢乐呢？<br />今日 emo 能量赞助来源，歌曲《Duvet》，演唱者 Bôa，别名《TVアニメ「serial experiments lain」OP1テーマ》，收录于《TallSnake Ep》专辑中。(就是《Lain》的 OP 哦)<br />每日一句 emo 小短句，我们有缘再见。</p><p>2023/10/15<br />从互联网文学，到农村纪实(在如今这个城市化程度很高的时代，还有人去关心乡村去记录现实，我是表示敬佩和珍惜的)，再到修正主义和牛鬼蛇神，再到过去的抗争记忆，再到古代新学和现代桎梧，还有当下未来的科幻，一切都与我无关，却都发生在我身边。<br />[图片] 已过期</p><p>2023/11/02<br />清醒令人痛苦，麻木使人沉沦，人记性太好会很痛苦。<br />每日一句 emo 小短句，我们有缘再见。</p><p>弱智吧小集合<br />敬老院的新人都是老人，这个世界的大人都是小人。<br />所有的桥都是温暖的，因为他们让河流不再难过。<br />从我确诊出生的那一刻，我的死亡就只是时间问题。<br />皱纹是时间吹过身体时泛起的涟漪。<br />月亮——摘自《星空》<br />看到花开放时，花就已经在枯萎了。<br />我的梦想是一对情侣，白天我压的她说不出话，晚上她压得我难以入眠。<br />我最新的照片是我最老的照片。<br />生鱼片是死鱼片。<br />世界是个大象，我们每个人都在盲人摸象，抽象是对世界最好的鞭笞。</p><p>2023/11/19<br />我已经燃烧殆尽了，只剩下雪白的灰。<br />燃え尽きたぜ…真っ白にな…</p><p>如果只能有一个李哥，为什么不能是我李元浩的李。<br />这可能是你唯一的机会了，小虎。<br />也就是说，现在是LPL苍蓝猛虎登场的时候了。<br />昼虎！夜凯！<br />地虎铠甲，合体！</p><p>小虎需要这个冠军来证明自己。</p><p>2023/12/15<br />害，卡姐真的是太惨了，幼年丧母，青年丧父，碰到了戈塔屎，以为是好人结果被坑了。<br />到博德之门后，她对死去的父母，以前的朋友都是在做死前的最后道别。<br />在饭店的夜里，她说干净床单的味道能让她想起妈妈，因为她妈妈是一个洗洁工，她畅想假如自己还有50年，未来会有多么美好……<br />但是这一切注定都是悲剧，逃窜到最不愿回首地狱也不过是在惨淡的命运驱使下痛苦地活着，“再见，大海。再见，太阳。再见。”<br />我爱你，卡菈克。</p><p>203/12/17<br />如果没有遗憾，我是否还会爱你？</p><p>2024/01/08<br />在最黑暗的晴空万里我为太阳哭泣，如果明天我不再升起，<br />请别为我忧郁，<br />如果明天我不再呼吸，<br />世界请为他人欢愉。<br />在麻木和壁垒中流浪，清醒让我渴望死亡。<br />如果懦弱是种疯狂，麻木是否已经渗入我的骨髓。<br />我渴望哭泣，我渴望结束，我渴望渴望。<br />每日一句 emo 小短句，我们有缘再见。</p><p>2024/01/20<br />哦，妈妈请别为我哭泣，我们将回到故乡。<br />读哈马斯的勇敢有感。<br />每日一句 emo 小短句，我们有缘再见。<br />神只是人类美好的倒影，至少于我而言，最伟大的是人类历史中那些充满勇气的瞬间。</p><p>2024/05/10<br />原来幻想中反派听到音乐被迷惑困住甚至感悟的情况是真实存在的。<br />当我听到童年熟悉的音乐才知道自己再也回不到那个，炎热却温暖，茫然却快乐的日子了。<br />我在熟悉的旋律在忘却了当下，只记得那个温和的午后，<br />我被这悠扬的笛声困在了过去，又逃不出现在，<br />这是一种奇妙的感觉，温馨快乐做了泪水的底料而悲伤洒在了我的脸颊。<br />https://www.bilibili.com/video/BV1dy42187pm<br />每日一句 emo 小短句，我们有缘再见。<br />对了，也许我的可可果已经熟了吧。<br />难道人生注定是一个塑造自己，丢失自己，怀念自己，找寻自己的过程吗……可悲的是我无法找回自己了，我只想杀死自己。</p><p>2024/07/14<br />坐火车是一件挺有心理压力的事。<br />在车上能看见各个年龄段，和很多不同的人，从小孩到大人，再到老人，从体力工人再到脑力劳动者。<br />仿佛人生的大部分状态和未来的可能都被压缩到这一个狭窄的通往过去或未来的车型上。<br />在这里看到自己记忆中的过去，也能投射出自己些许的未来。<br />我为不能回到过去而感到悲伤，我为昏暗的未来感到悲伤。<br />我为座位如此接近，阶级差距却如此之大而感到悲伤。</p><p>2024/07/15<br />在混杂的音响和众人的祝福中，我的思绪其实早已飞到过去，我只看得见一屡长发在我眼前拂过，<br />阳光顺着发间映出，仿佛发光的是她，而不是背后的太阳，我怯懦地用残缺把她的脸从回忆中抹去，<br />仿佛这样就不会悲伤。<br />于是我坐在喜宴的桌沿上，沐浴着礼炮的彩色飘带，大家都在笑，我也笑了，<br />“祝你幸福”。</p><p>2024/09/14<br />难道人生就是一个被当下蹂躏，焦虑未来，怀念过去的体验吗？<br />如果一向如此，我美好的曾经是否子虚乌有，我的焦虑是否杞人忧天，我的现在是否镜花水月。<br />你好，我已经去了未来，如果你看到了这段信息，请在现在把我带到过去。</p><p>2024/11/24<br />阳光好刺眼啊，仿佛要把我全身的潮湿和阴暗都蒸发掉一样，即便是这样的白日青天、朗朗乾坤，我的前程为何还是一片灰暗。<br />要何等的烈焰才能驱散笼罩在心头的阴霾。</p><p>2024/10/25<br />为什么现实是这样复杂且痛苦的呢？<br />也许这个世界就是一口大锅里面炖着一切，当我品尝生活的滋味时，不是咸，也不是甜，那种味道很复杂，很多时候这种味道让我说不出话。<br />也许五味杂陈的意思我现在才理解吧。<br />我的现实是没有幸运星的。<br />也许一开始这就不是一个开心温暖的故事，不过虽然我开了一个糟糕的起承，但至少我还是作者，这个故事还不会封笔。<br />写到这里时不由得想到巴勒斯坦人民的遭遇，真是场卑劣的战争，悲怆和残忍正在这片土地上演，巴勒斯坦人民万岁。</p><p>2024/11/01<br />我闭上眼睛，勇气没有增长。<br />这薄薄的无尽黑暗中，我看到了未来，<br />所以无需畏惧，大啖食粮之刻已至。</p><p>2024/11/28<br />我只是在原地兜圈子的一个孩子，<br />我渴望有人主动跑过来爱我，<br />我希望有人能拉着我的手前进，<br />而现实是，不会有这样的人了，<br />而幼稚的我只知道坐在原地大哭，<br />这不是一场悲剧，只是我个人的丑态。</p><p>2024/12/03<br />正义是杀不完的，无论是真的还是希望相信，正义都是杀不完的。<br />即便我们只能像“我们必须想象西西弗斯是幸福的”一样略带无奈和妥协地去相信自我价值。<br />正义是杀不完的。</p><p>悲歌可以当泣，远望可以当归</p><p>2024/12/05<br />望未来•娄山关<br />冬风裂，空留萧索孤影夜。孤影夜，霜飞雨泄，亭台幽咽。<br />崎岖闭路了无疟，今夕空作亡魂雀。亡魂雀，幽闭犹怨，寒玉犹泪。</p><p>2024/12/05<br />我时常感到悲伤， 说悲伤是陪我之现在的朋友也不为过，所以我想既然我摆脱不了它，不如去享受这一刻，把我的感受和思考记下来，哪怕给人作为玩乐的笑料，渐渐的这也成为了我的一种习惯或者说乐趣。<br />人活一世也许真的会留下点什么。</p><p>2024/12/11<br />雨打在外套上窸窸窣窣，上海的冬天，也不能说为冬天吧，比家乡来讲应是晚秋的气温，虽然如此但气温也低，寒冷的夜有些伤感，能听到只有汽车呼啸而过带起的水泽和雨滴滴答答。没有月亮，没有星星，就像没有太阳一样，我想不明白游戏行业为什么这样的，有的人已经金缕玉衣，而我能还在一堆烂泥淤成的潭里，不仅狼狈丑陋而且一无所有。每每想到这我都感到十分的伤心，甚至想大哭一场以此来发泄来麻痹这庞大的、痛苦的、无助的感觉。我想璀璨的人生我是不会拥有了，有的故事就是这样的能够扭扭歪歪地写出几个字就已经很不容易了，哪里还有什么美学或者意义呢。我的人生已经开始了，但是我的人生其实早就结束了。雨漏进了泥潭，天有些凉，我也有些冷了，但是我看不见月亮。</p><p><em>注释：雨没有漏进泥潭，其实是笔者的眼泪在心窝中流转。</em></p><p>2024/12/12</p><ul><li><p>分不清是被子冷，还是天气冷，还是世态炎凉。</p></li><li><p>所以说人与人之间的隔阂就像at立场一样，我撞不开，强行撕开只会让人受伤。</p></li><li><p>冷暖自知，能感受到的只会有冷。这是个最冰冷的词汇，因为不能和别人拥抱才只能自己窝在寒冷里幻想温暖。</p></li><li><p>没人爱我。<br />倒不是说大家都不喜欢我，可能会有人喜欢我，但是是没有爱的勇气的，我也没有，我就是那个害怕幸福而逃走的胆小鬼。<br />xx，你戏谑的外表下藏着什么呢？<br />嘻嘻哈哈也金缮不了被生活伤害的残破的心。<br />我不要。<br />我要未来，我要希望，我想要爱，我想要真理。</p></li><li><p>我所做的工作都是微不足道的，我只是把那个缤纷绚丽的世界搬到大家面前，除此之外别无他长。<br />只要用心观察世界，每个人都是伟大的作家。</p></li></ul><p>2024/12/19<br />你说得对。<br />我的一生确实是浪费了。<br />我不再是那个有所期望的人了，<br />在自己的软弱催使下，在见证一起冷漠的爱和爱抽象的人却转身向现实铡刀者之后，我不在爱人类了。</p><p>所谓的博爱和温柔，只不过是披着抽象外衣的自我感动，卑劣至极罢了。我不再爱自己，在试着爱人类时，也失败了。 人所之人，非人哉。</p><p>2024/12/25<br />前人之述备矣。<br />我每次有所感悟，有所表达时，特别是选题相近，比如对时间流逝的感悟，其实早有绝笔，所以总有些彷徨，我对着千古已定的命题还有所疑虑，仿佛我已经忘却了前人的教诲，有些羞愧。<br />但是我突然想到，所感前人之感，也并非说明我们遗忘了什么。<br />恰恰说明人类从未遗忘，对于相同的困境和问题，拥有了相同的感悟或表达抑或不同，恰恰说明人类没有忘却。<br />面对相同的问题，我相信这种重复思考会继续下去，直到它解决的那天。<br />虽然后人可能忘记我当下随感，但是当他们遇到相同的问题时这一切的思考会再次涌现。<br />也许对于人类而言，时间的流向已经固定，宇宙就是如此的残忍无情，那么如此脆弱的人类，所能拥有对抗这一切的、唯一的脆弱武器便是思想，唯有思想才能穿越时间。<br />我称之为，遗忘的记忆。</p><p>去忘记吧，等你忘记所有招式你就练成了太极拳。</p><p>2024/12/26<br />"雪融"，我看不见太阳升起了，我的雪在这里就要化了，只不过只能以泪水的方式了。<br />明年7月，如果你有时间的话，对风声说一句天气如何吧。</p><p>2024/12/27<br />有时候做梦就梦见审死官里面那一幕，<br />星爷演的那个状师，拿着金元宝轻蔑地指着我，“做游戏啊！做游戏啊！”，<br />于是我也和他一起戏谑了。</p><p>2025/01/07<br />昨天我大学同学的朋友问我，你读这么多年书现在加班那么晚，有没有后悔过，<br />当时没觉得什么只是说，还能怎么办想那么干啥，得生活啊。<br />现在冷静下来，想想心里突然有点东西放不下了。<br />我知道他是想问问我答案，但是我也不知道答案，<br />我其实和他一样，<br />至少在对人生的迷惘上，出奇的一致。</p><p>2025/01/08 看一次哭一次，如果真的有爱情的话希望别是这个样子。<br />伤心莫采琵琶树，断魂不照小轩窗。</p><p>2025/01/24<br />幸福是主观的，浮动的，不可定义的，同时也是无法衡量，不能经由测试的。<br />很多时候幸福可能是一瞬间的感觉，当然会有幸福存在。<br />然而从长远看人生更可能是一场悲剧，幸福也许是不存在的。<br />选择做一个无知的人欺骗自己是幸福的，或者做一个痛苦的人接受幸福是少数的。<br />很难说这两者是聪明的愚蠢，还是愚蠢的聪明。</p><p>2025/02/21<br />你怎么开始怀念过去了？<br />你老了吗？可是你最多可能也就30岁，不太老也不太年轻。<br />我不知道，也许是……过得有点辛苦让我想起了从前。<br />你呢？朋友。</p><p>2025/02/21<br />落叶魔音，见落叶而知深秋，<br />晓得盎然春日遥遥。<br />初听不觉何足道，十年邈邈，<br />再奏断万股愁肠，千滴泪。</p><p>2025/02/26<br />牛马哥，我总是想起从前，<br />我现在生活地很痛苦，在夜深人静的时候，我努力回想小时候那些美好的时光，那些日子因为遥远反而显得格外温暖。<br />但是我的身心已经冰冷，只有在回忆中逃避当下的时，才能感受到什么叫生命。<br />在我去逐步认识这个世界的现实中，疫情又给了我沉重的打击，在哪个迷惘和无措的时光惶惶然，我被迫进入了社会，没有承担责任的勇气，没有敢于面对困难的魄力，有的只有对未来的迷惘和昨日的创伤。<br />于是我再次回忆，那个慵懒的躺在午后阳光里的孩子，那个和朋友有说有笑不知愁滋味的男孩。<br />对我而言过去是欢乐的，但是我站在原地往回跑的时候，却无论如何也追不上了。</p><p>2025/03/18<br />就像我总怀念那年夏天的风，<br />我记得那是一个凉爽的下午，<br />它从窗户钻了进来，<br />卷起前桌黑色的长发，<br />来到我的桌前，<br />它给的感觉很轻快，仿佛在拖着我无拘无束，<br />它就这样的一阵阵来，一阵阵去，<br />直到那个夏天过去了，<br />我以为他还会回来，我也以为那个夏天会再来。<br />可是夏天总是，但是那股风再也没回来过。</p><p>2025/03/30<br />如果严肃的文学作品消失那将是整个时代的悲剧，<br />在当下我们可以看到，文娱作品越来越轻量化，娱乐化，<br />表达内容浮于表面，过去的严肃叙事仿佛消失了，<br />那些曾经激烈探讨的问题不再成为作品创作的素材了，<br />可是那些问题就真的消失了吗？<br />尤其是在去政治化特别严重的某些国家，<br />甚至是谈之色变，政治和每个人的生活、权力、义务相关，<br />放弃严肃叙事，放弃政治讨论，等同于放弃思考，放弃社会权益。<br />我觉得这是可悲的、可怕的。</p><p>2025/3/30<br />省流，匹配成功。 不过不用想这么多，玩游戏的时候感觉到开心就好了。<br />游戏作为文娱产品的目的就是取悦用户的。<br />有反思有向往是好事，但是个人的努力无法和时代的洪流抗争，<br />所以，去享受人生吧，在生活的痛苦中，给自己找一颗糖吧。</p><p>2025/05/11<br />追寻梦想总是痛苦的，尤其是在这片土地上，现实太过沉重，把我们每个人拖向地狱，<br />为生活妥协无可指责，但是在回首过去时，总会心有不甘，人生就是抱着遗憾漫无目的踱步的过程。</p><p>2025/05/21<br />仇恨就像螺旋一开始还有迹可循，可世事不能离散只有连续。</p><blockquote><ul><li><p>Agent Ross, Pinkerton Detective Agency.</p></li><li><p>Enjoy your fishing kid, while you still can.</p></li><li><p>Excuse me! You Edgar Ross?</p></li><li><p>Do I know you?</p></li><li><p>Forgive me for startling you, sir. I have a message for you. Myname is Jack Marston. You know my father.</p></li><li><p>I see... I remember your father.</p></li><li><p>I've come for you, Ross.</p></li><li><p>And you, boy, have sure as shit found me.</p></li><li><p>You killed my father. You shot him like a dog.</p></li><li><p>Your father killed himself with the life he lived.</p></li><li><p>You killed him! I saw you!</p></li><li><p>You keep saying that.</p></li><li><p>You sent him to do your dirty work, then you shot him like adog!</p></li><li><p>And I'll shoot you like one too, you little piece of trash! Nowget out of here before I kill you as well!</p></li><li><p>I ain't going nowhere, old man!</p></li></ul><p>RED DEAD REDEMPTION</p></blockquote><blockquote><ul><li>You can't erase the past, John. Killin' me, it won't make it goaway. ...</li><li>Hello again, John.</li><li>Hello, Dutch.</li><li>We gotta stop meeting like this!</li><li>Sure.</li><li>I've got a plan, John.</li><li>You've always got a plan, Dutch.</li><li>This is a good one.</li><li>I don't doubt it.</li><li>We can't always fight nature, John. We can't fight change. We can'tfight gravirty. We can't fight nothing. My whole life, all I ever didwas fight.</li><li>Then give up, Dutch.</li><li>But I can't give up, neither. I can't fight my own nature. That'sthe paradox, John. You see?</li><li>Then I have to shoot you.</li><li>When I'm gone, they'll just find another monster. They have to,because they have to justify their wages.</li><li>That's their business.</li><li>Out time is passed, John.</li></ul></blockquote><p>2025/06/07<br />繁重的工作压得人喘不过气， 连打游戏作为消遣的动力都没有，在夜深人静放松思绪能够思考什么的时候，往日观看的asoul视频又浮现在眼前，已经很遥远了，但是有希望能够近一些。无论接受与否那都成了过去，必须学着接受， 这就是生活残酷的地方，我们漫无目的来到这个世界，遵从生存的本能，短短数十年在史书中不过寥寥几笔， 整个人类历史于宇宙而言不过尘烟，这一切真的有意义吗？宇宙存在所谓意义吗？我怀疑，但悲哀的是我只能相信，无所谓与否。</p><p>清风乱弄两三页，提笔一拨百十年。 长叹飘渺江中月，落花点水了人间。</p><p>2025/06/15<br />从《巴黎的忧郁》到《凉宫秋日的忧郁》他们的悲伤不及我的万分之一，<br />早在落笔之前忧郁已悄然而至，媒体所载至少有人同悲，而我的忧郁只属于我自己。</p><p>摘抄自《知乎》，中华人民共和国的一款人民分享见闻观点，芝士的平台。</p><p>2025/07/04<br />在21世纪还能看到联合小团体迫害一个人在网上发表言论的自由，这种情景也是少见了。当你在为同胞争取权益时，还要被倒打一耙，要怪罪你破坏了他们安定祥和的生活，<br />与之前其痛恨其作为资本家走狗的同事时的面孔截然相反，换了副面孔便高高在上，圣洁无暇了。<br />若是真的有罪便也受的没什么怨言，狺狺野狗也学起秦桧的手段了，真不得令人发笑。</p><p>2025/07/08<br />树死叶落黄，飞沙填泥漳，<br />猢狲不可言秋凉，唯恐泣涕泪叶扬。</p><p>2025/07/25<br />在某国你上班得忍受被压干最后一滴血的觉悟，<br />没有基本的人权保障，没有合理的假期安排，没有休息时间，<br />还要被当权者拿走产出，还得看着他们用你的辛勤劳动去花天酒地肆意挥霍。</p><p>2025/07/25<br />回万古长夜月明，多少英雄不在，<br />哀一生前途晦暗，几许气概无存。<br />多少千百事，都做尘与土。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
