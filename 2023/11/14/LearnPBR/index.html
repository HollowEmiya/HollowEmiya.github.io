

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Hollow Emiya">
  <meta name="keywords" content="">
  
    <meta name="description" content="关于PBR的一些知识点 Learn PBR PBR理论 简介 PBR（Physically Based Rendering）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。 PBR 特征 更高质量的着色效果和更多复杂的材质特性。  表面细节 物体粗糙度 区别明显的金属和">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn PBR">
<meta property="og:url" content="http://example.com/2023/11/14/LearnPBR/index.html">
<meta property="og:site_name" content="Emiya Blog">
<meta property="og:description" content="关于PBR的一些知识点 Learn PBR PBR理论 简介 PBR（Physically Based Rendering）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。 PBR 特征 更高质量的着色效果和更多复杂的材质特性。  表面细节 物体粗糙度 区别明显的金属和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/imgs/LearnPBR/pbr.png">
<meta property="article:published_time" content="2023-11-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-19T02:21:06.286Z">
<meta property="article:author" content="Hollow Emiya">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/imgs/LearnPBR/pbr.png">
  
  
  
  <title>Learn PBR - Emiya Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Emiya&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/imgs/LearnPBR/pbr.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Learn PBR"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-14 00:00" pubdate>
          2023年11月14日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Learn PBR</h1>
            
            
              <div class="markdown-body">
                
                <p>关于PBR的一些知识点</p>
<h1 id="learn-pbr">Learn PBR</h1>
<h1 id="pbr理论">PBR理论</h1>
<h2 id="简介"><strong>简介</strong></h2>
<p><strong>PBR</strong>（<strong>Physically Based
Rendering</strong>）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。</p>
<h3 id="pbr-特征"><strong>PBR</strong> <strong>特征</strong></h3>
<p>更高质量的着色效果和更多复杂的材质特性。</p>
<ul>
<li>表面细节</li>
<li>物体粗糙度</li>
<li>区别明显的金属和绝缘体</li>
<li>物体的浑浊程度</li>
<li>菲涅尔现象：不同角度有不同强度的反射光</li>
<li>半透明物体</li>
<li>多层混合材质</li>
<li>清漆效果</li>
<li>其它更复杂的表面特征</li>
</ul>
<blockquote>
<p>近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：</p>
<ul>
<li>PBR Diffuse for GGX + Smith (2017)</li>
<li>MultiScattering Diffuse (2018)</li>
<li>Layers Material（分层材质）</li>
<li>Mixed Material（混合材质）</li>
<li>Mixed BxDF（混合BxDF）</li>
<li>Advanced Rendering（进阶渲染）</li>
</ul>
</blockquote>
<h3 id="output"><strong>OutPut</strong></h3>
<figure>
<img src="/imgs/LearnPBR/output.PNG" srcset="/img/loading.gif" lazyload alt="output" />
<figcaption aria-hidden="true">output</figcaption>
</figure>
<h2 id="pbr-和-游戏引擎"><strong>PBR</strong> <strong>和
游戏引擎</strong></h2>
<h3 id="ue4-的-pbr"><strong>UE4 的</strong> <strong>PBR</strong></h3>
<ul>
<li><strong>Base Color</strong>，基础的纹理颜色
非金属物体只有<strong>单色</strong>，即强度</li>
</ul>
<table>
<thead>
<tr>
<th>Material</th>
<th>Base Color Intensity</th>
</tr>
</thead>
<tbody>
<tr>
<td>木炭(Charcoal)</td>
<td>0.02</td>
</tr>
<tr>
<td>新沥青(Fresh asphalt)</td>
<td>0.02</td>
</tr>
<tr>
<td>旧沥青(Worn asphalt)</td>
<td>0.08</td>
</tr>
<tr>
<td>土壤(Bare soil)</td>
<td>0.13</td>
</tr>
<tr>
<td>绿草(Green Grass)</td>
<td>0.21</td>
</tr>
<tr>
<td>沙漠沙(desert sand)</td>
<td>0.36</td>
</tr>
<tr>
<td>新混泥土(Fresh concrete)</td>
<td>0.51</td>
</tr>
<tr>
<td>海洋冰(Ocean Ice)</td>
<td>0.56</td>
</tr>
<tr>
<td>鲜雪(Fresh snow)</td>
<td>0.81</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>金属</strong>材质，在 Linear 空间的值</li>
</ul>
<table>
<thead>
<tr>
<th>材质(Material)</th>
<th>基础色(BaseColor)</th>
</tr>
</thead>
<tbody>
<tr>
<td>铁(Iron)</td>
<td>(0.560, 0.570, 0.580)</td>
</tr>
<tr>
<td>银(Silver)</td>
<td>(0.972, 0.960, 0.915)</td>
</tr>
<tr>
<td>铝(Aluminum)</td>
<td>(0.913, 0.921, 0.925)</td>
</tr>
<tr>
<td>金(Gold)</td>
<td>(1.000, 0.766, 0.336)</td>
</tr>
<tr>
<td>铜(Copper)</td>
<td>(0.955, 0.637, 0.538)</td>
</tr>
<tr>
<td>铬(Chromium)</td>
<td>(0.550, 0.556, 0.554)</td>
</tr>
<tr>
<td>镍(Nickel)</td>
<td>(0.660, 0.609, 0.526)</td>
</tr>
<tr>
<td>钛(Titanium)</td>
<td>(0.542, 0.497, 0.449)</td>
</tr>
<tr>
<td>钴(Cobalt)</td>
<td>(0.662, 0.655, 0.634)</td>
</tr>
<tr>
<td>铂(Platinum)</td>
<td>(0.672, 0.637, 0.585)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>粗糙度(Roughness)</strong>：表面的粗糙程度,
[0,1]，越粗糙高光越弱。</li>
</ul>
<figure>
<img src="/imgs/LearnPBR/roughness.png" srcset="/img/loading.gif" lazyload alt="roughness" />
<figcaption aria-hidden="true">roughness</figcaption>
</figure>
<figure>
<img src="/imgs/LearnPBR/roughness2.png" srcset="/img/loading.gif" lazyload alt="roughness2" />
<figcaption aria-hidden="true">roughness2</figcaption>
</figure>
<p>上为非金属，下为金属，粗糙度从0至1</p>
<ul>
<li><strong>金属度(Metallic)</strong>：表示材质像金属的程度，0是绝缘体(电介质)，1
是金属，金属只有镜面反射，没有漫反射。</li>
</ul>
<figure>
<img src="/imgs/LearnPBR/metallic.png" srcset="/img/loading.gif" lazyload alt="metallic" />
<figcaption aria-hidden="true">metallic</figcaption>
</figure>
<p>金属度从0至1</p>
<ul>
<li><strong>镜面度(Specular)</strong>：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)</li>
</ul>
<figure>
<img src="/imgs/LearnPBR/specular.png" srcset="/img/loading.gif" lazyload alt="specular" />
<figcaption aria-hidden="true">specular</figcaption>
</figure>
<p>From 0 ~ 1</p>
<table>
<thead>
<tr>
<th>材质(Material)</th>
<th>镜面度(Specular)</th>
</tr>
</thead>
<tbody>
<tr>
<td>草(Glass)</td>
<td>0.5</td>
</tr>
<tr>
<td>塑料(Plastic)</td>
<td>0.5</td>
</tr>
<tr>
<td>石英(Quartz)</td>
<td>0.57</td>
</tr>
<tr>
<td>冰(Ice)</td>
<td>0.224</td>
</tr>
<tr>
<td>水(Water)</td>
<td>0.255</td>
</tr>
<tr>
<td>牛奶(Milk)</td>
<td>0.277</td>
</tr>
<tr>
<td>皮肤(Skin)</td>
<td>0.35</td>
</tr>
</tbody>
</table>
<h3 id="unity-的-pbr"><strong>Unity 的</strong>
<strong>PBR</strong></h3>
<ul>
<li><strong>Albedo</strong>，和 UE 的 Base Color 一样。
可以用颜色或者Tex</li>
<li><strong>Metallic</strong>，可以用金属贴图，但是用了 Smoothness
参数就消失了</li>
<li><strong>Smoothness</strong>，光滑度，和 UE 的 粗糙度正相反
<ul>
<li><strong>Smoothness
Source</strong>，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha
或基础色的 Alpha</li>
</ul></li>
<li><strong>Occlusion</strong>：遮蔽图，指定材质接收间接光的光照强度和反射强度。
能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。</li>
<li><strong>Fresnel</strong>，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity
里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。</li>
</ul>
<h2 id="pbr-基本原理"><strong>PBR</strong>
<strong>基本原理</strong></h2>
<p>满足以下条件的光照模型才能称之为PBR光照模型：</p>
<ul>
<li>基于微平面模型（Be based on the microfacet surface model）。</li>
<li>能量守恒（Be energy conserving）。</li>
<li>使用基于物理的BRDF（Use a physically based BRDF）。</li>
</ul>
<h3
id="微表面理论microfacet"><strong>微表面理论(Microfacet)</strong></h3>
<p>很多 PBR 技术都是基于理论
认为<strong>在微观上</strong>，所有的物体表面都是由很多的朝向不一的微小平面组成的。</p>
<blockquote>
<p>真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至<em>光栅化后的像素尺度</em>来看待的话，这种假设的结果和实际差别甚微。</p>
</blockquote>
<figure>
<img src="/imgs/LearnPBR/microfacet.png" srcset="/img/loading.gif" lazyload alt="microfacet" />
<figcaption aria-hidden="true">microfacet</figcaption>
</figure>
<p>基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度
Roughness，用统计学的方法去估算微表面的粗糙度。</p>
<p>...</p>
<h3 id="energy-conservation-能量守恒"><strong>Energy Conservation
(能量守恒)</strong></h3>
<p>在 Microfacet
中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，</p>
<p>所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。</p>
<h4
id="镜面反射specular和漫反射diffuse"><strong>镜面反射(specular)和漫反射(diffuse)</strong></h4>
<p>一束光打到物体，会发生 <strong>reflection</strong> 反射 和
<strong>refraction</strong>
折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。
折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。</p>
<figure>
<img src="/imgs/LearnPBR/reflect.png" srcset="/img/loading.gif" lazyload alt="reflect" />
<figcaption aria-hidden="true">reflect</figcaption>
</figure>
<p><em>照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。</em>
通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface
Scattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。
金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。</p>
<p>根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。</p>
<p>float kS = calculateSpecularComponent(...); // 反射/镜面部分</p>
<p>float kD = 1.0 - kS; // 折射/漫反射部分</p>
<p>ks + kd 不会超过1，所以近似地能量守恒。</p>
<h3 id="reflectance-equation"><strong>Reflectance Equation</strong></h3>
<p><span
class="math display">\[L_0(p,w_0)=\int\limits_{\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\,\mathrm{d}w_i\]</span></p>
<h2 id="辐射度量学"><strong>辐射度量学</strong></h2>
<h3 id="概念表"><strong>概念表</strong></h3>
<figure>
<img src="/imgs/LearnPBR/chart1.png" srcset="/img/loading.gif" lazyload alt="chart1" />
<figcaption aria-hidden="true">chart1</figcaption>
</figure>
<figure>
<img src="/imgs/LearnPBR/chart2.png" srcset="/img/loading.gif" lazyload alt="chart2" />
<figcaption aria-hidden="true">chart2</figcaption>
</figure>
<blockquote>
<p>微分符号 d
的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx</p>
</blockquote>
<h3 id="辐射通量radiant-flux"><strong>辐射通量（Radiant
Flux)</strong></h3>
<p>光源单位时间内的输出<span
class="math display">\[\Phi=\frac{\mathrm{d}Q}{\mathrm{d}t}\]</span></p>
<blockquote>
<p>光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。</p>
</blockquote>
<p>传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。</p>
<h3 id="radiant-insensity辐射强度"><strong>Radiant
Insensity(辐射强度)</strong></h3>
<p>单位球面上，一个光源向单位立体角所投送的辐射通量。</p>
<p><span
class="math display">\[I=\frac{\mathrm{d}\Phi}{\mathrm{d}w}\]</span></p>
<p>the power per unit angle</p>
<p>假如光源均匀向四周发散</p>
<p><span class="math display">\[I = \frac{\Phi}{4\pi}\]</span></p>
<h3 id="irradiance"><strong>Irradiance</strong></h3>
<p>The power per (perpendicular/projected) unit area incident on a
surface point.</p>
<p><span
class="math display">\[E(x)=\frac{\mathrm{d}\Phi(x)}{\mathrm{d}A^\perp
}\]</span></p>
<p>面要和光源垂直。</p>
<p>即 Lambert‘s Consine Law</p>
<h3 id="radiance"><strong>Radiance</strong></h3>
<p>The radiance(luminance) is the power emitted, reflected, transmitted
or received by a surface, <em>per unit solid angle, per projected unit
area.</em> 在单位立体角并且在单位的面积上</p>
<p><span
class="math display">\[L(p,w)=\frac{\mathrm{d}^2\Phi(p,w)}{\mathrm{d}w\,\mathrm{d}A\cos\theta}=\frac{\mathrm{d}^2\Phi(p,w)}{\mathrm{d}w\,\mathrm{d}A^\perp}\]</span></p>
<ul>
<li>Irradiance: power per projected unit area</li>
<li>Intensity: power per solid angle</li>
</ul>
<p>So</p>
<ul>
<li>Radiance : Irrandiance pre solid angle</li>
<li>Radiance : Intensity pre unit projected area</li>
</ul>
<p>Irradiance 是 dA 收到的能量</p>
<p>Irradiance per solid angle 是 dA 的能量向某一个方向辐射</p>
<figure>
<img src="/imgs/LearnPBR/Radiance.png" srcset="/img/loading.gif" lazyload alt="Radiance" />
<figcaption aria-hidden="true">Radiance</figcaption>
</figure>
<p>该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E
里面……</p>
<p>Incident Radiance 延申理解：</p>
<p>一小块面积 dA 向某个方向辐射的能量</p>
<p>反过来就是，从一个方向打向一个小面，到达这个面时的能量</p>
<p><span
class="math display">\[L(p,w)=\frac{\mathrm{d}I(p,w)}{\mathrm{d}A\cos\theta}=\frac{\mathrm{d}I(p,w)}{\mathrm{d}A^\perp}\]</span></p>
<h3 id="irradiance-vs.-radiace"><strong>Irradiance vs.
Radiace</strong></h3>
<p><span
class="math display">\[\mathrm{d}E(p,w)=L_i(p,w)\cos\theta\,\mathrm{d}w\\\]</span></p>
<p>两边同时积分</p>
<p><span
class="math display">\[E(p)=\int_H^2L_i(p,w)\cos\theta\,\mathrm{d}w\\
Uint\;Hemisphere:H^2\]</span></p>
<p>每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。</p>
<p>再回到渲染方程</p>
<p><span class="math display">\[L_0(p,w_0)=\int\limits_\Omega
f_r(p,w_i,w_0)\underbrace{L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i}_{Radiace}\]</span></p>
<p>其中只有 f 项待解。</p>
<h2
id="brdf双向反射分布函数"><strong>BRDF(双向反射分布函数)</strong></h2>
<p>Bidirectional Reflectance Distribution Function，BRDF</p>
<p>一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。</p>
<figure>
<img src="/imgs/LearnPBR/BRDF.svg" srcset="/img/loading.gif" lazyload alt="BRDF" />
<figcaption aria-hidden="true">BRDF</figcaption>
</figure>
<p>BRDF
描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，</p>
<p>假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号
入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.</p>
<p><span
class="math display">\[f_r(p,w_0,w_i)=\frac{\mathrm{d}L_0(p,w_0)}{\mathrm{d}E(p,w_i)}=\frac{\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\cos\theta_i\,\mathrm{d}w_i}\]</span></p>
<p>BRDF 有多种模拟表面光照的算法，实时渲染所用的基本是
<strong>Cook-Torrance BRDF</strong></p>
<h3 id="参考"><strong>参考</strong></h3>
<ul>
<li><strong>PBRT-BRDF章节：</strong><a
target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection">Surface
Reflection (pbr-book.org)</a></li>
</ul>
<h3 id="cook-torrance-brdf"><strong>Cook-Torrance BRDF</strong></h3>
<p><span
class="math display">\[f_r=k_df_{lambert}+k_sf_{cook-torrance}\\
k_d是入射光被折射比例，\\ k_s是被镜面反射比例\]</span></p>
<p>而左侧的 f_lambert 表示漫反射部分，Lambertian
Diffuse，一般是恒定的算式：</p>
<p><span class="math display">\[f_{lambert}=\frac{c}{\pi}\]</span></p>
<p>c 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的</p>
<h4 id="brdf的高光项"><strong>BRDF的高光项</strong></h4>
<p><span class="math display">\[f_{cook-torrance}=\frac{DFG}{4(w_0\cdot
n)(w_i\cdot n)}\]</span></p>
<ul>
<li><strong>D( Normal Distribution Function, NDF )</strong> :
法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(half
Dir)的一致性或者说微表面的数量。 估算微表面的主要函数。</li>
<li><strong>F( Fresnel Equation
)</strong>：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。
不同表面角下，表面反射光线的比例。</li>
<li><strong>G( Geometry Function )</strong> :
几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/28476602/answer/41003204">brdf为什么要定义为一个单位是sr-1的量？
- 知乎 (zhihu.com)</a> <a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/28476602/answer/41003204">brdf为什么要定义为一个单位是sr-1的量？
- 文刀秋二的回答:</a></p>
<h3 id="dnormal-distribution-function-ndf"><strong>D(Normal Distribution
Function, NDF)</strong></h3>
<p>描述和微表面法线和半角向量的一致性，从统计学上近似
<strong>Trowbridge-Reitz GGX(GGXTR) :</strong></p>
<p><span
class="math display">\[{NDF}_{GGXTR}(n,h,\alpha)=\frac{\alpha^2}{\pi((n\cdot
h)^2(\alpha^2-1)+1)^2}\\ h=normalize(viewDir+lightDir)\\
\alpha={roughness}^2\]</span></p>
<figure>
<img src="/imgs/LearnPBR/ggx.png" srcset="/img/loading.gif" lazyload alt="ggx" />
<figcaption aria-hidden="true">ggx</figcaption>
</figure>
<p><a
target="_blank" rel="noopener" href="https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN">Trowbridge-Reitz
GGX | Desmos</a></p>
<p>当 粗糙度 为零时函数值变为零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float DoubleDistributeGGX(float3 N, float3 H, float roughness)<br>&#123;<br>    float a = roughness * roughness;<br>    float a2 = a * a;<br>    float NdotH = max(0.0, dot(N, H));<br>    float NdotH2 = NdotH * NdotH;<br><br>    float p = (NdotH2 * (a2 - 1.0) + 1.0);<br>    p = PI * p * p;<br>    return a2 / p;<br>&#125;<br><br>roughness += 0.0001;<br>float NDF = DoubleDistributeGGX(N, H, roughness);<br></code></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">2013SiggraphPresentationsNotes-26915738.pdf
(unrealengine.com): Specular D</a></p>
<h4
id="generalized-trowbridge-reitzgtr分布"><strong>Generalized-Trowbridge-Reitz（GTR）分布</strong></h4>
<p>GTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。</p>
<p><span class="math display">\[D_{GTR}(m)=\frac{c}{(1+(n\cdot
m)^2(\alpha^2-1))^\gamma}\]</span></p>
<ul>
<li>关于形状不变性的好处，可以总结为：
<ul>
<li>方便推导出该NDF归一化的各向异性版本</li>
<li>方便推导出遮蔽阴影项 Smith G</li>
<li>方便基于NDF或可见法线分布推导其重要性采样
<ul>
<li>对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性</li>
</ul></li>
</ul></li>
</ul>
<h4 id="参考-1"><strong>参考</strong></h4>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69380665">【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结
- 知乎 (zhihu.com)</a>:关于形状不变性。</p>
<h3 id="ffresnel-equation"><strong>F(Fresnel Equation)</strong></h3>
<p><span
class="math display">\[F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5\]</span></p>
<p>F_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0
越大菲涅尔反射现象越强。</p>
<p>当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。</p>
<figure>
<img src="/imgs/LearnPBR/fresnel.png" srcset="/img/loading.gif" lazyload alt="fresnel" />
<figcaption aria-hidden="true">fresnel</figcaption>
</figure>
<p><strong>Fresnel-Schlick</strong>只适用于绝缘体的表面算法。
金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以：
预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。
这样就可以使用同一个公式了。</p>
<p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<a
target="_blank" rel="noopener" href="http://refractiveindex.info/">RefractiveIndex</a>。</p>
<p>所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</p>
<figure>
<img src="/imgs/LearnPBR/chart3.png" srcset="/img/loading.gif" lazyload alt="chart3" />
<figcaption aria-hidden="true">chart3</figcaption>
</figure>
<p>由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非
非零即一
的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。</p>
<p>我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick
近似，但是对于金属表面通常这样做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 F0 = vec3(0.04,0.04,0.04);<br>F0 = mix(F0, surfaceColor.rgb, metalness);<br></code></pre></td></tr></table></figure>
<p>我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 fresnelSchlick(float cosTheta, vec3 F0)<br>&#123;<br>    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br>// cosTheta = dot(N,V)<br></code></pre></td></tr></table></figure>
<p>这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的
fresnelSchlick</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)<br>&#123;<br>    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 Fresnel
Reflection： <a
target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission">Specular
Reflection and Transmission (pbr-book.org)</a></p>
<blockquote>
<ol type="1">
<li>The first class is <em>dielectrics</em>, which are materials that
don’t conduct electricity. They have real-valued indices of refraction
(usually in the range 1-3) and transmit† a portion of the incident
illumination. Examples of dielectrics are glass, mineral oil, water, and
air.</li>
<li>The second class consists of <em>conductors</em> such as metals.
Valence electrons can freely move within the their atomic lattice,
allowing electric currents to flow from one place to another. This
fundamental atomic property translates into a profoundly different
behavior when a conductor is subjected to electromagnetic radiation such
as visible light: the material is opaque and reflects back a significant
portion of the illumination. A portion of the light is also transmitted
into the interior of the conductor, where it is rapidly absorbed: total
absorption typically occurs within the top 0.1 μm of the material, hence
only extremely thin metal films are capable of transmitting appreciable
amounts of light. We ignore this effect in <code>pbrt</code> and only
model the reflection component of conductors. In contrast to
dielectrics, conductors have a complex-valued index of refraction
n=n0+ik.</li>
<li>Semiconductors such as silicon or germanium are the third class
though we will not consider them in this book.</li>
<li>The first class is dielectrics, which are materials that don't
conduct electricity. They have real-valued indices of refraction
(usually in the range 1-3) and transmitt a portion of the incident
illumination. Examples of dielectrics are glass, mineral oil, water, and
air.</li>
<li>The second class consists of conductors such as metals. Valence
electrons can freely move within the their atomic lattice, allowing
electric currents to flow from one place to another. This fundamental
atomic property translates into a profoundly different behavior when a
conductor is subjected to electromagnetic radiation such as visible
light: the material is opaque and reflects back a significant portion of
the illumination. A portion of the light is also transmitted into the
interior of the conductor, where it is rapidly absorbed: total
absorption typically occurs within the top 0.1 um of the material, hence
only extremely thin metal films are capable of transmitting appreciable
amounts of light. We ignore this effect in pbrt and only model the
reflection component of conductors. In contrast to dielectrics,
conductors have a complex-valued index of refraction = n + ik.</li>
<li>Semiconductors such as silicon or germanium are the third class
though we will not consider them in this book.</li>
</ol>
<p>第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。</p>
<p>第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率=
n + ik。</p>
<p>硅或锗等半导体是第三类，但我们在本书中不考虑它们。</p>
</blockquote>
<h3 id="ggeometry-function"><strong>G(Geometry Function)</strong></h3>
<p>几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。</p>
<p>类似 NDF，也使用 Roughness
作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和
Schlick-Beckmann 组合而成的模拟函数 <strong>Schlick-GGX</strong>：</p>
<p><span class="math display">\[G_{SchlickGGX}(n,v,k)=\frac{n\cdot
v}{(n\cdot v)(1-k)+k}\]</span></p>
<figure>
<img src="/imgs/LearnPBR/G.png" srcset="/img/loading.gif" lazyload alt="G" />
<figcaption aria-hidden="true">G</figcaption>
</figure>
<p>这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL
光照的几何函数参数:</p>
<p><span class="math display">\[k_{direct}=\frac{(\alpha+1)^2}{8}\\
k_{IBL}=\frac{\alpha^2}{2}\]</span></p>
<p>这里的 α 取决于我们怎么从粗糙度转换。</p>
<p>为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影)
几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 <strong>Smith</strong>
函数将其放在一起:</p>
<p><span
class="math display">\[G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float GeometrySchlickGGX(float NdotV, float k)<br>&#123;<br>    float nom = NdotV;<br>    float denom =  NdotV * (1 - k) + k;<br>    return nom / denom;<br>&#125;<br><br>float GeometeySmith(vec3 N, vec3 V, vec3 L, float k)<br>&#123;<br>    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);<br>    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);<br>    return Gsub * Gsub2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="kulla-conty-approximation"><strong>Kulla-Conty
Approximation</strong></h3>
<p>由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF
只是考虑一次反射罢了。</p>
<p>所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。</p>
<p><span
class="math display">\[E(\mu_o)=\int_0^{2\pi}\int_0^1f_r(\mu_o,\mu_i,\phi)u_i\,\mathrm{d}\mu_i\,\mathrm{d}\phi\\
u=\sin\theta\]</span></p>
<ul>
<li>Key idea
<ul>
<li>损失的能量就是 1 - E(_o)，不过E(_o)是和观察方向相关的。
我要做的就是补上这部分能量，能量加起来就是1了啊。</li>
<li>E(_0)是和观察方向相关的。</li>
<li>要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为
BRDF 具有对称性，有1 - E(_o)那么应该也有一项1 -
E(_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF
的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(_i))(1 -
E(_o)) 这么设计只是为了简单……</li>
<li><span class="math display">\[c=\frac{1}{\pi(1-E_{avg})}\\
E_{avg}=2\int_0^1E(\mu)\mu\,\mathrm{d}\mu\\
f_{ms}(\mu_o,\mu_i)=\frac{(1-E(\mu_i))(1 -
E(\mu_o))}{\pi(1-E_{avg})}\]</span></li>
<li></li>
</ul></li>
<li>但E_{avg}还是不知道的，这个可以预计算。
<ul>
<li>Precompute / tabulate</li>
<li><span
class="math display">\[E_{avg}(\mu_o)=2\int_0^1E(\mu_i)\mu_i\,\mathrm{d}\mu_i\\\]</span></li>
<li><span class="math display">\[E_{avg}\]</span>和<span
class="math display">\[\mu_o\]</span>, 以及 BRDF(或者说roughness) 相关
这个预计算的结果会根据 brdf 的不同而改变。</li>
</ul></li>
</ul>
<figure>
<img src="/imgs/LearnPBR/Kulla-Conty.png" srcset="/img/loading.gif" lazyload alt="Kulla-Conty" />
<figcaption aria-hidden="true">Kulla-Conty</figcaption>
</figure>
<ul>
<li>如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算
没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。</li>
<li>Define the average Fresnel
不管入射角多大，每次反射平均反射掉多少能量</li>
</ul>
<p><span
class="math display">\[F_{avg}=\frac{\int_0^1F(\mu)\mu\,\mathrm{d}\mu}{\int_0^1\mu\,\mathrm{d}\mu}=2\int_0^1F(\mu)\mu\,\mathrm{d}\mu\]</span></p>
<ul>
<li><span class="math display">\[E_{avg}\]</span>
表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participate
in further bounces</li>
<li>所以最后的 能量/颜色
<ul>
<li>能够直接看到的 <span
class="math display">\[F_{avg}E_{avg}\]</span></li>
<li>光反射一次被看到：<span
class="math display">\[F_{avg}(1-E_{avg})\cdot F_{avg}E_{avg}\]</span>
<span
class="math display">\[F_{avg}(1-E_{avg})\]</span>是反射后(F)未能从物体表面反射出去的能量(1-E)，
<span
class="math display">\[F_{avg}(1-E_{avg})\underline{F_{avg}}\]</span>
未能出去的能量发生第二次 <span
class="math display">\[F_{avg}(1-E_{avg})\cdot
F_{avg}\underline{E_{avg}}\]</span> 发生反射后有多少能量被看到</li>
<li>反射k次：F_{avg}<sup>k(1-E_{avg})</sup>kF_{avg}E_{avg}</li>
<li>累加得到 color term：</li>
<li><span
class="math display">\[\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\]</span></li>
<li>最后将 color term directly multiplied on the uncolored
<strong>additional BRDF</strong></li>
</ul></li>
</ul>
<h3 id="cook-torrance-反射方程"><strong>Cook-Torrance
反射方程</strong></h3>
<p><span
class="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +
k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i\]</span></p>
<h4 id="直接光-附加光">直接光 + 附加光</h4>
<figure>
<img src="/imgs/LearnPBR/output2.PNG" srcset="/img/loading.gif" lazyload alt="output2" />
<figcaption aria-hidden="true">output2</figcaption>
</figure>
<h2 id="ibl"><strong>IBL</strong></h2>
<h3 id="diffuse-irradiance"><strong>Diffuse Irradiance</strong></h3>
<p>Imaged base lighting, IBL
是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，<strong>而是将周围环境整体视为一个大光源</strong>。IBL(
取自现实世界或者在3D场景生成)
环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。
由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL
对 PBR
很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p>
<p><span
class="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +
k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i\]</span></p>
<p>对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。
直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的<strong>每个</strong>方向w_i都有可能具有一定的
Radiance，这就很麻烦了。 我们需要：</p>
<ul>
<li>对给定任何方向w_i，能获取到该方向的场景 Radiance。</li>
<li>积分需要快，因为是实时渲染。</li>
</ul>
<p>第一个思路就是用
环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。</p>
<p>为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:</p>
<p><span
class="math display">\[L_0(p,w_0)=\int_{\Omega}(k_d\frac{c}{\pi} +
k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot n)})L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i\\
Because\;diffuse\;k_d\;and\;specular\;are\;independent\;for\;each\;other.\\
We\;can\;break\;up.\\
L_0(p,w_0)=\int_{\Omega}k_d\frac{c}{\pi}L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i + \int_{\Omega}k_s\frac{FDG}{4(w_0\cdot n)(w_i\cdot
n)}L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\]</span></p>
<p>先来研究
diffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。</p>
<p><span
class="math display">\[L_0(p,w_0)=k_d\frac{c}{\pi}\int_{\Omega}L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i\]</span></p>
<p>卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球
上的所有其他采样方向。</p>
<p>为了对环境贴图进行卷积，我们通过对半球 ，来计算每个输出采样方向
w_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。</p>
<figure>
<img src="/imgs/LearnPBR/ibl1.png" srcset="/img/loading.gif" lazyload alt="ibl1" />
<figcaption aria-hidden="true">ibl1</figcaption>
</figure>
<p>是不是看不懂，看不懂就对了，因为应该是这样的！</p>
<figure>
<img src="/imgs/LearnPBR/ibl2.png" srcset="/img/loading.gif" lazyload alt="ibl2" />
<figcaption aria-hidden="true">ibl2</figcaption>
</figure>
<p>该预计算的立方体贴图在每个采样方向
w_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。</p>
<p>辐射方程也依赖了位置 p
，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置
p
处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值</p>
<p>关于在半球的积分，可以将立体角 soiled angle 展开</p>
<p><span class="math display">\[L_0(p,w_0)= k_d\frac{c}{\pi}
\int_{\phi=0}^{2\pi}\int_{\theta=0}^{\frac{1}{2}\pi}
L_i(p,\phi_i,\theta_i)
\cos\theta\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\phi\\  Here\;\cos\theta\sin\theta,\;\sin\theta\;for\;soiled\;angle,\;\cos\theta\;for\;\overrightarrow{up}:w_i\cdot
n\\  L_0(p,w_0)=k_d\frac{c}{\pi}
\frac{1}{n_1n_2}\sum\limits^{n_1}_{\phi=0}\sum\limits^{n_2}_{\theta=0}
L_i(p,\phi_i,\theta_i)
\cos\theta\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\phi\]</span></p>
<h3 id="实现"><strong>实现</strong></h3>
<p>Roughness in [0,1]-&gt;[0,5]</p>
<p>做五级的skybox，存在cubemap tex内</p>
<h4 id="参考-2"><strong>参考</strong></h4>
<p><a
target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">漫反射辐照
- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a
target="_blank" rel="noopener" href="http://www.codinglabs.net/article_physically_based_rendering.aspx">codinglabs.net/article_physically_based_rendering.aspx</a></p>
<h3 id="specular-ibl"><strong>Specular IBL</strong></h3>
<h4 id="the-split-sum-1st-stage"><strong>The Split Sum: 1st
Stage</strong></h4>
<p>现在来看镜面反射部分，反射方程为：</p>
<p><span
class="math display">\[L_0(p,w_0)=\int\limits_\Omega(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(w_0\cdot
n)(w_i\cdot n)})L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\]</span></p>
<p>这下坏了，因为 ks
是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。
Epic Games
提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（<strong>split
sum approximation</strong>）。
分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在
PBR 着色器中求和，以用于间接镜面反射部分
IBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR
环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：</p>
<p><span
class="math display">\[L_0(p,w_0)=\int\limits_\Omega(k_s\frac{DFG}{4(w_0\cdot
n)(w_i\cdot n)})L_i(p,w_i)n\cdot w_i\,\mathrm{d}w_i\\
=\int\limits_\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\cdot
w_i\,\mathrm{d}w_i\]</span></p>
<p>我们依然想计算出一个类似镜面 IBL
贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于
w_i，但是这次积分还依赖于 BRDF</p>
<p><span class="math display">\[f_r(p,w_i,w_0)=\frac{DFG}{4(w_0\cdot
n)(w_i\cdot n)}\]</span></p>
<p>BRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。</p>
<p><span
class="math display">\[\int_{\Omega}f(x)g(x)\,\mathrm{d}x\approx\frac{\int_{\Omega_G}f(x)\,\mathrm{d}x}{\int_{\Omega_G}\,\mathrm{d}x}\cdot\int_{\Omega}g(x)\,\mathrm{d}x\]</span></p>
<p>所以
E宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。</p>
<p><span class="math display">\[L_0(p,w_0)=\int\limits_\Omega
L_i(p,w_i)\,\mathrm{d}w_i*\int\limits_\Omega f_r(p,w_i,w_0)n\cdot
w_i\,\mathrm{d}w_i\]</span></p>
<p>卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的
mipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5
个不同粗糙度值的预卷积结果，如下图所示：</p>
<figure>
<img src="/imgs/LearnPBR/IBLCubemap.png" srcset="/img/loading.gif" lazyload alt="IBLCubemap" />
<figcaption aria-hidden="true">IBLCubemap</figcaption>
</figure>
<p>为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。</p>
<figure>
<img src="/imgs/LearnPBR/iblAlpha.png" srcset="/img/loading.gif" lazyload alt="iblAlpha" />
<figcaption aria-hidden="true">iblAlpha</figcaption>
</figure>
<p>从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的
fliter 进行采样的，当越粗糙时这个 filter 越大。</p>
<p>为什么两部分分开了还要前面项会受到 BRDF
影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。</p>
<figure>
<img src="/imgs/LearnPBR/boban.jpg" srcset="/img/loading.gif" lazyload alt="boban" />
<figcaption aria-hidden="true">boban</figcaption>
</figure>
<p>我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据
brdf 定义可知：</p>
<p><span
class="math display">\[R=reflection(w_o,n)，w_o就是\overrightarrow{view}。\]</span></p>
<p><strong>假设不同方向入射，波瓣变化不大</strong>，我们可以得到:</p>
<p><span class="math display">\[f(w_o,w_i(n),n)\approx
f(R,w_i(R),R)，也就是 N=V=R。\]</span>
f(w_o,w_i(n),n)f(R,w_i(R),R)，也就是 N=V=R。</p>
<figure>
<img src="/imgs/LearnPBR/poban.jpg" srcset="/img/loading.gif" lazyload alt="poban" />
<figcaption aria-hidden="true">poban</figcaption>
</figure>
<p>我们使用 Cook-Torrance BRDF
的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此
Epic Games
假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：</p>
<p>vec3 N = normalize(w_o);</p>
<p>vec3 R = N;</p>
<p>vec3 V = R;</p>
<p>但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。</p>
<p>Moving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probe
filtering</p>
<p>To simplify this evaluation, we can pre-integrate the integral by
making some approximations. Pre-integrating this equation for every v
and Θ would require a huge memory footprint. Thus, a first approximation
is to remove the view dependency. This leads to a coarse approximation
of the BRDF but it is an acceptable trade-off: the shape of a BRDF based
on the micro-facets framework and/or half-angle parametrization is
strongly dependent on the view angle as shown on Figure 54. At normal
incident direction, the shape of a BRDF is isotropic. At grazing angles
the shape of a BRDF is anisotropic. Removing the view dependency for
pre-integrating Equation 46 would make the assumption that the BRDF
shape is isotropic at all view angles. This leads to key visual
differences, preventing stretched reflections. This approximation can be
quite noticeable on flat surfaces as shown on Figure 55 but less on
curvy surfaces38</p>
<figure>
<img src="/imgs/LearnPBR/ueReference.png" srcset="/img/loading.gif" lazyload alt="ueReference" />
<figcaption aria-hidden="true">ueReference</figcaption>
</figure>
<h4 id="the-split-sum-2nd-stage"><strong>The Split Sum: 2nd
Stage</strong></h4>
<p><span
class="math display">\[Lo(p,w_o)\approx\frac{\int_{\Omega_{fr}}L_i(p,w_i)\,\mathrm{d}w_i}{\int_{\Omega_{fr}}\,\mathrm{d}w_i}\cdot\underline{\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i}\]</span></p>
<p>这部分计算和 F_0,,，但是3D贴图太大了！！！</p>
<p>菲涅项其实比较好拆，我们可以对这部分做一些处理</p>
<p><span class="math display">\[R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\
R_0-R_0(1-\cos\theta)^5+(1-\cos\theta)^5\\
\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i\approx\\
R_0\int_{\Omega^+}\frac{f_r}{F}(1-(1-\cos\theta)^5)\cos\theta_i\,\mathrm{d}w_i+\int_{\Omega^+}\frac{f_r}{F}(1-\cos\theta)^5\cos\theta_i\,\mathrm{d}w_i\]</span></p>
<figure>
<img src="/imgs/LearnPBR/uecode1.png" srcset="/img/loading.gif" lazyload alt="uecode1" />
<figcaption aria-hidden="true">uecode1</figcaption>
</figure>
<h3 id="the-split-sum-1st-stage-sample"><strong>The Split Sum: 1st Stage
Sample</strong></h3>
<p>在上一节教程中，我们使用球面坐标生成均匀分布在半球 <span
class="math display">\[\Omega\]</span>
上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：</p>
<figure>
<img src="/imgs/LearnPBR/sample.png" srcset="/img/loading.gif" lazyload alt="sample" />
<figcaption aria-hidden="true">sample</figcaption>
</figure>
<p>所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。
在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。</p>
<p>F = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);</p>
<p>float3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st,
sampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);</p>
<p>col += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;</p>
<figure>
<img src="/imgs/LearnPBR/uecode2.png" srcset="/img/loading.gif" lazyload alt="uecode2" />
<figcaption aria-hidden="true">uecode2</figcaption>
</figure>
<h3
id="蒙特卡洛monte-carlo积分和重要性采样importance-sampling"><strong>蒙特卡洛(Monte
Carlo)积分和重要性采样(Importance Sampling)</strong></h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146144853">蒙特卡洛积分 - 知乎
(zhihu.com)</a></p>
<p>有了蒙特卡洛，那么如何对半球面上的进行采样。</p>
<h3 id="低差异序列"><strong>低差异序列</strong></h3>
<p>Hammersley 序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float RadicalInverse_VdC(uint bits)<br>&#123;<br>    bits = (bits &lt;&lt; 16u) | (bits &gt;&gt; 16u);<br>    bits = ((bits &amp; 0x55555555u) &lt;&lt; 1u) | ((bits &amp; 0xAAAAAAAAu) &gt;&gt; 1u);<br>    bits = ((bits &amp; 0x33333333u) &lt;&lt; 2u) | ((bits &amp; 0xCCCCCCCCu) &gt;&gt; 2u);<br>    bits = ((bits &amp; 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits &amp; 0xF0F0F0F0u) &gt;&gt; 4u);<br>    bits = ((bits &amp; 0x00FF00FFu) &lt;&lt; 8u) | ((bits &amp; 0xFF00FF00u) &gt;&gt; 8u);<br>    return float(bits) * 2.3283064365386963e-10; // / 0x100000000<br>&#125;<br>// ----------------------------------------------------------------------------<br>float2 Hammersley(uint i, uint N)<br>&#123;<br>    return float2(float(i)/float(N), RadicalInverse_VdC(i));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343666731">看懂蒙特卡洛积分(三)
低差异采样序列</a> <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20197323">低差异序列（一）-
常见序列的定义及性质 - 知乎 (zhihu.com)</a> <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20374706">低差异序列（二）-
高效实现以及应用 - 知乎 (zhihu.com)</a></p>
<h4 id="ggx-重要性采样"><strong>GGX 重要性采样</strong></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)<br>&#123;<br>    // use roughness for better view<br>    float alpha2 = roughness * roughness;<br><br>    float phi = 2.0 * PI * Xi.x;<br>    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));<br>    float sinTheta = sqrt(1 - cosTheta * cosTheta);<br><br>    float3 H;<br>    H.x = cos(phi) * sinTheta;<br>    H.y = sin(phi) * sinTheta;<br>    H.z = cosTheta;<br><br>    float3 up = abs(N.z) &lt; 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);<br>    float3 tangent = normalize(cross(up,N));<br>    float3 biTangent = normalize(cross(N, tangent));<br><br>    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;<br>    return normalize(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="the-split-sum">The Split Sum</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// 1st<br>void PrefilteredColor(float3 dir, uint3 id)<br>&#123;<br>    float3 N = normalize(dir);<br>    float3 R = N;<br>    float3 V = R;<br><br>    const uint SAMPLE_COUNT = 1024;<br>    float totalWeight[5] = &#123;0.0, 0.0, 0.0, 0.0, 0.0&#125;;<br>    float3 preColor[5] = &#123; float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)&#125;;<br>    for(uint i = 0; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, SAMPLE_COUNT);<br>        float3 H[5];<br>        float3 L[5];<br>        float NdotL[5];<br>        for(uint a = 0; a &lt; 5; a++)<br>        &#123;<br>            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);<br>            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);<br>            NdotL[a] = max(0.0,dot(N,L[a]));<br>            if(NdotL[a] &gt; 0.0)<br>            &#123;<br>                float D = DistributeGGX(N, H[a], (float)a/5.0);<br>                float NdotH = max(0.0, dot(N, H[a]));<br>                float HdotV = max(0.0, dot(H[a], V));<br>                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;<br><br>                float res = 512.0;<br>                float saTexel = 4.0 * PI / (6.0 * res * res);<br>                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);<br>                float roughness = (float)a / 5.0;<br>                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); <br>                <br>                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];<br>                totalWeight[a] += NdotL[a];<br>            &#125;<br>        &#125;         <br>    &#125;<br>    int powLog = 1;<br>    for(uint b = 0; b &lt; 5; b++)<br>    &#123;    <br>        preColor[b] = preColor[b] / totalWeight[b];<br>        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);<br>        powLog *= 2;<br>    &#125;<br>&#125;<br><br>// 2nd<br>float2 IntegrateBRDF(float NdotV, float roughness)<br>&#123;<br>    float3 V;<br>    V.x = sqrt(1 - NdotV * NdotV);<br>    V.y = 0.0;<br>    V.z = NdotV;<br><br>    float A = 0.0;<br>    float B = 0.0;<br><br>    float3 N = float3(0.0, 0.0, 1.0);<br><br>    int sampleCount = 1024;<br>    for(int i = 0; i &lt; sampleCount; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, sampleCount);<br>        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF<br>        float3 L = normalize(2.0 * dot(V,H) * H - V);<br><br>        float NdotL = max(L.z, 0.0);<br>        float NdotH = max(H.z, 0.0);<br>        float VdotH = max(0.0, dot(V, H));<br><br>        if(NdotL &gt; 0.0)<br>        &#123;<br>            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G<br>            float G_Vis = (G * VdotH) / (NdotH * NdotV);    <br>            float Fc = pow(1 - VdotH, 5.0);<br>            <br>            A += (1.0 - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= float(sampleCount);<br>    B /= float(sampleCount);<br>    return float2(A, B);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="反射探针"><strong>反射探针</strong></h3>
<p>在unity中添加 probe 然后 baked</p>
<p>使用 sampleSH 对 probe 进行采样</p>
<h3 id="environment-diffuse-ibl-specular">Environment Diffuse + IBL
Specular</h3>
<figure>
<img src="/imgs/LearnPBR/output3.PNG" srcset="/img/loading.gif" lazyload alt="output3" />
<figcaption aria-hidden="true">output3</figcaption>
</figure>
<p>中间是粗糙度越来越小 下面是金属度越来越大</p>
<h3 id="ibl-参考"><strong>IBL 参考</strong></h3>
<p><a
target="_blank" rel="noopener" href="https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/">Image
Based Lighting | Chetan Jags (wordpress.com)</a> <a
target="_blank" rel="noopener" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">course_notes_moving_frostbite_to_pbr_v32.pdf
(wordpress.com)</a>:4.9章节 <a
target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/">镜面IBL
- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66518450">深入理解 PBR/基于图像照明
(IBL) - 知乎 (zhihu.com)</a> <a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture5
Real-time Environment Mapping哔哩哔哩bilibili</a>: Split Sum</p>
<h2 id="杂项"><strong>杂项</strong></h2>
<ul>
<li>ComputeShader 使用 cubetex：[<a
target="_blank" rel="noopener" href="https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/">Compute
shader] Use TextureCube(Resolved)</a></li>
<li>TextureCube&lt;float4 cubemap; SamplerState _LinearClamp; float3
dir; cubemap.SampleLevel(_LinearClamp, dir, 0);</li>
<li>如何向Tex指定mipmap层级写入，在 setrendertarget 指定</li>
<li>compute Shader sample
<ul>
<li><code>float4 c = tex[id];</code></li>
<li>mipmap: <code>float4 c = tex.mips[0][id]</code> or
<code>tex.Load(uint3(id,0))</code></li>
<li>SampleLevel:</li>
<li>SampleState Sampler1 { Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4
t = tex.SampleLevel(Sample1, uv, 0);</li>
</ul></li>
<li>Sample filter <a target="_blank" rel="noopener" href="https://enjoyphysics.cn/Article1554">8.5
纹理采样 (enjoyphysics.cn)</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// 在倍增、缩减、多级渐进纹理上使用线性过滤。<br>SamplerState mySampler0 <br>&#123;<br>    Filter = MIN_MAG_MIP_LINEAR; <br>&#125;; <br><br>// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。<br>SamplerState mySampler1 <br>&#123; <br>    Filter = MIN_LINEAR_MAG_MIP_POINT; <br>&#125;; <br><br>// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。<br>SamplerState mySampler2 <br>&#123; <br>    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; <br>&#125;; <br><br>// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。<br>SamplerState mySampler3 <br>&#123; <br>    Filter = ANISOTROPIC; <br>    MaxAnisotropy = 4;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="unity-and-mipmap"><strong>Unity And Mipmap</strong></h3>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/419644293">【渲染】用计算着色器生成Mipmap
- 知乎 (zhihu.com)</a></p>
<h3 id="computer-指定-mipmap-写入"><strong>Computer 指定 Mipmap
写入</strong></h3>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">computeShader.SetTexture(kernal, “<span class="hljs-keyword">name</span>”, tex, mipmapLevel);<br></code></pre></td></tr></table></figure>
<h3 id="不同光源的衰减"><strong>不同光源的衰减</strong></h3>
<p><a
target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/">投光物
- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a
target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/">Point
and Spot Lights (catlikecoding.com)</a></p>
<h4 id="point-light"><strong>Point Light</strong></h4>
<ul>
<li><span class="math inline">\((\,max(0,
1-(\frac{d^2}{r^2})^2)\,)^2\)</span>，r 是 point light 的范围</li>
<li><span
class="math inline">\(\frac{1.0}{K_c+K_l*d+K_q*d^2}\)</span></li>
</ul>
<h3 id="shadergui"><strong>ShaderGUI</strong></h3>
<p>通过编写 ShaderGUI 在 Material 面板控制 shader properties</p>
<p>或 en/dis able keyword</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">public class MyShaderGUI : ShaderGUI<br>&#123;<br>    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)<br>    &#123;<br>        base.OnGUI(materialEditor, properties);<br>        Material material = materialEditor.target as Material;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Shader 结尾加上</p>
<p>CustomEditor "MyLearnPBRGUI";</p>
<h2 id="urp-光"><strong>URP 光</strong></h2>
<p><a
target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html">Light
组件参考 | Universal RP | 12.1.1 (unity3d.com)</a> <a
target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/LightModes.html">光照模式
- Unity 手册 (unity3d.com)</a> <a
target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html">光源模式：Baked
- Unity 手册 (unity3d.com)</a></p>
<h3 id="lighting"><strong>Lighting</strong></h3>
<ul>
<li>Scene/Mixed Lighting/Lighting Mode
<ul>
<li><strong>Baked Indirect</strong>: <a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html">Lighting
Mode：Baked Indirect - Unity 手册</a> 混合光源的行为类似于<a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html">实时光源</a>，但有额外的好处是会<strong>将间接光照烘焙到光照贴图中</strong>。<strong>混合(Mixed)光源照亮的游戏对象会投射实时阴影</strong>，最大距离是在项目中定义的<a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html">阴影距离
(Shadow Distance)</a>。</li>
<li><strong>Shadow Mask</strong>: <a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html">Lighting
Mode：Shadowmask - Unity 手册</a>
与烘焙间接照明模式类似，阴影遮罩照明模式将<strong>实时直接照明</strong>与<strong><a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html">烘焙间接照明</a>(Baked
Indirect Lighting
Mode)</strong>相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使
Unity
可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在<a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html">光照探针</a>中存储其他信息来实现此目的。Unity
为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。</li>
<li><strong>Subtractive</strong>: <a
target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html">Lighting
Mode：Subtractive - Unity 手册</a> 在 Subtractive
光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity
将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。
因为阴影被烘焙到光照贴图中，所以 Unity
在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity
提供了 <strong>Realtime Shadow Color</strong>
属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。
Subtractive
光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。</li>
</ul></li>
</ul>
<h2 id="isotropic-anisotropic-brdfs"><strong>Isotropic / Anisotropic
BRDFs</strong></h2>
<p><span class="math display">\[f_r(\theta_i,\phi_i;\theta_r,\phi_r)\ne
f_r(\theta_i,\phi_i,\phi_r-\phi_i)\\
i\;is\;input,\;r\;is\;reflection\;dir.\]</span></p>
<h3 id="ndf"><strong>NDF</strong></h3>
<p><strong>形状不变性</strong></p>
<ul>
<li><p>是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。</p></li>
<li><p>若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：</p></li>
<li><p><span class="math display">\[D(m)=\frac{1}{\alpha_2(n\cdot
m)^4}g(\frac{\sqrt{1-(n\cdot m)^2}}{\alpha(n\cdot m)})\]</span></p></li>
<li><p>其中g（）代表一个表示了NDF形状的一维函数。</p></li>
</ul>
<h4 id="anisotropic-beckmann-distribution"><strong>Anisotropic Beckmann
Distribution</strong></h4>
<p><span
class="math display">\[D_{Baniso}(m)=\frac{1}{\pi\alpha_x\alpha_y(n\cdot
m)^4}exp(-\frac{\frac{(t\cdot m)^2}{\alpha_x^2}+\frac{(b\cdot
m)^2}{\alpha_y^2}}{(n\cdot m)^2})\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// Anisotropic Beckmann<br>float D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;<br>*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="trowbridge-reitz-ggx-anisotropic"><strong>Trowbridge-Reitz GGX
Anisotropic</strong></h4>
<p><span
class="math display">\[D_{GGXaniso}(m)=\frac{1}{\pi\alpha_x\alpha_y}\frac{1}{(\frac{(x\cdot
m)^2}{\alpha_x^2}+\frac{(y\cdot m)^2}{\alpha_y^2}+(n\cdot
m))^2}\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs OpenGL">// Anisotropic GGX<br>// [Burley 2012, &quot;Physically-Based Shading at Disney&quot;]<br>float D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;<br>*    return 1 / ( PI * ax*ay * d*d );<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>其中，X为tangent，t切线方向，Y为binormal，b，副法线方向</li>
<li>需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf">2010-anisobrdf.pdf
(cuni.cz)</a> <a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/3tyXRt">Slope: GGX
Anisotropic (shadertoy.com)</a></p>
<h3 id="geometry-function"><strong>Geometry Function</strong></h3>
<p><span class="math display">\[G_1(m,v)=\frac{clamp(0,1,m\cdot
v)}{1+\Lambda(v)}\]</span></p>
<h4 id="beckmann"><strong>Beckmann</strong></h4>
<p><span
class="math display">\[\Lambda(v)=\frac{erf(a)-1}{2}+\frac{1}{2a\sqrt{\pi}}exp(-a^2)\\
a=\frac{1}{\alpha\tan\theta_o}\]</span></p>
<h4 id="ggx"><strong>GGX</strong></h4>
<p><span
class="math display">\[\Lambda(v)=\frac{-1+\sqrt{1+\frac{1}{a^2}}}{2}\\
a=\frac{1}{\alpha\tan\theta_o}\]</span></p>
<h3 id="anisotropic-geometry-function"><strong>Anisotropic Geometry
Function</strong></h3>
<h4 id="smith"><strong>Smith</strong></h4>
<p>假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。</p>
<p>假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴</p>
<p><span class="math display">\[a_x&#39;=a_x\frac{a_y}{a_x}=a_y\\
a_y&#39;=a_y\]</span></p>
<p>也就是粗糙度=_y</p>
<p><span
class="math display">\[v&#39;=(\frac{\alpha_x}{\alpha_y}x_o,y_o,z_o)=(\frac{\alpha_x}{\alpha_y}\cos\phi_o\sin\theta_o,\sin\phi_o\sin\theta_o,\cos\theta_o)\\
\frac{1}{\tan\theta&#39;_o}=\frac{z_o}{\sqrt{\frac{\alpha_x^2}{\alpha_y^2}x_o^2+y_o^2}}=\frac{1}{\sqrt{\frac{\alpha_x^2}{\alpha_y^2}\cos^2\phi_o+\sin^2\phi_o}\cdot\tan\theta_o}\\
Because:a=\frac{1}{\alpha\tan\theta_o}\\
a&#39;=\frac{1}{a_y\tan\theta_o}=\frac{1}{a_y\sqrt{\frac{\alpha_x^2}{\alpha_y^2}\cos^2\phi_o+\sin^2\phi_o}\cdot\tan\theta_o}\\
=\frac{1}{\sqrt{\alpha_x^2\cos^2\phi_o+\alpha_y^2\sin^2\phi_o}\cdot\tan\theta_o}\]</span></p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/haozi2008/article/details/112284028">PBR 五
几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客</a></p>
<p><a
target="_blank" rel="noopener" href="https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md">PBR-White-Paper/content/part
5/README.md at master · QianMo/PBR-White-Paper (github.com)</a></p>
<h3 id="output-1"><strong>Output</strong></h3>
<p><img src="/imgs/LearnPBR/output4-1.PNG" srcset="/img/loading.gif" lazyload alt="output4-1" style="zoom:50%;" /></p>
<p><img src="/imgs/LearnPBR/AnisoSphere2.png" srcset="/img/loading.gif" lazyload alt="AnisoSphere2" style="zoom:50%;" /></p>
<h3 id="anisotropic-ibl"><strong>Anisotropic IBL</strong></h3>
<h4 id="split-sum-2nd"><strong>Split Sum 2nd</strong></h4>
<p><span class="math display">\[R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\
R_0-R_0(1-\cos\theta)^5+(1-\cos\theta)^5\\
\int_{\Omega^+}f_r(p,w_i,w_o)\cos\theta_i\,\mathrm{d}w_i\approx\\
R_0\int_{\Omega^+}\frac{f_r}{F}(1-(1-\cos\theta)^5)\cos\theta_i\,\mathrm{d}w_i+\int_{\Omega^+}\frac{f_r}{F}(1-\cos\theta)^5\cos\theta_i\,\mathrm{d}w_i\]</span></p>
<p>roughness_x, roughness_y, theta 相关3D LUT了</p>
<h2
id="todo动态天空的环境光怎么计算"><strong>[TODO]动态天空的环境光怎么计算</strong></h2>
<p>提前烘焙，插值。</p>
<p>TOD</p>
<p>像大气散射，其实已经计算了 LUT 所以可以直接使用。</p>
<h2 id="unity-specular-cube0">Unity Specular Cube0</h2>
<p><a
target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620">Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl
at 19518485b3edcf19f267f293f899d5d25e734a17 ·
Unity-Technologies/Graphics (github.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);<br>    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);<br>    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);<br>    return irradiance * occlusion;<br></code></pre></td></tr></table></figure>
<h3
id="perceptualroughnesstomipmaplevel">PerceptualRoughnessToMipmapLevel</h3>
<p><a
target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27">Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl
at 19518485b3edcf19f267f293f899d5d25e734a17 ·
Unity-Technologies/Graphics (github.com)</a></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-built_in">real</span> PerceptualRoughnessToMipmapLevel(<span class="hljs-built_in">real</span> perceptualRoughness, <span class="hljs-built_in">uint</span> maxMipLevel)<br>&#123;<br>    perceptualRoughness = perceptualRoughness * (<span class="hljs-number">1.7</span> - <span class="hljs-number">0.7</span> * perceptualRoughness);<br><br>    <span class="hljs-keyword">return</span> perceptualRoughness * maxMipLevel;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0,
reflectVector, mip);</p>
<h2 id="参考-3"><strong>参考</strong></h2>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/10631718.html">由浅入深学习PBR的原理和实现
- 0向往0 - 博客园 (cnblogs.com)</a><br />
<a
target="_blank" rel="noopener" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">course_notes_moving_frostbite_to_pbr_v32.pdf
(wordpress.com)</a><br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53086060">【基于物理的渲染（PBR）白皮书】（一）
开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)</a><br />
<a target="_blank" rel="noopener" href="https://www.pbr-book.org/3ed-2018/contents">Physically Based
Rendering: From Theory to Implementation (pbr-book.org)</a><br />
Real-Time Rendering Fourth Edition 第九章<br />
<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture10
Real-Time Physically-based Materials (surface
models)哔哩哔哩bilibili</a><br />
<a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0">Lecture11
Real-Time Physically-based Materials (surface models
cont.)哔哩哔哩bilibili</a><br />
UE4: <a
target="_blank" rel="noopener" href="https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">2013SiggraphPresentationsNotes-26915738.pdf
(unrealengine.com)</a><br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144611412">寒霜引擎的PBR实践3.0（一）材质篇
- 知乎 (zhihu.com)</a><br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158261389">寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源
- 知乎 (zhihu.com)</a><br />
<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/186541854">寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光
- 知乎 (zhihu.com)</a><br />
[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/121719442">译]Real Shading in
Unreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)</a><br />
<a
target="_blank" rel="noopener" href="https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/">使用Compute
Shader计算球谐全局光照 | ZZNEWCLEAR13</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="print-no-link">#图形学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Learn PBR</div>
      <div>http://example.com/2023/11/14/LearnPBR/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Hollow Emiya</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/13/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9/" title="Hexo 主题变更">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hexo 主题变更</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/05/%E5%A4%A7%E6%B0%94%E6%95%A3%E5%B0%84/" title="大气散射">
                        <span class="hidden-mobile">大气散射</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
